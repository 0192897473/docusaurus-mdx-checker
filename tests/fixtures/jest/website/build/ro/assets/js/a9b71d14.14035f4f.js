"use strict";(self.webpackChunkjest_website=self.webpackChunkjest_website||[]).push([[9678],{3108:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var a=t(4246),s=t(1670);const r={id:"setup-teardown",title:"Asamblare \u0219i dezasamblare"},o=void 0,i={unversionedId:"setup-teardown",id:"setup-teardown",title:"Asamblare \u0219i dezasamblare",description:"Adesea, \xeen timp ce scrie\u021bi teste ave\u021bi nevoie de configur\u0103ri, care trebuie s\u0103 se ruleze \xeenainte de teste, \u015fi diverse cur\u0103\u021b\u0103ri, care trebuie s\u0103 se ruleze dup\u0103 execu\u021bia testelor. Jest ofer\u0103 func\u0163ii utilitare pentru aceste situa\u021bii.",source:"@site/i18n/ro/docusaurus-plugin-content-docs/current/SetupAndTeardown.md",sourceDirName:".",slug:"/setup-teardown",permalink:"/ro/docs/next/setup-teardown",draft:!1,unlisted:!1,editUrl:"https://crowdin.com/project/jest-v2/ro",tags:[],version:"current",frontMatter:{id:"setup-teardown",title:"Asamblare \u0219i dezasamblare"},sidebar:"docs",previous:{title:"Testarea codului asincron",permalink:"/ro/docs/next/asynchronous"},next:{title:"Func\u021bii pentru dubluri",permalink:"/ro/docs/next/mock-functions"}},c={},l=[{value:"Repeating Setup",id:"repeating-setup",level:2},{value:"Configurare unic\u0103",id:"configurare-unic\u0103",level:2},{value:"Delimitare",id:"delimitare",level:2},{value:"Order of Execution",id:"order-of-execution",level:2},{value:"Sfaturi generale",id:"sfaturi-generale",level:2}];function d(e){const n=Object.assign({p:"p",h2:"h2",code:"code",pre:"pre",a:"a",em:"em",admonition:"admonition"},(0,s.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Adesea, \xeen timp ce scrie\u021bi teste ave\u021bi nevoie de configur\u0103ri, care trebuie s\u0103 se ruleze \xeenainte de teste, \u015fi diverse cur\u0103\u021b\u0103ri, care trebuie s\u0103 se ruleze dup\u0103 execu\u021bia testelor. Jest ofer\u0103 func\u0163ii utilitare pentru aceste situa\u021bii."}),"\n",(0,a.jsx)(n.h2,{id:"repeating-setup",children:"Repeating Setup"}),"\n",(0,a.jsxs)(n.p,{children:["If you have some work you need to do repeatedly for many tests, you can use ",(0,a.jsx)(n.code,{children:"beforeEach"})," and ",(0,a.jsx)(n.code,{children:"afterEach"})," hooks."]}),"\n",(0,a.jsxs)(n.p,{children:["De exemplu, s\u0103 prespunem c\u0103 mai multe teste interac\u0163ioneaz\u0103 cu o baz\u0103 de date a ora\u015felor. Avem o metod\u0103 ",(0,a.jsx)(n.code,{children:"initializeCityDatabase()"})," care trebuie s\u0103 fie apelat\u0103 \xeenainte de fiecare dintre aceste teste, si o metod\u0103 ",(0,a.jsx)(n.code,{children:"clearCityDatabase()"})," care trebuie s\u0103 fie apelat\u0103 dup\u0103 fiecare dintre aceste teste. Aceasta se poate realiza cu:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"beforeEach(() => {\n  initializeCityDatabase();\n});\n\nafterEach(() => {\n  clearCityDatabase();\n});\n\ntest('city database has Vienna', () => {\n  expect(isCity('Vienna')).toBeTruthy();\n});\n\ntest('city database has San Juan', () => {\n  expect(isCity('San Juan')).toBeTruthy();\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"beforeEach"})," \u015fi ",(0,a.jsx)(n.code,{children:"afterEach"})," pot rula cod asincron \xeen acela\u015fi mod cum ",(0,a.jsx)(n.a,{href:"/ro/docs/next/asynchronous",children:"testele pot rula cod asincron"})," - fie primesc un parametru ",(0,a.jsx)(n.code,{children:"done"})," sau returneaz\u0103 o promisiune. De exemplu, \xeen cazul \xeen care ",(0,a.jsx)(n.code,{children:"initializeCityDatabase()"})," returneaz\u0103 o promisiune care este rezolvat\u0103 atunci c\xe2nd baza de date s-a ini\u021bializat, ar trebui s\u0103 return\u0103m acea promisiune:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"beforeEach(() => {\n  return initializeCityDatabase();\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"configurare-unic\u0103",children:"Configurare unic\u0103"}),"\n",(0,a.jsxs)(n.p,{children:["\xcen unele cazuri, trebuie s\u0103 configur\u0103m o singur\u0103 dat\u0103, la \xeenceputul unui fi\u015fier. This can be especially bothersome when the setup is asynchronous, so you can't do it inline. Jest provides ",(0,a.jsx)(n.code,{children:"beforeAll"})," and ",(0,a.jsx)(n.code,{children:"afterAll"})," hooks to handle this situation."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, if both ",(0,a.jsx)(n.code,{children:"initializeCityDatabase()"})," and ",(0,a.jsx)(n.code,{children:"clearCityDatabase()"})," returned promises, and the city database could be reused between tests, we could change our test code to:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"beforeAll(() => {\n  return initializeCityDatabase();\n});\n\nafterAll(() => {\n  return clearCityDatabase();\n});\n\ntest('city database has Vienna', () => {\n  expect(isCity('Vienna')).toBeTruthy();\n});\n\ntest('city database has San Juan', () => {\n  expect(isCity('San Juan')).toBeTruthy();\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"delimitare",children:"Delimitare"}),"\n",(0,a.jsxs)(n.p,{children:["The top level ",(0,a.jsx)(n.code,{children:"before*"})," and ",(0,a.jsx)(n.code,{children:"after*"})," hooks apply to every test in a file. The hooks declared inside a ",(0,a.jsx)(n.code,{children:"describe"})," block apply only to the tests within that ",(0,a.jsx)(n.code,{children:"describe"})," block."]}),"\n",(0,a.jsx)(n.p,{children:"For example, let's say we had not just a city database, but also a food database. We could do different setup for different tests:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Applies to all tests in this file\nbeforeEach(() => {\n  return initializeCityDatabase();\n});\n\ntest('city database has Vienna', () => {\n  expect(isCity('Vienna')).toBeTruthy();\n});\n\ntest('city database has San Juan', () => {\n  expect(isCity('San Juan')).toBeTruthy();\n});\n\ndescribe('matching cities to foods', () => {\n  // Applies only to tests in this describe block\n  beforeEach(() => {\n    return initializeFoodDatabase();\n  });\n\n  test('Vienna <3 veal', () => {\n    expect(isValidCityFoodPair('Vienna', 'Wiener Schnitzel')).toBe(true);\n  });\n\n  test('San Juan <3 plantains', () => {\n    expect(isValidCityFoodPair('San Juan', 'Mofongo')).toBe(true);\n  });\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Note that the top-level ",(0,a.jsx)(n.code,{children:"beforeEach"})," is executed before the ",(0,a.jsx)(n.code,{children:"beforeEach"})," inside the ",(0,a.jsx)(n.code,{children:"describe"})," block. It may help to illustrate the order of execution of all hooks."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"beforeAll(() => console.log('1 - beforeAll'));\nafterAll(() => console.log('1 - afterAll'));\nbeforeEach(() => console.log('1 - beforeEach'));\nafterEach(() => console.log('1 - afterEach'));\n\ntest('', () => console.log('1 - test'));\n\ndescribe('Scoped / Nested block', () => {\n  beforeAll(() => console.log('2 - beforeAll'));\n  afterAll(() => console.log('2 - afterAll'));\n  beforeEach(() => console.log('2 - beforeEach'));\n  afterEach(() => console.log('2 - afterEach'));\n\n  test('', () => console.log('2 - test'));\n});\n\n// 1 - beforeAll\n// 1 - beforeEach\n// 1 - test\n// 1 - afterEach\n// 2 - beforeAll\n// 1 - beforeEach\n// 2 - beforeEach\n// 2 - test\n// 2 - afterEach\n// 1 - afterEach\n// 2 - afterAll\n// 1 - afterAll\n"})}),"\n",(0,a.jsx)(n.h2,{id:"order-of-execution",children:"Order of Execution"}),"\n",(0,a.jsxs)(n.p,{children:["Jest executes all describe handlers in a test file ",(0,a.jsx)(n.em,{children:"before"})," it executes any of the actual tests. This is another reason to do setup and teardown inside ",(0,a.jsx)(n.code,{children:"before*"})," and ",(0,a.jsx)(n.code,{children:"after*"})," handlers rather than inside the ",(0,a.jsx)(n.code,{children:"describe"})," blocks. Once the ",(0,a.jsx)(n.code,{children:"describe"})," blocks are complete, by default Jest runs all the tests serially in the order they were encountered in the collection phase, waiting for each to finish and be tidied up before moving on."]}),"\n",(0,a.jsx)(n.p,{children:"Consider the following illustrative test file and output:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"describe('describe outer', () => {\n  console.log('describe outer-a');\n\n  describe('describe inner 1', () => {\n    console.log('describe inner 1');\n\n    test('test 1', () => console.log('test 1'));\n  });\n\n  console.log('describe outer-b');\n\n  test('test 2', () => console.log('test 2'));\n\n  describe('describe inner 2', () => {\n    console.log('describe inner 2');\n\n    test('test 3', () => console.log('test 3'));\n  });\n\n  console.log('describe outer-c');\n});\n\n// describe outer-a\n// describe inner 1\n// describe outer-b\n// describe inner 2\n// describe outer-c\n// test 1\n// test 2\n// test 3\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Just like the ",(0,a.jsx)(n.code,{children:"describe"})," and ",(0,a.jsx)(n.code,{children:"test"})," blocks Jest calls the ",(0,a.jsx)(n.code,{children:"before*"})," and ",(0,a.jsx)(n.code,{children:"after*"})," hooks in the order of declaration. Note that the ",(0,a.jsx)(n.code,{children:"after*"})," hooks of the enclosing scope are called first. For example, here is how you can set up and tear down resources which depend on each other:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"beforeEach(() => console.log('connection setup'));\nbeforeEach(() => console.log('database setup'));\n\nafterEach(() => console.log('database teardown'));\nafterEach(() => console.log('connection teardown'));\n\ntest('test 1', () => console.log('test 1'));\n\ndescribe('extra', () => {\n  beforeEach(() => console.log('extra database setup'));\n  afterEach(() => console.log('extra database teardown'));\n\n  test('test 2', () => console.log('test 2'));\n});\n\n// connection setup\n// database setup\n// test 1\n// database teardown\n// connection teardown\n\n// connection setup\n// database setup\n// extra database setup\n// test 2\n// extra database teardown\n// database teardown\n// connection teardown\n"})}),"\n",(0,a.jsxs)(n.admonition,{type:"note",children:[(0,a.jsxs)(n.p,{children:["If you are using ",(0,a.jsx)(n.code,{children:"jasmine2"})," test runner, take into account that it calls the ",(0,a.jsx)(n.code,{children:"after*"})," hooks in the reverse order of declaration. To have identical output, the above example should be altered like this:"]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-diff",children:"  beforeEach(() => console.log('connection setup'));\n+ afterEach(() => console.log('connection teardown'));\n\n  beforeEach(() => console.log('database setup'));\n+ afterEach(() => console.log('database teardown'));\n\n- afterEach(() => console.log('database teardown'));\n- afterEach(() => console.log('connection teardown'));\n\n  // ...\n"})})]}),"\n",(0,a.jsx)(n.h2,{id:"sfaturi-generale",children:"Sfaturi generale"}),"\n",(0,a.jsxs)(n.p,{children:["\xcen cazul \xeen care un test e\u0219ueaz\u0103, unul dintre primele lucruri pe care ar trebui s\u0103 le verifica\u0163i este dac\u0103 dac\u0103 testul cade si atunci c\xe2nd ruleaz\u0103 doar el. To run only one test with Jest, temporarily change that ",(0,a.jsx)(n.code,{children:"test"})," command to a ",(0,a.jsx)(n.code,{children:"test.only"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"test.only('this will be the only test that runs', () => {\n  expect(true).toBe(false);\n});\n\ntest('this test will not run', () => {\n  expect('A').toBe('A');\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Dac\u0103 ave\u0163i un test care cade adesea atunci c\xe2nd face parte dintr-o suit\u0103 mai mare de teste, dar nu cade atunci c\xe2nd ruleaz\u0103 singur, cu siguran\u021b\u0103 ceva de la un test precedent interfereaz\u0103 cu acesta. Pute\u0163i rezolva adesea acest lucru cur\u0103\u021barea st\u0103rii comune cu ",(0,a.jsx)(n.code,{children:"beforeEach"}),". If you're not sure whether some shared state is being modified, you can also try a ",(0,a.jsx)(n.code,{children:"beforeEach"})," that logs data."]})]})}const u=function(e={}){const{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,a.jsx)(n,Object.assign({},e,{children:(0,a.jsx)(d,e)})):d(e)}},1670:(e,n,t)=>{t.d(n,{Zo:()=>i,ah:()=>r});var a=t(7378);const s=a.createContext({});function r(e){const n=a.useContext(s);return a.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}const o={};function i({components:e,children:n,disableParentContext:t}){let i;return i=t?"function"==typeof e?e({}):e||o:r(e),a.createElement(s.Provider,{value:i},n)}}}]);