"use strict";(self.webpackChunkjest_website=self.webpackChunkjest_website||[]).push([[672],{566:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>d,default:()=>m,frontMatter:()=>l,metadata:()=>h,toc:()=>p});var s=t(4246),i=t(1670),r=t(8447),a=t(2599),o=t(9459),c=t(6294);const l={id:"expect",title:"A\u015ftept\u0103ri"},d=void 0,h={unversionedId:"expect",id:"version-29.6/expect",title:"A\u015ftept\u0103ri",description:'When you\'re writing tests, you often need to check that values meet certain conditions. expect gives you access to a number of "matchers" that let you validate different things.',source:"@site/i18n/ro/docusaurus-plugin-content-docs/version-29.6/ExpectAPI.md",sourceDirName:".",slug:"/expect",permalink:"/ro/docs/expect",draft:!1,unlisted:!1,editUrl:"https://crowdin.com/project/jest-v2/ro",tags:[],version:"29.6",frontMatter:{id:"expect",title:"A\u015ftept\u0103ri"},sidebar:"api",previous:{title:"Globale",permalink:"/ro/docs/api"},next:{title:"Func\u021bii pentru dubluri",permalink:"/ro/docs/mock-function-api"}},u={},p=[{value:"Reference",id:"reference",level:2},{value:"A\u015ftept\u0103ri",id:"a\u015ftept\u0103ri",level:2},{value:"<code>expect(value)</code>",id:"expectvalue",level:3},{value:"Modifiers",id:"modifiers",level:2},{value:"<code>.not</code>",id:"not",level:3},{value:"<code>.resolves</code>",id:"resolves",level:3},{value:"<code>.rejects</code>",id:"rejects",level:3},{value:"Matchers",id:"matchers",level:2},{value:"<code>.toBe(value)</code>",id:"tobevalue",level:3},{value:"<code>.toHaveBeenCalled()</code>",id:"tohavebeencalled",level:3},{value:"<code>.toHaveBeenCalledTimes(number)</code>",id:"tohavebeencalledtimesnumber",level:3},{value:"<code>.toHaveBeenCalledWith(arg1, arg2, ...)</code>",id:"tohavebeencalledwitharg1-arg2-",level:3},{value:"<code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code>",id:"tohavebeenlastcalledwitharg1-arg2-",level:3},{value:"<code>.toHaveBeenNthCalledWith(nthCall, arg1, arg2, ....)</code>",id:"tohavebeennthcalledwithnthcall-arg1-arg2-",level:3},{value:"<code>.toHaveReturned()</code>",id:"tohavereturned",level:3},{value:"<code>.toHaveReturnedTimes(number)</code>",id:"tohavereturnedtimesnumber",level:3},{value:"<code>.toHaveReturnedWith(value)</code>",id:"tohavereturnedwithvalue",level:3},{value:"<code>.toHaveLastReturnedWith(value)</code>",id:"tohavelastreturnedwithvalue",level:3},{value:"<code>.toHaveNthReturnedWith(nthCall, value)</code>",id:"tohaventhreturnedwithnthcall-value",level:3},{value:"<code>.toHaveLength(number)</code>",id:"tohavelengthnumber",level:3},{value:"<code>.toHaveProperty(keyPath, value?)</code>",id:"tohavepropertykeypath-value",level:3},{value:"<code>.toBeCloseTo(number, numDigits?)</code>",id:"tobeclosetonumber-numdigits",level:3},{value:"<code>.toBeDefined()</code>",id:"tobedefined",level:3},{value:"<code>.toBeFalsy()</code>",id:"tobefalsy",level:3},{value:"<code>.toBeGreaterThan(number | bigint)</code>",id:"tobegreaterthannumber--bigint",level:3},{value:"<code>.toBeGreaterThanOrEqual(number | bigint)</code>",id:"tobegreaterthanorequalnumber--bigint",level:3},{value:"<code>.toBeLessThan(number | bigint)</code>",id:"tobelessthannumber--bigint",level:3},{value:"<code>.toBeLessThanOrEqual(number | bigint)</code>",id:"tobelessthanorequalnumber--bigint",level:3},{value:"<code>.toBeInstanceOf(Class)</code>",id:"tobeinstanceofclass",level:3},{value:"<code>.toBeNull()</code>",id:"tobenull",level:3},{value:"<code>.toBeTruthy()</code>",id:"tobetruthy",level:3},{value:"<code>.toBeUndefined()</code>",id:"tobeundefined",level:3},{value:"<code>.toBeNaN()</code>",id:"tobenan",level:3},{value:"<code>.toContain(item)</code>",id:"tocontainitem",level:3},{value:"<code>.toContainEqual(item)</code>",id:"tocontainequalitem",level:3},{value:"<code>.toEqual(value)</code>",id:"toequalvalue",level:3},{value:"<code>.toMatch(regexp | string)</code>",id:"tomatchregexp--string",level:3},{value:"<code>.toMatchObject(object)</code>",id:"tomatchobjectobject",level:3},{value:"<code>.toMatchSnapshot(propertyMatchers?, hint?)</code>",id:"tomatchsnapshotpropertymatchers-hint",level:3},{value:"<code>.toMatchInlineSnapshot(propertyMatchers?, inlineSnapshot)</code>",id:"tomatchinlinesnapshotpropertymatchers-inlinesnapshot",level:3},{value:"<code>.toStrictEqual(value)</code>",id:"tostrictequalvalue",level:3},{value:"<code>.toThrow(error?)</code>",id:"tothrowerror",level:3},{value:"<code>.toThrowErrorMatchingSnapshot(hint?)</code>",id:"tothrowerrormatchingsnapshothint",level:3},{value:"<code>.toThrowErrorMatchingInlineSnapshot(inlineSnapshot)</code>",id:"tothrowerrormatchinginlinesnapshotinlinesnapshot",level:3},{value:"Asymmetric Matchers",id:"asymmetric-matchers",level:2},{value:"<code>expect.anything()</code>",id:"expectanything",level:3},{value:"<code>expect.any(constructor)</code>",id:"expectanyconstructor",level:3},{value:"<code>expect.arrayContaining(array)</code>",id:"expectarraycontainingarray",level:3},{value:"<code>expect.not.arrayContaining(array)</code>",id:"expectnotarraycontainingarray",level:3},{value:"<code>expect.closeTo(number, numDigits?)</code>",id:"expectclosetonumber-numdigits",level:3},{value:"<code>expect.objectContaining(object)</code>",id:"expectobjectcontainingobject",level:3},{value:"<code>expect.not.objectContaining(object)</code>",id:"expectnotobjectcontainingobject",level:3},{value:"<code>expect.stringContaining(string)</code>",id:"expectstringcontainingstring",level:3},{value:"<code>expect.not.stringContaining(string)</code>",id:"expectnotstringcontainingstring",level:3},{value:"<code>expect.stringMatching(string | regexp)</code>",id:"expectstringmatchingstring--regexp",level:3},{value:"<code>expect.not.stringMatching(string | regexp)</code>",id:"expectnotstringmatchingstring--regexp",level:3},{value:"Assertion Count",id:"assertion-count",level:2},{value:"<code>expect.assertions(number)</code>",id:"expectassertionsnumber",level:3},{value:"<code>expect.hasAssertions()</code>",id:"expecthasassertions",level:3},{value:"Extend Utilities",id:"extend-utilities",level:2},{value:"<code>expect.addEqualityTesters(testers)</code>",id:"expectaddequalitytesterstesters",level:3},{value:"Custom equality testers API",id:"custom-equality-testers-api",level:4},{value:"<code>this.equals(a, b, customTesters?)</code>",id:"thisequalsa-b-customtesters",level:4},{value:"Matchers vs Testers",id:"matchers-vs-testers",level:4},{value:"Recursive custom equality testers",id:"recursive-custom-equality-testers",level:4},{value:"<code>expect.addSnapshotSerializer(serializer)</code>",id:"expectaddsnapshotserializerserializer",level:3},{value:"<code>expect.extend(matchers)</code>",id:"expectextendmatchers",level:3},{value:"Async Matchers",id:"async-matchers",level:4},{value:"Custom Matchers API",id:"custom-matchers-api",level:4},{value:"<code>this.isNot</code>",id:"thisisnot",level:4},{value:"<code>this.promise</code>",id:"thispromise",level:4},{value:"<code>this.equals(a, b, customTesters?)</code>",id:"thisequalsa-b-customtesters-1",level:4},{value:"<code>this.expand</code>",id:"thisexpand",level:4},{value:"<code>this.utils</code>",id:"thisutils",level:4},{value:"<code>this.customTesters</code>",id:"thiscustomtesters",level:4},{value:"Custom snapshot matchers",id:"custom-snapshot-matchers",level:4},{value:"async",id:"async",level:4},{value:"Bail out",id:"bail-out",level:4}];function x(e){const n=Object.assign({p:"p",code:"code",admonition:"admonition",a:"a",h2:"h2",hr:"hr",h3:"h3",pre:"pre",strong:"strong",ul:"ul",li:"li",em:"em",h4:"h4"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["When you're writing tests, you often need to check that values meet certain conditions. ",(0,s.jsx)(n.code,{children:"expect"}),' gives you access to a number of "matchers" that let you validate different things.']}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["For additional Jest matchers maintained by the Jest Community check out ",(0,s.jsx)(n.a,{href:"https://github.com/jest-community/jest-extended",children:(0,s.jsx)(n.code,{children:"jest-extended"})}),"."]})}),"\n","\n",(0,s.jsx)(o.ZP,{}),"\n",(0,s.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n","\n","\n",(0,s.jsx)(c.Z,{toc:p.slice(1)}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"a\u015ftept\u0103ri",children:"A\u015ftept\u0103ri"}),"\n",(0,s.jsx)(n.h3,{id:"expectvalue",children:(0,s.jsx)(n.code,{children:"expect(value)"})}),"\n",(0,s.jsxs)(n.p,{children:["Func\u0163ia ",(0,s.jsx)(n.code,{children:"expect"})," este folosit\u0103 de fiecare dat\u0103 c\xe2nd vrei s\u0103 testezi o valoare. Foarte rar vei apela ",(0,s.jsx)(n.code,{children:"expect"})," de una singur\u0103. \xcen schimb, vei folosi ",(0,s.jsx)(n.code,{children:"expect"}),' \xeempreun\u0103 cu func\u021bie de "comparare" pentru a pretinde ceva despre o valoare.']}),"\n",(0,s.jsxs)(n.p,{children:["Este mai u\u015for de \xeen\u0163eles acest lucru printr-un exemplu. S\u0103 presupunem c\u0103 ave\u0163i o metod\u0103 ",(0,s.jsx)(n.code,{children:"bestLaCroixFlavor()"})," care ar trebui s\u0103 returneze ",(0,s.jsx)(n.code,{children:"'grapefruit'"}),". Iat\u0103 cum ai testa acest lucru:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('the best flavor is grapefruit', () => {\n  expect(bestLaCroixFlavor()).toBe('grapefruit');\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this case, ",(0,s.jsx)(n.code,{children:"toBe"})," is the matcher function. There are a lot of different matcher functions, documented below, to help you test different things."]}),"\n",(0,s.jsxs)(n.p,{children:["Argumentul func\u021biei ",(0,s.jsx)(n.code,{children:"expect"})," trebuie s\u0103 fie valoarea care produce codul \u015fi orice argument pentru func\u021bia comparator ar trebui s\u0103 fie valoarea corect\u0103. Dac\u0103 le amesteca\u021bi, testele vor func\u0163iona \xeen continuare, dar mesajele de eroare pentru testele e\u0219uate vor ar\u0103ta ciudat."]}),"\n",(0,s.jsx)(n.h2,{id:"modifiers",children:"Modifiers"}),"\n",(0,s.jsx)(n.h3,{id:"not",children:(0,s.jsx)(n.code,{children:".not"})}),"\n",(0,s.jsxs)(n.p,{children:["If you know how to test something, ",(0,s.jsx)(n.code,{children:".not"})," lets you test its opposite. For example, this code tests that the best La Croix flavor is not coconut:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('the best flavor is not coconut', () => {\n  expect(bestLaCroixFlavor()).not.toBe('coconut');\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"resolves",children:(0,s.jsx)(n.code,{children:".resolves"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"resolves"})," to unwrap the value of a fulfilled promise so any other matcher can be chained. If the promise is rejected the assertion fails."]}),"\n",(0,s.jsxs)(n.p,{children:["De exemplu, acest cod testeaz\u0103 c\u0103 promisiunea se rezolv\u0103 \u015fi c\u0103 valoarea rezultat\u0103 este ",(0,s.jsx)(n.code,{children:"'lemon'"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('resolves to lemon', () => {\n  // make sure to add a return statement\n  return expect(Promise.resolve('lemon')).resolves.toBe('lemon');\n});\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["Since you are still testing promises, the test is still asynchronous. Hence, you will need to ",(0,s.jsx)(n.a,{href:"/ro/docs/asynchronous#promises",children:"tell Jest to wait"})," by returning the unwrapped assertion."]}),(0,s.jsxs)(n.p,{children:["Alternativ, pute\u0163i utiliza ",(0,s.jsx)(n.code,{children:"async/await"})," \xeen combina\u0163ie cu ",(0,s.jsx)(n.code,{children:".resolves"}),":"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('resolves to lemon', async () => {\n  await expect(Promise.resolve('lemon')).resolves.toBe('lemon');\n  await expect(Promise.resolve('lemon')).resolves.not.toBe('octopus');\n});\n"})})]}),"\n",(0,s.jsx)(n.h3,{id:"rejects",children:(0,s.jsx)(n.code,{children:".rejects"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".rejects"})," to unwrap the reason of a rejected promise so any other matcher can be chained. If the promise is fulfilled the assertion fails."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, this code tests that the promise rejects with reason ",(0,s.jsx)(n.code,{children:"'octopus'"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('rejects to octopus', () => {\n  // make sure to add a return statement\n  return expect(Promise.reject(new Error('octopus'))).rejects.toThrow(\n    'octopus',\n  );\n});\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["Since you are still testing promises, the test is still asynchronous. Hence, you will need to ",(0,s.jsx)(n.a,{href:"/ro/docs/asynchronous#promises",children:"tell Jest to wait"})," by returning the unwrapped assertion."]}),(0,s.jsxs)(n.p,{children:["Alternatively, you can use ",(0,s.jsx)(n.code,{children:"async/await"})," in combination with ",(0,s.jsx)(n.code,{children:".rejects"}),"."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('rejects to octopus', async () => {\n  await expect(Promise.reject(new Error('octopus'))).rejects.toThrow('octopus');\n});\n"})})]}),"\n",(0,s.jsx)(n.h2,{id:"matchers",children:"Matchers"}),"\n",(0,s.jsx)(n.h3,{id:"tobevalue",children:(0,s.jsx)(n.code,{children:".toBe(value)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toBe"})," to compare primitive values or to check referential identity of object instances. It calls ",(0,s.jsx)(n.code,{children:"Object.is"})," to compare values, which is even better for testing than ",(0,s.jsx)(n.code,{children:"==="})," strict equality operator."]}),"\n",(0,s.jsxs)(n.p,{children:["De exemplu, acest cod va valida unele propriet\u0103\u0163i ale obiectului ",(0,s.jsx)(n.code,{children:"can"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const can = {\n  name: 'pamplemousse',\n  ounces: 12,\n};\n\ndescribe('the can', () => {\n  test('has 12 ounces', () => {\n    expect(can.ounces).toBe(12);\n  });\n\n  test('has a sophisticated name', () => {\n    expect(can.name).toBe('pamplemousse');\n  });\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Don't use ",(0,s.jsx)(n.code,{children:".toBe"})," with floating-point numbers. De exemplu, din cauza rotunjirilor, \xeen JavaScript ",(0,s.jsx)(n.code,{children:"0.2 + 0.1"})," nu este strict egal cu ",(0,s.jsx)(n.code,{children:"0.3"}),". Dac\u0103 ave\u0163i numerele cu virgul\u0103 mobil\u0103, \xeencerca\u0163i ",(0,s.jsx)(n.code,{children:".toBeCloseTo"})," \xeen schimb."]}),"\n",(0,s.jsxs)(n.p,{children:["Although the ",(0,s.jsx)(n.code,{children:".toBe"})," matcher ",(0,s.jsx)(n.strong,{children:"checks"})," referential identity, it ",(0,s.jsx)(n.strong,{children:"reports"})," a deep comparison of values if the assertion fails. If differences between properties do not help you to understand why a test fails, especially if the report is large, then you might move the comparison into the ",(0,s.jsx)(n.code,{children:"expect"})," function. For example, to assert whether or not elements are the same instance:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["rewrite ",(0,s.jsx)(n.code,{children:"expect(received).toBe(expected)"})," as ",(0,s.jsx)(n.code,{children:"expect(Object.is(received, expected)).toBe(true)"})]}),"\n",(0,s.jsxs)(n.li,{children:["rewrite ",(0,s.jsx)(n.code,{children:"expect(received).not.toBe(expected)"})," as ",(0,s.jsx)(n.code,{children:"expect(Object.is(received, expected)).toBe(false)"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"tohavebeencalled",children:(0,s.jsx)(n.code,{children:".toHaveBeenCalled()"})}),"\n",(0,s.jsxs)(n.p,{children:["Exist\u0103 \u0219i cu aliasul: ",(0,s.jsx)(n.code,{children:".toBeCalled()"})]}),"\n",(0,s.jsxs)(n.p,{children:["Utiliza\u0163i ",(0,s.jsx)(n.code,{children:".toHaveBeenCalledWith"})," pentru a v\u0103 asigura c\u0103 o func\u0163ie mock a fost apelat\u0103 cu ni\u0219te argumente specifice. The arguments are checked with the same algorithm that ",(0,s.jsx)(n.code,{children:".toEqual"})," uses."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's say you have a ",(0,s.jsx)(n.code,{children:"drinkAll(drink, flavour)"})," function that takes a ",(0,s.jsx)(n.code,{children:"drink"})," function and applies it to all available beverages. You might want to check that ",(0,s.jsx)(n.code,{children:"drink"})," gets called for ",(0,s.jsx)(n.code,{children:"'lemon'"}),", but not for ",(0,s.jsx)(n.code,{children:"'octopus'"}),", because ",(0,s.jsx)(n.code,{children:"'octopus'"})," flavour is really weird and why would anything be octopus-flavoured? Se poate face asta cu urm\u0103torul test:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function drinkAll(callback, flavour) {\n  if (flavour !== 'octopus') {\n    callback(flavour);\n  }\n}\n\ndescribe('drinkAll', () => {\n  test('drinks something lemon-flavoured', () => {\n    const drink = jest.fn();\n    drinkAll(drink, 'lemon');\n    expect(drink).toHaveBeenCalled();\n  });\n\n  test('does not drink something octopus-flavoured', () => {\n    const drink = jest.fn();\n    drinkAll(drink, 'octopus');\n    expect(drink).not.toHaveBeenCalled();\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavebeencalledtimesnumber",children:(0,s.jsx)(n.code,{children:".toHaveBeenCalledTimes(number)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".toBeCalledTimes(number)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Utiliza\u0163i ",(0,s.jsx)(n.code,{children:". toHaveBeenCalledTimes "})," pentru a v\u0103 asigura c\u0103 o func\u0163ie mock a fost apelat\u0103 de un anumit num\u0103r de ori."]}),"\n",(0,s.jsxs)(n.p,{children:["De exemplu, s\u0103 presupunem c\u0103 avem o func\u0163ie ",(0,s.jsx)(n.code,{children:"drinkEach(drink, Array<flavor>)"}),", care prime\u0219te o func\u0163ie ",(0,s.jsx)(n.code,{children:"drink"})," pe care o aplic\u0103 tuturor b\u0103uturilor primite. A\u0163i putea verifica faptul c\u0103 func\u0163ia a fost apelat\u0103 de un num\u0103r exact de ori. Se poate face asta cu urm\u0103torul test:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drinkEach drinks each drink', () => {\n  const drink = jest.fn();\n  drinkEach(drink, ['lemon', 'octopus']);\n  expect(drink).toHaveBeenCalledTimes(2);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavebeencalledwitharg1-arg2-",children:(0,s.jsx)(n.code,{children:".toHaveBeenCalledWith(arg1, arg2, ...)"})}),"\n",(0,s.jsxs)(n.p,{children:["Exist\u0103 \u0219i cu aliasul: ",(0,s.jsx)(n.code,{children:".toBeCalledWith()"})]}),"\n",(0,s.jsxs)(n.p,{children:["Utiliza\u0163i ",(0,s.jsx)(n.code,{children:".toHaveBeenCalledWith"})," pentru a v\u0103 asigura c\u0103 o func\u0163ie mock a fost apelat\u0103 cu ni\u0219te argumente specifice. The arguments are checked with the same algorithm that ",(0,s.jsx)(n.code,{children:".toEqual"})," uses."]}),"\n",(0,s.jsxs)(n.p,{children:["De exemplu, s\u0103 spunem c\u0103 pute\u0163i \xeenregistra o b\u0103utur\u0103 cu func\u021bie ",(0,s.jsx)(n.code,{children:"register"}),", \u015fi ",(0,s.jsx)(n.code,{children:"applyToAll(f)"})," ar trebui s\u0103 aplice func\u021bia ",(0,s.jsx)(n.code,{children:"f"})," tuturor b\u0103uturilor \xeenregistrate. Pentru a v\u0103 asigura c\u0103 aceasta func\u0163ioneaz\u0103, a\u021bi putea scrie:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('registration applies correctly to orange La Croix', () => {\n  const beverage = new LaCroix('orange');\n  register(beverage);\n  const f = jest.fn();\n  applyToAll(f);\n  expect(f).toHaveBeenCalledWith(beverage);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavebeenlastcalledwitharg1-arg2-",children:(0,s.jsx)(n.code,{children:".toHaveBeenLastCalledWith(arg1, arg2, ...)"})}),"\n",(0,s.jsxs)(n.p,{children:["Exist\u0103 \u0219i cu aliasul: ",(0,s.jsx)(n.code,{children:".lastCalledWith(arg1, arg2, ...)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Dac\u0103 ave\u0163i o func\u0163ie mock, pute\u0163i utiliza ",(0,s.jsx)(n.code,{children:".toHaveBeenLastCalledWith"})," pentru a testa cu ce argumente a fost apelat\u0103 ultima dat\u0103. De exemplu, s\u0103 presupunem c\u0103 ave\u0163i o func\u0163ie ",(0,s.jsx)(n.code,{children:"applyToAllFlavors(f)"}),", care aplic\u0103 ",(0,s.jsx)(n.code,{children:"f"})," la o gr\u0103mad\u0103 de arome, \u015fi dori\u0163i s\u0103 v\u0103 asigura\u0163i c\u0103, atunci c\xe2nd o apela\u021bi, ultima arom\u0103 cu care opereaz\u0103 este ",(0,s.jsx)(n.code,{children:"'mango'"}),". Pute\u0163i scrie:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('applying to all flavors does mango last', () => {\n  const drink = jest.fn();\n  applyToAllFlavors(drink);\n  expect(drink).toHaveBeenLastCalledWith('mango');\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavebeennthcalledwithnthcall-arg1-arg2-",children:(0,s.jsx)(n.code,{children:".toHaveBeenNthCalledWith(nthCall, arg1, arg2, ....)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".nthCalledWith(nthCall, arg1, arg2, ...)"})]}),"\n",(0,s.jsxs)(n.p,{children:["If you have a mock function, you can use ",(0,s.jsx)(n.code,{children:".toHaveBeenNthCalledWith"})," to test what arguments it was nth called with. For example, let's say you have a ",(0,s.jsx)(n.code,{children:"drinkEach(drink, Array<flavor>)"})," function that applies ",(0,s.jsx)(n.code,{children:"f"})," to a bunch of flavors, and you want to ensure that when you call it, the first flavor it operates on is ",(0,s.jsx)(n.code,{children:"'lemon'"})," and the second one is ",(0,s.jsx)(n.code,{children:"'octopus'"}),". Pute\u0163i scrie:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drinkEach drinks each drink', () => {\n  const drink = jest.fn();\n  drinkEach(drink, ['lemon', 'octopus']);\n  expect(drink).toHaveBeenNthCalledWith(1, 'lemon');\n  expect(drink).toHaveBeenNthCalledWith(2, 'octopus');\n});\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"The nth argument must be positive integer starting from 1."})}),"\n",(0,s.jsx)(n.h3,{id:"tohavereturned",children:(0,s.jsx)(n.code,{children:".toHaveReturned()"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".toReturn()"})]}),"\n",(0,s.jsxs)(n.p,{children:["If you have a mock function, you can use ",(0,s.jsx)(n.code,{children:".toHaveReturned"})," to test that the mock function successfully returned (i.e., did not throw an error) at least one time. For example, let's say you have a mock ",(0,s.jsx)(n.code,{children:"drink"})," that returns ",(0,s.jsx)(n.code,{children:"true"}),". Pute\u0163i scrie:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drinks returns', () => {\n  const drink = jest.fn(() => true);\n\n  drink();\n\n  expect(drink).toHaveReturned();\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavereturnedtimesnumber",children:(0,s.jsx)(n.code,{children:".toHaveReturnedTimes(number)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".toReturnTimes(number)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toHaveReturnedTimes"})," to ensure that a mock function returned successfully (i.e., did not throw an error) an exact number of times. Any calls to the mock function that throw an error are not counted toward the number of times the function returned."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's say you have a mock ",(0,s.jsx)(n.code,{children:"drink"})," that returns ",(0,s.jsx)(n.code,{children:"true"}),". Pute\u0163i scrie:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drink returns twice', () => {\n  const drink = jest.fn(() => true);\n\n  drink();\n  drink();\n\n  expect(drink).toHaveReturnedTimes(2);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavereturnedwithvalue",children:(0,s.jsx)(n.code,{children:".toHaveReturnedWith(value)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".toReturnWith(value)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toHaveReturnedWith"})," to ensure that a mock function returned a specific value."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's say you have a mock ",(0,s.jsx)(n.code,{children:"drink"})," that returns the name of the beverage that was consumed. Pute\u0163i scrie:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drink returns La Croix', () => {\n  const beverage = {name: 'La Croix'};\n  const drink = jest.fn(beverage => beverage.name);\n\n  drink(beverage);\n\n  expect(drink).toHaveReturnedWith('La Croix');\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavelastreturnedwithvalue",children:(0,s.jsx)(n.code,{children:".toHaveLastReturnedWith(value)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".lastReturnedWith(value)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toHaveLastReturnedWith"})," to test the specific value that a mock function last returned. If the last call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's say you have a mock ",(0,s.jsx)(n.code,{children:"drink"})," that returns the name of the beverage that was consumed. Pute\u0163i scrie:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drink returns La Croix (Orange) last', () => {\n  const beverage1 = {name: 'La Croix (Lemon)'};\n  const beverage2 = {name: 'La Croix (Orange)'};\n  const drink = jest.fn(beverage => beverage.name);\n\n  drink(beverage1);\n  drink(beverage2);\n\n  expect(drink).toHaveLastReturnedWith('La Croix (Orange)');\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohaventhreturnedwithnthcall-value",children:(0,s.jsx)(n.code,{children:".toHaveNthReturnedWith(nthCall, value)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".nthReturnedWith(nthCall, value)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toHaveNthReturnedWith"})," to test the specific value that a mock function returned for the nth call. If the nth call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's say you have a mock ",(0,s.jsx)(n.code,{children:"drink"})," that returns the name of the beverage that was consumed. Pute\u0163i scrie:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drink returns expected nth calls', () => {\n  const beverage1 = {name: 'La Croix (Lemon)'};\n  const beverage2 = {name: 'La Croix (Orange)'};\n  const drink = jest.fn(beverage => beverage.name);\n\n  drink(beverage1);\n  drink(beverage2);\n\n  expect(drink).toHaveNthReturnedWith(1, 'La Croix (Lemon)');\n  expect(drink).toHaveNthReturnedWith(2, 'La Croix (Orange)');\n});\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"The nth argument must be positive integer starting from 1."})}),"\n",(0,s.jsx)(n.h3,{id:"tohavelengthnumber",children:(0,s.jsx)(n.code,{children:".toHaveLength(number)"})}),"\n",(0,s.jsxs)(n.p,{children:["Utiliza\u0163i ",(0,s.jsx)(n.code,{children:".toHaveLength"})," pentru a verifica dac\u0103 un obiect are o proprietate de ",(0,s.jsx)(n.code,{children:".length"})," \u015fi are o anumit\u0103 valoare numeric\u0103."]}),"\n",(0,s.jsx)(n.p,{children:"Acest lucru este util mai ales pentru a verifica dimensiunea listelor sau a \u0219irurilor de caractere."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"expect([1, 2, 3]).toHaveLength(3);\nexpect('abc').toHaveLength(3);\nexpect('').not.toHaveLength(5);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavepropertykeypath-value",children:(0,s.jsx)(n.code,{children:".toHaveProperty(keyPath, value?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Utiliza\u0163i ",(0,s.jsx)(n.code,{children:".toHaveProperty"})," pentru a verifica dac\u0103 exist\u0103 o anumit\u0103 proprietate la referin\u0163a ",(0,s.jsx)(n.code,{children:"keyPath"})," pentru un obiect. For checking deeply nested properties in an object you may use ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors",children:"dot notation"})," or an array containing the keyPath for deep references."]}),"\n",(0,s.jsxs)(n.p,{children:["You can provide an optional ",(0,s.jsx)(n.code,{children:"value"})," argument to compare the received property value (recursively for all properties of object instances, also known as deep equality, like the ",(0,s.jsx)(n.code,{children:"toEqual"})," matcher)."]}),"\n",(0,s.jsxs)(n.p,{children:["Exemplul urm\u0103tor con\u0163ine un obiect ",(0,s.jsx)(n.code,{children:"houseForSale"})," cu propriet\u0103\u0163i imbricate. We are using ",(0,s.jsx)(n.code,{children:"toHaveProperty"})," to check for the existence and values of various properties in the object."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Object containing house features to be tested\nconst houseForSale = {\n  bath: true,\n  bedrooms: 4,\n  kitchen: {\n    amenities: ['oven', 'stove', 'washer'],\n    area: 20,\n    wallColor: 'white',\n    'nice.oven': true,\n  },\n  livingroom: {\n    amenities: [\n      {\n        couch: [\n          ['large', {dimensions: [20, 20]}],\n          ['small', {dimensions: [10, 10]}],\n        ],\n      },\n    ],\n  },\n  'ceiling.height': 2,\n};\n\ntest('this house has my desired features', () => {\n  // Example Referencing\n  expect(houseForSale).toHaveProperty('bath');\n  expect(houseForSale).toHaveProperty('bedrooms', 4);\n\n  expect(houseForSale).not.toHaveProperty('pool');\n\n  // Deep referencing using dot notation\n  expect(houseForSale).toHaveProperty('kitchen.area', 20);\n  expect(houseForSale).toHaveProperty('kitchen.amenities', [\n    'oven',\n    'stove',\n    'washer',\n  ]);\n\n  expect(houseForSale).not.toHaveProperty('kitchen.open');\n\n  // Deep referencing using an array containing the keyPath\n  expect(houseForSale).toHaveProperty(['kitchen', 'area'], 20);\n  expect(houseForSale).toHaveProperty(\n    ['kitchen', 'amenities'],\n    ['oven', 'stove', 'washer'],\n  );\n  expect(houseForSale).toHaveProperty(['kitchen', 'amenities', 0], 'oven');\n  expect(houseForSale).toHaveProperty(\n    'livingroom.amenities[0].couch[0][1].dimensions[0]',\n    20,\n  );\n  expect(houseForSale).toHaveProperty(['kitchen', 'nice.oven']);\n  expect(houseForSale).not.toHaveProperty(['kitchen', 'open']);\n\n  // Referencing keys with dot in the key itself\n  expect(houseForSale).toHaveProperty(['ceiling.height'], 'tall');\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobeclosetonumber-numdigits",children:(0,s.jsx)(n.code,{children:".toBeCloseTo(number, numDigits?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"toBeCloseTo"})," to compare floating point numbers for approximate equality."]}),"\n",(0,s.jsxs)(n.p,{children:["The optional ",(0,s.jsx)(n.code,{children:"numDigits"})," argument limits the number of digits to check ",(0,s.jsx)(n.strong,{children:"after"})," the decimal point. For the default value ",(0,s.jsx)(n.code,{children:"2"}),", the test criterion is ",(0,s.jsx)(n.code,{children:"Math.abs(expected - received) < 0.005"})," (that is, ",(0,s.jsx)(n.code,{children:"10 ** -2 / 2"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"Intuitive equality comparisons often fail, because arithmetic on decimal (base 10) values often have rounding errors in limited precision binary (base 2) representation. For example, this test fails:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('adding works sanely with decimals', () => {\n  expect(0.2 + 0.1).toBe(0.3); // Fails!\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It fails because in JavaScript, ",(0,s.jsx)(n.code,{children:"0.2 + 0.1"})," is actually ",(0,s.jsx)(n.code,{children:"0.30000000000000004"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"For example, this test passes with a precision of 5 digits:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('adding works sanely with decimals', () => {\n  expect(0.2 + 0.1).toBeCloseTo(0.3, 5);\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Because floating point errors are the problem that ",(0,s.jsx)(n.code,{children:"toBeCloseTo"})," solves, it does not support big integer values."]}),"\n",(0,s.jsx)(n.h3,{id:"tobedefined",children:(0,s.jsx)(n.code,{children:".toBeDefined()"})}),"\n",(0,s.jsxs)(n.p,{children:["Utiliza\u0163i ",(0,s.jsx)(n.code,{children:".toBeDefined"})," pentru a verifica dac\u0103 o variabil\u0103 nu este nedefinit\u0103. For example, if you want to check that a function ",(0,s.jsx)(n.code,{children:"fetchNewFlavorIdea()"})," returns ",(0,s.jsx)(n.em,{children:"something"}),", you can write:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('there is a new flavor idea', () => {\n  expect(fetchNewFlavorIdea()).toBeDefined();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A\u021bi putea scrie \u0219i ",(0,s.jsx)(n.code,{children:"expect(fetchNewFlavorIdea()).not.toBe(undefined)"}),", dar este de preferat s\u0103 evita\u021bi referin\u021ba la ",(0,s.jsx)(n.code,{children:"undefined"})," \xeen mod direct \xeen codul vostru."]}),"\n",(0,s.jsx)(n.h3,{id:"tobefalsy",children:(0,s.jsx)(n.code,{children:".toBeFalsy()"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toBeFalsy"})," when you don't care what a value is and you want to ensure a value is false in a boolean context. For example, let's say you have some application code that looks like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"drinkSomeLaCroix();\nif (!getErrors()) {\n  drinkMoreLaCroix();\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Nu ar trebui sa ne pese ce anume returneaz\u0103 ",(0,s.jsx)(n.code,{children:"getErrors"}),", specific - ar putea returna ",(0,s.jsx)(n.code,{children:"false"}),", ",(0,s.jsx)(n.code,{children:"null"}),", sau ",(0,s.jsx)(n.code,{children:"0"}),", codul func\u021bion\xe2nd identic. A\u0219adar, dac\u0103 dori\u0163i s\u0103 testa\u0163i ca nu exist\u0103 erori dup\u0103 ce a\u021bi b\u0103ut ni\u0219te La Croix, a\u021bi putea scrie:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drinking La Croix does not lead to errors', () => {\n  drinkSomeLaCroix();\n  expect(getErrors()).toBeFalsy();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In JavaScript, there are six falsy values: ",(0,s.jsx)(n.code,{children:"false"}),", ",(0,s.jsx)(n.code,{children:"0"}),", ",(0,s.jsx)(n.code,{children:"''"}),", ",(0,s.jsx)(n.code,{children:"null"}),", ",(0,s.jsx)(n.code,{children:"undefined"}),", and ",(0,s.jsx)(n.code,{children:"NaN"}),". Everything else is truthy."]}),"\n",(0,s.jsx)(n.h3,{id:"tobegreaterthannumber--bigint",children:(0,s.jsx)(n.code,{children:".toBeGreaterThan(number | bigint)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"toBeGreaterThan"})," to compare ",(0,s.jsx)(n.code,{children:"received > expected"})," for number or big integer values. For example, test that ",(0,s.jsx)(n.code,{children:"ouncesPerCan()"})," returns a value of more than 10 ounces:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('ounces per can is more than 10', () => {\n  expect(ouncesPerCan()).toBeGreaterThan(10);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobegreaterthanorequalnumber--bigint",children:(0,s.jsx)(n.code,{children:".toBeGreaterThanOrEqual(number | bigint)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"toBeGreaterThanOrEqual"})," to compare ",(0,s.jsx)(n.code,{children:"received >= expected"})," for number or big integer values. For example, test that ",(0,s.jsx)(n.code,{children:"ouncesPerCan()"})," returns a value of at least 12 ounces:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('ounces per can is at least 12', () => {\n  expect(ouncesPerCan()).toBeGreaterThanOrEqual(12);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobelessthannumber--bigint",children:(0,s.jsx)(n.code,{children:".toBeLessThan(number | bigint)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"toBeLessThan"})," to compare ",(0,s.jsx)(n.code,{children:"received < expected"})," for number or big integer values. For example, test that ",(0,s.jsx)(n.code,{children:"ouncesPerCan()"})," returns a value of less than 20 ounces:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('ounces per can is less than 20', () => {\n  expect(ouncesPerCan()).toBeLessThan(20);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobelessthanorequalnumber--bigint",children:(0,s.jsx)(n.code,{children:".toBeLessThanOrEqual(number | bigint)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"toBeLessThanOrEqual"})," to compare ",(0,s.jsx)(n.code,{children:"received <= expected"})," for number or big integer values. For example, test that ",(0,s.jsx)(n.code,{children:"ouncesPerCan()"})," returns a value of at most 12 ounces:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('ounces per can is at most 12', () => {\n  expect(ouncesPerCan()).toBeLessThanOrEqual(12);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobeinstanceofclass",children:(0,s.jsx)(n.code,{children:".toBeInstanceOf(Class)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toBeInstanceOf(Class)"})," to check that an object is an instance of a class. This matcher uses ",(0,s.jsx)(n.code,{children:"instanceof"})," underneath."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class A {}\n\nexpect(new A()).toBeInstanceOf(A);\nexpect(() => {}).toBeInstanceOf(Function);\nexpect(new A()).toBeInstanceOf(Function); // throws\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobenull",children:(0,s.jsx)(n.code,{children:".toBeNull()"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:".toBeNull()"})," is the same as ",(0,s.jsx)(n.code,{children:".toBe(null)"})," but the error messages are a bit nicer. So use ",(0,s.jsx)(n.code,{children:".toBeNull()"})," when you want to check that something is null."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function bloop() {\n  return null;\n}\n\ntest('bloop returns null', () => {\n  expect(bloop()).toBeNull();\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobetruthy",children:(0,s.jsx)(n.code,{children:".toBeTruthy()"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toBeTruthy"})," when you don't care what a value is and you want to ensure a value is true in a boolean context. For example, let's say you have some application code that looks like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"drinkSomeLaCroix();\nif (thirstInfo()) {\n  drinkMoreLaCroix();\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Nu ar trebui sa ne pese ce anume returneaz\u0103 ",(0,s.jsx)(n.code,{children:"thirstInfo"}),", specific - ar putea returna fie ",(0,s.jsx)(n.code,{children:"true"})," fie un obiect complex, codul func\u021bion\xe2nd identic. So if you want to test that ",(0,s.jsx)(n.code,{children:"thirstInfo"})," will be truthy after drinking some La Croix, you could write:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drinking La Croix leads to having thirst info', () => {\n  drinkSomeLaCroix();\n  expect(thirstInfo()).toBeTruthy();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In JavaScript, there are six falsy values: ",(0,s.jsx)(n.code,{children:"false"}),", ",(0,s.jsx)(n.code,{children:"0"}),", ",(0,s.jsx)(n.code,{children:"''"}),", ",(0,s.jsx)(n.code,{children:"null"}),", ",(0,s.jsx)(n.code,{children:"undefined"}),", and ",(0,s.jsx)(n.code,{children:"NaN"}),". Everything else is truthy."]}),"\n",(0,s.jsx)(n.h3,{id:"tobeundefined",children:(0,s.jsx)(n.code,{children:".toBeUndefined()"})}),"\n",(0,s.jsxs)(n.p,{children:["Utiliza\u0163i ",(0,s.jsx)(n.code,{children:".toBeUndefined"})," pentru a verifica dac\u0103 o variabil\u0103 este nedefinit\u0103. De exemplu, dac\u0103 dori\u0163i s\u0103 verifica\u0163i dac\u0103 o func\u0163ie ",(0,s.jsx)(n.code,{children:"bestDrinkForFlavor(flavor)"})," returneaz\u0103 ",(0,s.jsx)(n.code,{children:"undefined"})," pentru aroma ",(0,s.jsx)(n.code,{children:"'octopus'"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('the best drink for octopus flavor is undefined', () => {\n  expect(bestDrinkForFlavor('octopus')).toBeUndefined();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A\u021bi putea scrie \u0219i ",(0,s.jsx)(n.code,{children:"expect(bestDrinkForFlavor()).toBe(undefined)"}),", dar este de preferat s\u0103 evita\u021bi referin\u021ba la ",(0,s.jsx)(n.code,{children:"undefined"})," \xeen mod direct \xeen codul vostru."]}),"\n",(0,s.jsx)(n.h3,{id:"tobenan",children:(0,s.jsx)(n.code,{children:".toBeNaN()"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toBeNaN"})," when checking a value is ",(0,s.jsx)(n.code,{children:"NaN"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('passes when value is NaN', () => {\n  expect(NaN).toBeNaN();\n  expect(1).not.toBeNaN();\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tocontainitem",children:(0,s.jsx)(n.code,{children:".toContain(item)"})}),"\n",(0,s.jsxs)(n.p,{children:["Utiliza\u0163i ",(0,s.jsx)(n.code,{children:".toContain"})," atunci c\xe2nd dori\u0163i s\u0103 verifica\u021bi dac\u0103 un element se afl\u0103 \xeentr-o list\u0103. Pentru testarea elementele din matrice, foloseste ",(0,s.jsx)(n.code,{children:"==="}),", o verificare de strict\u0103 egalitate. ",(0,s.jsx)(n.code,{children:".toContain"})," poate de asemenea verifica dac\u0103 un string este un sub\u0219ir al unui alt \u015fir."]}),"\n",(0,s.jsxs)(n.p,{children:["De exemplu, dac\u0103 ",(0,s.jsx)(n.code,{children:"getAllFlavors()"})," returneaz\u0103 o list\u0103 de arome \u015fi dori\u0163i s\u0103 v\u0103 asigura\u0163i c\u0103 ",(0,s.jsx)(n.code,{children:"lime"})," se afl\u0103 \xeen ea, se poate scrie:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('the flavor list contains lime', () => {\n  expect(getAllFlavors()).toContain('lime');\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"This matcher also accepts others iterables such as strings, sets, node lists and HTML collections."}),"\n",(0,s.jsx)(n.h3,{id:"tocontainequalitem",children:(0,s.jsx)(n.code,{children:".toContainEqual(item)"})}),"\n",(0,s.jsxs)(n.p,{children:["Utiliza\u0163i ",(0,s.jsx)(n.code,{children:".toContainEqual"})," atunci c\xe2nd dori\u0163i pentru s\u0103 verifica\u021bi dac\u0103 un element cu o anumit\u0103 structur\u0103 \u015fi valori este con\u0163inut \xeentr-o list\u0103. Pentru testarea elementele din list\u0103, acest validator verific\u0103 recursiv egalitatea tuturor propriet\u0103\u021bilor, \xeen loc s\u0103 verifice referin\u021ba obiectului."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('my beverage', () => {\n  test('is delicious and not sour', () => {\n    const myBeverage = {delicious: true, sour: false};\n    expect(myBeverages()).toContainEqual(myBeverage);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"toequalvalue",children:(0,s.jsx)(n.code,{children:".toEqual(value)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toEqual"}),' to compare recursively all properties of object instances (also known as "deep" equality). It calls ',(0,s.jsx)(n.code,{children:"Object.is"})," to compare primitive values, which is even better for testing than ",(0,s.jsx)(n.code,{children:"==="})," strict equality operator."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, ",(0,s.jsx)(n.code,{children:".toEqual"})," and ",(0,s.jsx)(n.code,{children:".toBe"})," behave differently in this test suite, so all the tests pass:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const can1 = {\n  flavor: 'grapefruit',\n  ounces: 12,\n};\nconst can2 = {\n  flavor: 'grapefruit',\n  ounces: 12,\n};\n\ndescribe('the La Croix cans on my desk', () => {\n  test('have all the same properties', () => {\n    expect(can1).toEqual(can2);\n  });\n  test('are not the exact same can', () => {\n    expect(can1).not.toBe(can2);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"toEqual"})," ignores object keys with ",(0,s.jsx)(n.code,{children:"undefined"})," properties, ",(0,s.jsx)(n.code,{children:"undefined"})," array items, array sparseness, or object type mismatch. To take these into account use ",(0,s.jsx)(n.a,{href:"#tostrictequalvalue",children:(0,s.jsx)(n.code,{children:".toStrictEqual"})})," instead."]})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:".toEqual"})," won't perform a ",(0,s.jsx)(n.em,{children:"deep equality"})," check for two errors. Numai proprietatea ",(0,s.jsx)(n.code,{children:"message"})," al obiectului Error este luat\u0103 \xeen considerare pentru verificare. Este recomandat s\u0103 utiliza\u0163i ",(0,s.jsx)(n.code,{children:".toThrow"})," pentru testarea erorilor."]})}),"\n",(0,s.jsxs)(n.p,{children:["If differences between properties do not help you to understand why a test fails, especially if the report is large, then you might move the comparison into the ",(0,s.jsx)(n.code,{children:"expect"})," function. For example, use ",(0,s.jsx)(n.code,{children:"equals"})," method of ",(0,s.jsx)(n.code,{children:"Buffer"})," class to assert whether or not buffers contain the same content:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["rewrite ",(0,s.jsx)(n.code,{children:"expect(received).toEqual(expected)"})," as ",(0,s.jsx)(n.code,{children:"expect(received.equals(expected)).toBe(true)"})]}),"\n",(0,s.jsxs)(n.li,{children:["rewrite ",(0,s.jsx)(n.code,{children:"expect(received).not.toEqual(expected)"})," as ",(0,s.jsx)(n.code,{children:"expect(received.equals(expected)).toBe(false)"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"tomatchregexp--string",children:(0,s.jsx)(n.code,{children:".toMatch(regexp | string)"})}),"\n",(0,s.jsxs)(n.p,{children:["Utiliza\u0163i ",(0,s.jsx)(n.code,{children:".toMatch"})," pentru a verifica dac\u0103 un \u015fir de caractere valideaz\u0103 o expresie regulat\u0103."]}),"\n",(0,s.jsxs)(n.p,{children:["De exemplu, s-ar putea s\u0103 nu \u015fti\u0163i exact ce returneaz\u0103 ",(0,s.jsx)(n.code,{children:"essayOnTheBestFlavor()"}),", dar \u0219ti\u021bi c\u0103 este un \u015fir foarte lung \u015fi c\u0103 ar trebui s\u0103 con\u021bin\u0103 un sub\u0219ir ",(0,s.jsx)(n.code,{children:"grapefruit"}),". Pute\u021bi testa acest lucru \xeen felul urm\u0103tor:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('an essay on the best flavor', () => {\n  test('mentions grapefruit', () => {\n    expect(essayOnTheBestFlavor()).toMatch(/grapefruit/);\n    expect(essayOnTheBestFlavor()).toMatch(new RegExp('grapefruit'));\n  });\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Acest validator accept\u0103, de asemenea, un \u015fir de caractere, pe care va \xeencerca s\u0103-l g\u0103seasc\u0103:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('grapefruits are healthy', () => {\n  test('grapefruits are a fruit', () => {\n    expect('grapefruits').toMatch('fruit');\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tomatchobjectobject",children:(0,s.jsx)(n.code,{children:".toMatchObject(object)"})}),"\n",(0,s.jsxs)(n.p,{children:["Utiliza\u0163i ",(0,s.jsx)(n.code,{children:".toMatchObject"})," pentru a verifica dac\u0103 un obiect JavaScript con\u021bine un subset de propriet\u0103\u021bi ale altui obiect. Valideaz\u0103 un obiecte care con\u0163in propriet\u0103\u021bi care ",(0,s.jsx)(n.strong,{children:"nu"})," fac parte din obiectul a\u015fteptat."]}),"\n",(0,s.jsxs)(n.p,{children:["Se poate pasa, de asemenea, o list\u0103 de obiecte, iar \xeen cazul acesta metoda va returna adev\u0103rat numai \xeen cazul \xeen care fiecare obiect din lista primit\u0103 se potrive\u0219te (\xeen sensul ",(0,s.jsx)(n.code,{children:"toMatchObject"})," descris mai sus) cu obiectul corespunz\u0103tor din lista a\u015fteptat\u0103. Acest lucru este util dac\u0103 dori\u0163i s\u0103 verifica\u0163i c\u0103 dou\u0103 liste se potrivesc in raport cu num\u0103rul lor de elemente, spre deosebire de ",(0,s.jsx)(n.code,{children:"arrayContaining"}),", care permite elemente suplimentare \xeen lista primit\u0103."]}),"\n",(0,s.jsx)(n.p,{children:"Ave\u0163i posibilitatea s\u0103 valida\u021bi propriet\u0103\u0163i cu valori sau cu al\u021bi validatori."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const houseForSale = {\n  bath: true,\n  bedrooms: 4,\n  kitchen: {\n    amenities: ['oven', 'stove', 'washer'],\n    area: 20,\n    wallColor: 'white',\n  },\n};\nconst desiredHouse = {\n  bath: true,\n  kitchen: {\n    amenities: ['oven', 'stove', 'washer'],\n    wallColor: expect.stringMatching(/white|yellow/),\n  },\n};\n\ntest('the house has my desired features', () => {\n  expect(houseForSale).toMatchObject(desiredHouse);\n});\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('toMatchObject applied to arrays', () => {\n  test('the number of elements must match exactly', () => {\n    expect([{foo: 'bar'}, {baz: 1}]).toMatchObject([{foo: 'bar'}, {baz: 1}]);\n  });\n\n  test('.toMatchObject is called for each elements, so extra object properties are okay', () => {\n    expect([{foo: 'bar'}, {baz: 1, extra: 'quux'}]).toMatchObject([\n      {foo: 'bar'},\n      {baz: 1},\n    ]);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tomatchsnapshotpropertymatchers-hint",children:(0,s.jsx)(n.code,{children:".toMatchSnapshot(propertyMatchers?, hint?)"})}),"\n",(0,s.jsxs)(n.p,{children:["This ensures that a value matches the most recent snapshot. Check out ",(0,s.jsx)(n.a,{href:"/ro/docs/snapshot-testing",children:"the Snapshot Testing guide"})," for more information."]}),"\n",(0,s.jsxs)(n.p,{children:["You can provide an optional ",(0,s.jsx)(n.code,{children:"propertyMatchers"})," object argument, which has asymmetric matchers as values of a subset of expected properties, ",(0,s.jsx)(n.strong,{children:"if"})," the received value will be an ",(0,s.jsx)(n.strong,{children:"object"})," instance. It is like ",(0,s.jsx)(n.code,{children:"toMatchObject"})," with flexible criteria for a subset of properties, followed by a snapshot test as exact criteria for the rest of the properties."]}),"\n",(0,s.jsxs)(n.p,{children:["You can provide an optional ",(0,s.jsx)(n.code,{children:"hint"})," string argument that is appended to the test name. Although Jest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate ",(0,s.jsx)(n.strong,{children:"multiple"})," snapshots in a ",(0,s.jsx)(n.strong,{children:"single"})," ",(0,s.jsx)(n.code,{children:"it"})," or ",(0,s.jsx)(n.code,{children:"test"})," block. Jest sorts snapshots by name in the corresponding ",(0,s.jsx)(n.code,{children:".snap"})," file."]}),"\n",(0,s.jsx)(n.h3,{id:"tomatchinlinesnapshotpropertymatchers-inlinesnapshot",children:(0,s.jsx)(n.code,{children:".toMatchInlineSnapshot(propertyMatchers?, inlineSnapshot)"})}),"\n",(0,s.jsx)(n.p,{children:"Ensures that a value matches the most recent snapshot."}),"\n",(0,s.jsxs)(n.p,{children:["You can provide an optional ",(0,s.jsx)(n.code,{children:"propertyMatchers"})," object argument, which has asymmetric matchers as values of a subset of expected properties, ",(0,s.jsx)(n.strong,{children:"if"})," the received value will be an ",(0,s.jsx)(n.strong,{children:"object"})," instance. It is like ",(0,s.jsx)(n.code,{children:"toMatchObject"})," with flexible criteria for a subset of properties, followed by a snapshot test as exact criteria for the rest of the properties."]}),"\n",(0,s.jsxs)(n.p,{children:["Jest adds the ",(0,s.jsx)(n.code,{children:"inlineSnapshot"})," string argument to the matcher in the test file (instead of an external ",(0,s.jsx)(n.code,{children:".snap"})," file) the first time that the test runs."]}),"\n",(0,s.jsxs)(n.p,{children:["Check out the section on ",(0,s.jsx)(n.a,{href:"/ro/docs/snapshot-testing#inline-snapshots",children:"Inline Snapshots"})," for more info."]}),"\n",(0,s.jsx)(n.h3,{id:"tostrictequalvalue",children:(0,s.jsx)(n.code,{children:".toStrictEqual(value)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toStrictEqual"})," to test that objects have the same structure and type."]}),"\n",(0,s.jsxs)(n.p,{children:["Differences from ",(0,s.jsx)(n.code,{children:".toEqual"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["keys with ",(0,s.jsx)(n.code,{children:"undefined"})," properties are checked, e.g. ",(0,s.jsx)(n.code,{children:"{a: undefined, b: 2}"})," will not equal ",(0,s.jsx)(n.code,{children:"{b: 2}"}),";"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"undefined"})," items are taken into account, e.g. ",(0,s.jsx)(n.code,{children:"[2]"})," will not equal ",(0,s.jsx)(n.code,{children:"[2, undefined]"}),";"]}),"\n",(0,s.jsxs)(n.li,{children:["array sparseness is checked, e.g. ",(0,s.jsx)(n.code,{children:"[, 1]"})," will not equal ",(0,s.jsx)(n.code,{children:"[undefined, 1]"}),";"]}),"\n",(0,s.jsxs)(n.li,{children:["object types are checked, e.g. a class instance with fields ",(0,s.jsx)(n.code,{children:"a"})," and ",(0,s.jsx)(n.code,{children:"b"})," will not equal a literal object with fields ",(0,s.jsx)(n.code,{children:"a"})," and ",(0,s.jsx)(n.code,{children:"b"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class LaCroix {\n  constructor(flavor) {\n    this.flavor = flavor;\n  }\n}\n\ndescribe('the La Croix cans on my desk', () => {\n  test('are not semantically the same', () => {\n    expect(new LaCroix('lemon')).toEqual({flavor: 'lemon'});\n    expect(new LaCroix('lemon')).not.toStrictEqual({flavor: 'lemon'});\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tothrowerror",children:(0,s.jsx)(n.code,{children:".toThrow(error?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".toThrowError(error?)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Utiliza\u0163i ",(0,s.jsx)(n.code,{children:".toThrow"})," pentru a testa dac\u0103 o func\u0163ie arunc\u0103 o excep\u021bie atunci c\xe2nd este apelat\u0103. De exemplu, dac\u0103 vrem s\u0103 test\u0103m c\u0103 ",(0,s.jsx)(n.code,{children:"drinkFlavor('octopus')"})," arunc\u0103 o excep\u021bie, vom scrie:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('throws on octopus', () => {\n  expect(() => {\n    drinkFlavor('octopus');\n  }).toThrow();\n});\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"You must wrap the code in a function, otherwise the error will not be caught and the assertion will fail."})}),"\n",(0,s.jsx)(n.p,{children:"You can provide an optional argument to test that a specific error is thrown:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["regular expression: error message ",(0,s.jsx)(n.strong,{children:"matches"})," the pattern"]}),"\n",(0,s.jsxs)(n.li,{children:["string: error message ",(0,s.jsx)(n.strong,{children:"includes"})," the substring"]}),"\n",(0,s.jsxs)(n.li,{children:["error object: error message is ",(0,s.jsx)(n.strong,{children:"equal to"})," the message property of the object"]}),"\n",(0,s.jsxs)(n.li,{children:["error class: error object is ",(0,s.jsx)(n.strong,{children:"instance of"})," class"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["De exemplu, s\u0103 presupunem c\u0103 ",(0,s.jsx)(n.code,{children:"drinkFlavor"})," este implementat\u0103 \xeen felul urm\u0103tor:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function drinkFlavor(flavor) {\n  if (flavor == 'octopus') {\n    throw new DisgustingFlavorError('yuck, octopus flavor');\n  }\n  // Do some other stuff\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Am putea testa \xeen mai multe moduri c\u0103 aceast\u0103 eroare este aruncat\u0103:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('throws on octopus', () => {\n  function drinkOctopus() {\n    drinkFlavor('octopus');\n  }\n\n  // Test that the error message says \"yuck\" somewhere: these are equivalent\n  expect(drinkOctopus).toThrow(/yuck/);\n  expect(drinkOctopus).toThrow('yuck');\n\n  // Test the exact error message\n  expect(drinkOctopus).toThrow(/^yuck, octopus flavor$/);\n  expect(drinkOctopus).toThrow(new Error('yuck, octopus flavor'));\n\n  // Test that we get a DisgustingFlavorError\n  expect(drinkOctopus).toThrow(DisgustingFlavorError);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tothrowerrormatchingsnapshothint",children:(0,s.jsx)(n.code,{children:".toThrowErrorMatchingSnapshot(hint?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Utiliza\u0163i ",(0,s.jsx)(n.code,{children:".toThrowErrorMatchingSnapshot"})," pentru a testa dac\u0103 o func\u0163ie arunc\u0103 o eroare \xeen timpul compar\u0103rii cu cea mai recent\u0103 imagine, atunci c\xe2nd este apelat\u0103."]}),"\n",(0,s.jsxs)(n.p,{children:["You can provide an optional ",(0,s.jsx)(n.code,{children:"hint"})," string argument that is appended to the test name. Although Jest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate ",(0,s.jsx)(n.strong,{children:"multiple"})," snapshots in a ",(0,s.jsx)(n.strong,{children:"single"})," ",(0,s.jsx)(n.code,{children:"it"})," or ",(0,s.jsx)(n.code,{children:"test"})," block. Jest sorts snapshots by name in the corresponding ",(0,s.jsx)(n.code,{children:".snap"})," file."]}),"\n",(0,s.jsxs)(n.p,{children:["De exemplu, s\u0103 presupunem c\u0103 ave\u0163i o func\u0163ie ",(0,s.jsx)(n.code,{children:"drinkFlavor"})," care arunc\u0103 o excep\u021bie ori de c\xe2te ori aroma este ",(0,s.jsx)(n.code,{children:"'octopus'"}),", \u015fi este implementat\u0103 \xeen felul urm\u0103tor:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function drinkFlavor(flavor) {\n  if (flavor == 'octopus') {\n    throw new DisgustingFlavorError('yuck, octopus flavor');\n  }\n  // Do some other stuff\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Testul pentru aceast\u0103 func\u0163ie va ar\u0103ta astfel:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('throws on octopus', () => {\n  function drinkOctopus() {\n    drinkFlavor('octopus');\n  }\n\n  expect(drinkOctopus).toThrowErrorMatchingSnapshot();\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Care va genera urm\u0103toarea imagine:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'exports[`drinking flavors throws on octopus 1`] = `"yuck, octopus flavor"`;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Check out ",(0,s.jsx)(n.a,{href:"/blog/2016/07/27/jest-14",children:"React Tree Snapshot Testing"})," for more information on snapshot testing."]}),"\n",(0,s.jsx)(n.h3,{id:"tothrowerrormatchinginlinesnapshotinlinesnapshot",children:(0,s.jsx)(n.code,{children:".toThrowErrorMatchingInlineSnapshot(inlineSnapshot)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toThrowErrorMatchingInlineSnapshot"})," to test that a function throws an error matching the most recent snapshot when it is called."]}),"\n",(0,s.jsxs)(n.p,{children:["Jest adds the ",(0,s.jsx)(n.code,{children:"inlineSnapshot"})," string argument to the matcher in the test file (instead of an external ",(0,s.jsx)(n.code,{children:".snap"})," file) the first time that the test runs."]}),"\n",(0,s.jsxs)(n.p,{children:["Check out the section on ",(0,s.jsx)(n.a,{href:"/ro/docs/snapshot-testing#inline-snapshots",children:"Inline Snapshots"})," for more info."]}),"\n",(0,s.jsx)(n.h2,{id:"asymmetric-matchers",children:"Asymmetric Matchers"}),"\n",(0,s.jsx)(n.h3,{id:"expectanything",children:(0,s.jsx)(n.code,{children:"expect.anything()"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.anything()"})," valideaz\u0103 orice, mai putin ",(0,s.jsx)(n.code,{children:"null"})," sau ",(0,s.jsx)(n.code,{children:"undefined"}),". \xcel pute\u0163i folosi \xeen interiorul lui ",(0,s.jsx)(n.code,{children:"toEqual"})," sau ",(0,s.jsx)(n.code,{children:"toBeCalledWith"})," \xeen locul unei valori concrete. De exemplu, dac\u0103 dori\u0163i s\u0103 verifica\u0163i c\u0103 o dublur\u0103 a fost apelat\u0103 cu un argument non-null:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('map calls its argument with a non-null argument', () => {\n  const mock = jest.fn();\n  [1].map(x => mock(x));\n  expect(mock).toHaveBeenCalledWith(expect.anything());\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectanyconstructor",children:(0,s.jsx)(n.code,{children:"expect.any(constructor)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.any(constructor)"})," matches anything that was created with the given constructor or if it's a primitive that is of the passed type. \xcel pute\u0163i folosi \xeen interiorul lui ",(0,s.jsx)(n.code,{children:"toEqual"})," sau ",(0,s.jsx)(n.code,{children:"toBeCalledWith"})," \xeen locul unei valori concrete. De exemplu, dac\u0103 dori\u0163i s\u0103 verifica\u0163i c\u0103 o dublur\u0103 a fost apelat\u0103 cu un num\u0103r:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class Cat {}\nfunction getCat(fn) {\n  return fn(new Cat());\n}\n\ntest('randocall calls its callback with a class instance', () => {\n  const mock = jest.fn();\n  getCat(mock);\n  expect(mock).toHaveBeenCalledWith(expect.any(Cat));\n});\n\nfunction randocall(fn) {\n  return fn(Math.floor(Math.random() * 6 + 1));\n}\n\ntest('randocall calls its callback with a number', () => {\n  const mock = jest.fn();\n  randocall(mock);\n  expect(mock).toHaveBeenCalledWith(expect.any(Number));\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectarraycontainingarray",children:(0,s.jsx)(n.code,{children:"expect.arrayContaining(array)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.arrayContaining(array)"})," valideaz\u0103 o list\u0103 care con\u0163ine toate elementele din lista pasat\u0103. That is, the expected array is a ",(0,s.jsx)(n.strong,{children:"subset"})," of the received array. Therefore, it matches a received array which contains elements that are ",(0,s.jsx)(n.strong,{children:"not"})," in the expected array."]}),"\n",(0,s.jsx)(n.p,{children:"\xcel pute\u0163i folosi \xeen locul unei valori concrete:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["in ",(0,s.jsx)(n.code,{children:"toEqual"})," or ",(0,s.jsx)(n.code,{children:"toBeCalledWith"})]}),"\n",(0,s.jsxs)(n.li,{children:["to match a property in ",(0,s.jsx)(n.code,{children:"objectContaining"})," or ",(0,s.jsx)(n.code,{children:"toMatchObject"})]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('arrayContaining', () => {\n  const expected = ['Alice', 'Bob'];\n  it('matches even if received contains additional elements', () => {\n    expect(['Alice', 'Bob', 'Eve']).toEqual(expect.arrayContaining(expected));\n  });\n  it('does not match if received does not contain expected elements', () => {\n    expect(['Bob', 'Eve']).not.toEqual(expect.arrayContaining(expected));\n  });\n});\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('Beware of a misunderstanding! A sequence of dice rolls', () => {\n  const expected = [1, 2, 3, 4, 5, 6];\n  it('matches even with an unexpected number 7', () => {\n    expect([4, 1, 6, 7, 3, 5, 2, 5, 4, 6]).toEqual(\n      expect.arrayContaining(expected),\n    );\n  });\n  it('does not match without an expected number 2', () => {\n    expect([4, 1, 6, 7, 3, 5, 7, 5, 4, 6]).not.toEqual(\n      expect.arrayContaining(expected),\n    );\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectnotarraycontainingarray",children:(0,s.jsx)(n.code,{children:"expect.not.arrayContaining(array)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.not.arrayContaining(array)"})," matches a received array which does not contain all of the elements in the expected array. That is, the expected array ",(0,s.jsx)(n.strong,{children:"is not a subset"})," of the received array."]}),"\n",(0,s.jsxs)(n.p,{children:["It is the inverse of ",(0,s.jsx)(n.code,{children:"expect.arrayContaining"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('not.arrayContaining', () => {\n  const expected = ['Samantha'];\n\n  it('matches if the actual array does not contain the expected elements', () => {\n    expect(['Alice', 'Bob', 'Eve']).toEqual(\n      expect.not.arrayContaining(expected),\n    );\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectclosetonumber-numdigits",children:(0,s.jsx)(n.code,{children:"expect.closeTo(number, numDigits?)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.closeTo(number, numDigits?)"})," is useful when comparing floating point numbers in object properties or array item. If you need to compare a number, please use ",(0,s.jsx)(n.code,{children:".toBeCloseTo"})," instead."]}),"\n",(0,s.jsxs)(n.p,{children:["The optional ",(0,s.jsx)(n.code,{children:"numDigits"})," argument limits the number of digits to check ",(0,s.jsx)(n.strong,{children:"after"})," the decimal point. For the default value ",(0,s.jsx)(n.code,{children:"2"}),", the test criterion is ",(0,s.jsx)(n.code,{children:"Math.abs(expected - received) < 0.005 (that is, 10 ** -2 / 2)"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"For example, this test passes with a precision of 5 digits:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('compare float in object properties', () => {\n  expect({\n    title: '0.1 + 0.2',\n    sum: 0.1 + 0.2,\n  }).toEqual({\n    title: '0.1 + 0.2',\n    sum: expect.closeTo(0.3, 5),\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectobjectcontainingobject",children:(0,s.jsx)(n.code,{children:"expect.objectContaining(object)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.objectContaining(object)"})," valideaz\u0103 orice obiect primit care con\u021bine \xeen mod recursiv propriet\u0103\u0163ile a\u015fteptate. Adic\u0103, obiectul asteptat este un ",(0,s.jsx)(n.strong,{children:"subset"})," al obiectului primit. Therefore, it matches a received object which contains properties that ",(0,s.jsx)(n.strong,{children:"are present"})," in the expected object."]}),"\n",(0,s.jsxs)(n.p,{children:["\xcen loc de valori literale \xeen obiectul a\u015fteptat, pute\u0163i utiliza validatori, ",(0,s.jsx)(n.code,{children:"expect.anything()"}),", \u015fi a\u015fa mai departe."]}),"\n",(0,s.jsxs)(n.p,{children:["De exemplu, s\u0103 presupunem c\u0103 ne a\u015ftept\u0103m ca o func\u0163ie ",(0,s.jsx)(n.code,{children:"onPress"})," s\u0103 fie apelat\u0103 cu un obiect de tip ",(0,s.jsx)(n.code,{children:"Event"}),", \u015fi tot ce avem nevoie s\u0103 verific\u0103m este c\u0103 evenimentul are propriet\u0103\u021bile ",(0,s.jsx)(n.code,{children:"event.x"})," \u0219i ",(0,s.jsx)(n.code,{children:"event.y"}),". Putem testa acest lucru \xeen felul urm\u0103tor:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('onPress gets called with the right thing', () => {\n  const onPress = jest.fn();\n  simulatePresses(onPress);\n  expect(onPress).toHaveBeenCalledWith(\n    expect.objectContaining({\n      x: expect.any(Number),\n      y: expect.any(Number),\n    }),\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectnotobjectcontainingobject",children:(0,s.jsx)(n.code,{children:"expect.not.objectContaining(object)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.not.objectContaining(object)"})," matches any received object that does not recursively match the expected properties. That is, the expected object ",(0,s.jsx)(n.strong,{children:"is not a subset"})," of the received object. Prin urmare, valideaz\u0103 un obiect primit care con\u0163ine propriet\u0103\u021bi care ",(0,s.jsx)(n.strong,{children:"nu"})," fac parte din obiectul a\u015fteptat."]}),"\n",(0,s.jsxs)(n.p,{children:["It is the inverse of ",(0,s.jsx)(n.code,{children:"expect.objectContaining"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('not.objectContaining', () => {\n  const expected = {foo: 'bar'};\n\n  it('matches if the actual object does not contain expected key: value pairs', () => {\n    expect({bar: 'baz'}).toEqual(expect.not.objectContaining(expected));\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectstringcontainingstring",children:(0,s.jsx)(n.code,{children:"expect.stringContaining(string)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.stringContaining(string)"})," matches the received value if it is a string that contains the exact expected string."]}),"\n",(0,s.jsx)(n.h3,{id:"expectnotstringcontainingstring",children:(0,s.jsx)(n.code,{children:"expect.not.stringContaining(string)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.not.stringContaining(string)"})," matches the received value if it is not a string or if it is a string that does not contain the exact expected string."]}),"\n",(0,s.jsxs)(n.p,{children:["It is the inverse of ",(0,s.jsx)(n.code,{children:"expect.stringContaining"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('not.stringContaining', () => {\n  const expected = 'Hello world!';\n\n  it('matches if the received value does not contain the expected substring', () => {\n    expect('How are you?').toEqual(expect.not.stringContaining(expected));\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectstringmatchingstring--regexp",children:(0,s.jsx)(n.code,{children:"expect.stringMatching(string | regexp)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.stringMatching(string | regexp)"})," matches the received value if it is a string that matches the expected string or regular expression."]}),"\n",(0,s.jsx)(n.p,{children:"\xcel pute\u0163i folosi \xeen locul unei valori concrete:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["in ",(0,s.jsx)(n.code,{children:"toEqual"})," or ",(0,s.jsx)(n.code,{children:"toBeCalledWith"})]}),"\n",(0,s.jsxs)(n.li,{children:["to match an element in ",(0,s.jsx)(n.code,{children:"arrayContaining"})]}),"\n",(0,s.jsxs)(n.li,{children:["to match a property in ",(0,s.jsx)(n.code,{children:"objectContaining"})," or ",(0,s.jsx)(n.code,{children:"toMatchObject"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Acest exemplu arat\u0103 cum pute\u0163i imbrica mai mul\u021bi validatori asimetrici, cu ",(0,s.jsx)(n.code,{children:"expect.stringMatching"})," \xeen interiorul unui ",(0,s.jsx)(n.code,{children:"expect.arrayContaining"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('stringMatching in arrayContaining', () => {\n  const expected = [\n    expect.stringMatching(/^Alic/),\n    expect.stringMatching(/^[BR]ob/),\n  ];\n  it('matches even if received contains additional elements', () => {\n    expect(['Alicia', 'Roberto', 'Evelina']).toEqual(\n      expect.arrayContaining(expected),\n    );\n  });\n  it('does not match if received does not contain expected elements', () => {\n    expect(['Roberto', 'Evelina']).not.toEqual(\n      expect.arrayContaining(expected),\n    );\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectnotstringmatchingstring--regexp",children:(0,s.jsx)(n.code,{children:"expect.not.stringMatching(string | regexp)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.not.stringMatching(string | regexp)"})," matches the received value if it is not a string or if it is a string that does not match the expected string or regular expression."]}),"\n",(0,s.jsxs)(n.p,{children:["It is the inverse of ",(0,s.jsx)(n.code,{children:"expect.stringMatching"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('not.stringMatching', () => {\n  const expected = /Hello world!/;\n\n  it('matches if the received value does not match the expected regex', () => {\n    expect('How are you?').toEqual(expect.not.stringMatching(expected));\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"assertion-count",children:"Assertion Count"}),"\n",(0,s.jsx)(n.h3,{id:"expectassertionsnumber",children:(0,s.jsx)(n.code,{children:"expect.assertions(number)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.assertions(number)"})," verific\u0103 dac\u0103 un anumit num\u0103r de aser\u021biuni au fost apelate \xeen timpul unui test. Acest lucru este adesea util c\xe2nd test\u0103m cod asincron, pentru a ne asigura c\u0103 aser\u021biunile dintr-un callback chiar sunt apelate."]}),"\n",(0,s.jsxs)(n.p,{children:["De exemplu, s\u0103 presupunem c\u0103 avem o func\u0163ie ",(0,s.jsx)(n.code,{children:"doAsync"})," care prime\u015fte dou\u0103 callback-uri ",(0,s.jsx)(n.code,{children:"callback1"})," \u015fi ",(0,s.jsx)(n.code,{children:"callback2"}),", care vor fi apelate asincron \xeentr-o ordine necunoscut\u0103. Putem testa acest lucru \xeen felul urm\u0103tor:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('doAsync calls both callbacks', () => {\n  expect.assertions(2);\n  function callback1(data) {\n    expect(data).toBeTruthy();\n  }\n  function callback2(data) {\n    expect(data).toBeTruthy();\n  }\n\n  doAsync(callback1, callback2);\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Apelul ",(0,s.jsx)(n.code,{children:"expect.assertions(2)"})," asigur\u0103 c\u0103 ambele callback-uri au fost apelate."]}),"\n",(0,s.jsx)(n.h3,{id:"expecthasassertions",children:(0,s.jsx)(n.code,{children:"expect.hasAssertions()"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.hasAssertions()"})," verific\u0103 dac\u0103 cel pu\u021bin o aser\u021biune a fost apelat\u0103 \xeen timpul unui test. Acest lucru este adesea util c\xe2nd test\u0103m cod asincron, pentru a ne asigura c\u0103 aser\u021biunile dintr-un callback chiar sunt apelate."]}),"\n",(0,s.jsxs)(n.p,{children:["De exemplu, s\u0103 spunem c\u0103 avem c\xe2teva func\u0163ii care se ocup\u0103 toate de stare. ",(0,s.jsx)(n.code,{children:"prepareState"})," apeleaz\u0103 un callback cu un obiect de stare, ",(0,s.jsx)(n.code,{children:"validateState"})," ruleaza pe acel obiect de stare \u015fi ",(0,s.jsx)(n.code,{children:"waitOnState"})," returneaz\u0103 o promisiune care a\u015fteapt\u0103 p\xe2n\u0103 c\xe2nd toate callback-urile ",(0,s.jsx)(n.code,{children:"prepareState"})," se termin\u0103. Putem testa acest lucru \xeen felul urm\u0103tor:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('prepareState prepares a valid state', () => {\n  expect.hasAssertions();\n  prepareState(state => {\n    expect(validateState(state)).toBeTruthy();\n  });\n  return waitOnState();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Apelul ",(0,s.jsx)(n.code,{children:"expect.hasAssertions()"})," ne asigur\u0103 c\u0103 ",(0,s.jsx)(n.code,{children:"prepareState"})," este apelat."]}),"\n",(0,s.jsx)(n.h2,{id:"extend-utilities",children:"Extend Utilities"}),"\n",(0,s.jsx)(n.h3,{id:"expectaddequalitytesterstesters",children:(0,s.jsx)(n.code,{children:"expect.addEqualityTesters(testers)"})}),"\n",(0,s.jsxs)(n.p,{children:["You can use ",(0,s.jsx)(n.code,{children:"expect.addEqualityTesters"})," to add your own methods to test if two objects are equal. For example, let's say you have a class in your code that represents volume and can determine if two volumes using different units are equal. You may want ",(0,s.jsx)(n.code,{children:"toEqual"})," (and other equality matchers) to use this custom equality method when comparing to Volume classes. You can add a custom equality tester to have ",(0,s.jsx)(n.code,{children:"toEqual"})," detect and apply custom logic when comparing Volume classes:"]}),"\n",(0,s.jsxs)(r.Z,{groupId:"code-examples",children:[(0,s.jsxs)(a.Z,{value:"js",label:"JavaScript",children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'tab={"span":3} title="Volume.js"',children:"// For simplicity in this example, we'll just support the units 'L' and 'mL'\nexport class Volume {\n  constructor(amount, unit) {\n    this.amount = amount;\n    this.unit = unit;\n  }\n\n  toString() {\n    return `[Volume ${this.amount}${this.unit}]`;\n  }\n\n  equals(other) {\n    if (this.unit === other.unit) {\n      return this.amount === other.amount;\n    } else if (this.unit === 'L' && other.unit === 'mL') {\n      return this.amount * 1000 === other.unit;\n    } else {\n      return this.amount === other.unit * 1000;\n    }\n  }\n}\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'title="areVolumesEqual.js"',children:"import {expect} from '@jest/globals';\nimport {Volume} from './Volume.js';\n\nfunction areVolumesEqual(a, b) {\n  const isAVolume = a instanceof Volume;\n  const isBVolume = b instanceof Volume;\n\n  if (isAVolume && isBVolume) {\n    return a.equals(b);\n  } else if (isAVolume !== isBVolume) {\n    return false;\n  } else {\n    return undefined;\n  }\n}\n\nexpect.addEqualityTesters([areVolumesEqual]);\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'title="__tests__/Volume.test.js"',children:"import {expect, test} from '@jest/globals';\nimport {Volume} from '../Volume.js';\nimport '../areVolumesEqual.js';\n\ntest('are equal with different units', () => {\n  expect(new Volume(1, 'L')).toEqual(new Volume(1000, 'mL'));\n});\n"})})]}),(0,s.jsxs)(a.Z,{value:"ts",label:"TypeScript",children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'tab={"span":3} title="Volume.ts"',children:"// For simplicity in this example, we'll just support the units 'L' and 'mL'\nexport class Volume {\n  public amount: number;\n  public unit: 'L' | 'mL';\n\n  constructor(amount: number, unit: 'L' | 'mL') {\n    this.amount = amount;\n    this.unit = unit;\n  }\n\n  toString(): string {\n    return `[Volume ${this.amount}${this.unit}]`;\n  }\n\n  equals(other: Volume): boolean {\n    if (this.unit === other.unit) {\n      return this.amount === other.amount;\n    } else if (this.unit === 'L' && other.unit === 'mL') {\n      return this.amount * 1000 === other.amount;\n    } else {\n      return this.amount === other.amount * 1000;\n    }\n  }\n}\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="areVolumesEqual.ts"',children:"import {expect} from '@jest/globals';\nimport {Volume} from './Volume.js';\n\nfunction areVolumesEqual(a: unknown, b: unknown): boolean | undefined {\n  const isAVolume = a instanceof Volume;\n  const isBVolume = b instanceof Volume;\n\n  if (isAVolume && isBVolume) {\n    return a.equals(b);\n  } else if (isAVolume !== isBVolume) {\n    return false;\n  } else {\n    return undefined;\n  }\n}\n\nexpect.addEqualityTesters([areVolumesEqual]);\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="__tests__/Volume.test.ts"',children:"import {expect, test} from '@jest/globals';\nimport {Volume} from '../Volume.js';\nimport '../areVolumesEqual.js';\n\ntest('are equal with different units', () => {\n  expect(new Volume(1, 'L')).toEqual(new Volume(1000, 'mL'));\n});\n"})})]})]}),"\n",(0,s.jsx)(n.h4,{id:"custom-equality-testers-api",children:"Custom equality testers API"}),"\n",(0,s.jsxs)(n.p,{children:["Custom testers are functions that return either the result (",(0,s.jsx)(n.code,{children:"true"})," or ",(0,s.jsx)(n.code,{children:"false"}),") of comparing the equality of the two given arguments or ",(0,s.jsx)(n.code,{children:"undefined"})," if the tester does not handle the given objects and wants to delegate equality to other testers (for example, the builtin equality testers)."]}),"\n",(0,s.jsx)(n.p,{children:"Custom testers are called with 3 arguments: the two objects to compare and the array of custom testers (used for recursive testers, see the section below)."}),"\n",(0,s.jsxs)(n.p,{children:["These helper functions and properties can be found on ",(0,s.jsx)(n.code,{children:"this"})," inside a custom tester:"]}),"\n",(0,s.jsx)(n.h4,{id:"thisequalsa-b-customtesters",children:(0,s.jsx)(n.code,{children:"this.equals(a, b, customTesters?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Aceasta este o func\u0163ie de egalitate-\xeen-ad\xe2ncime, care va returna ",(0,s.jsx)(n.code,{children:"true"})," dac\u0103 dou\u0103 obiecte au acelea\u015fi valori (recursiv). It optionally takes a list of custom equality testers to apply to the deep equality checks. If you use this function, pass through the custom testers your tester is given so further equality checks ",(0,s.jsx)(n.code,{children:"equals"})," applies can also use custom testers the test author may have configured. See the example in the ",(0,s.jsx)(n.a,{href:"#recursive-custom-equality-testers",children:"Recursive custom equality testers"})," section for more details."]}),"\n",(0,s.jsx)(n.h4,{id:"matchers-vs-testers",children:"Matchers vs Testers"}),"\n",(0,s.jsxs)(n.p,{children:["Matchers are methods available on ",(0,s.jsx)(n.code,{children:"expect"}),", for example ",(0,s.jsx)(n.code,{children:"expect().toEqual()"}),". ",(0,s.jsx)(n.code,{children:"toEqual"})," is a matcher. A tester is a method used by matchers that do equality checks to determine if objects are the same."]}),"\n",(0,s.jsxs)(n.p,{children:["Custom matchers are good to use when you want to provide a custom assertion that test authors can use in their tests. For example, the ",(0,s.jsx)(n.code,{children:"toBeWithinRange"})," example in the ",(0,s.jsx)(n.a,{href:"#expectextendmatchers",children:(0,s.jsx)(n.code,{children:"expect.extend"})})," section is a good example of a custom matcher. Sometimes a test author may want to assert two numbers are exactly equal and should use ",(0,s.jsx)(n.code,{children:"toBe"}),". Other times, however, a test author may want to allow for some flexibility in their test, and ",(0,s.jsx)(n.code,{children:"toBeWithinRange"})," may be a more appropriate assertion."]}),"\n",(0,s.jsxs)(n.p,{children:["Custom equality testers are good for globally extending Jest matchers to apply custom equality logic for all equality comparisons. Test authors can't turn on custom testers for certain assertions and turn them off for others (a custom matcher should be used instead if that behavior is desired). For example, defining how to check if two ",(0,s.jsx)(n.code,{children:"Volume"})," objects are equal for all matchers would be a good custom equality tester."]}),"\n",(0,s.jsx)(n.h4,{id:"recursive-custom-equality-testers",children:"Recursive custom equality testers"}),"\n",(0,s.jsxs)(n.p,{children:["If your custom equality testers are testing objects with properties you'd like to do deep equality with, you should use the ",(0,s.jsx)(n.code,{children:"this.equals"})," helper available to equality testers. This ",(0,s.jsx)(n.code,{children:"equals"})," method is the same deep equals method Jest uses internally for all of its deep equality comparisons. It's the method that invokes your custom equality tester. It accepts an array of custom equality testers as a third argument. Custom equality testers are also given an array of custom testers as their third argument. Pass this argument into the third argument of ",(0,s.jsx)(n.code,{children:"equals"})," so that any further equality checks deeper into your object can also take advantage of custom equality testers."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's say you have a ",(0,s.jsx)(n.code,{children:"Book"})," class that contains an array of ",(0,s.jsx)(n.code,{children:"Author"})," classes and both of these classes have custom testers. The ",(0,s.jsx)(n.code,{children:"Book"})," custom tester would want to do a deep equality check on the array of ",(0,s.jsx)(n.code,{children:"Author"}),"s and pass in the custom testers given to it, so the ",(0,s.jsx)(n.code,{children:"Author"}),"s custom equality tester is applied:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'title="customEqualityTesters.js"',children:"function areAuthorEqual(a, b) {\n  const isAAuthor = a instanceof Author;\n  const isBAuthor = b instanceof Author;\n\n  if (isAAuthor && isBAuthor) {\n    // Authors are equal if they have the same name\n    return a.name === b.name;\n  } else if (isAAuthor !== isBAuthor) {\n    return false;\n  } else {\n    return undefined;\n  }\n}\n\nfunction areBooksEqual(a, b, customTesters) {\n  const isABook = a instanceof Book;\n  const isBBook = b instanceof Book;\n\n  if (isABook && isBBook) {\n    // Books are the same if they have the same name and author array. We need\n    // to pass customTesters to equals here so the Author custom tester will be\n    // used when comparing Authors\n    return (\n      a.name === b.name && this.equals(a.authors, b.authors, customTesters)\n    );\n  } else if (isABook !== isBBook) {\n    return false;\n  } else {\n    return undefined;\n  }\n}\n\nexpect.addEqualityTesters([areAuthorsEqual, areBooksEqual]);\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Remember to define your equality testers as regular functions and ",(0,s.jsx)(n.strong,{children:"not"})," arrow functions in order to access the tester context helpers (e.g. ",(0,s.jsx)(n.code,{children:"this.equals"}),")."]})}),"\n",(0,s.jsx)(n.h3,{id:"expectaddsnapshotserializerserializer",children:(0,s.jsx)(n.code,{children:"expect.addSnapshotSerializer(serializer)"})}),"\n",(0,s.jsxs)(n.p,{children:["Pute\u0163i apela ",(0,s.jsx)(n.code,{children:"expect.addSnapshotSerializer"})," pentru a ad\u0103uga un modul care formateaz\u0103 structuri de date specifice aplica\u0163iei."]}),"\n",(0,s.jsxs)(n.p,{children:["Pentru un fi\u015fier de individual test, un modul suplimentar precede orice module din configurarea ",(0,s.jsx)(n.code,{children:"snapshotSerializers"}),", care preced\u0103 la r\xe2ndul lor serializatoarele implicite pentru tipurile JavaScript \u015fi elemente React. Ultimul modul ad\u0103ugat este primul testat."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import serializer from 'my-serializer-module';\nexpect.addSnapshotSerializer(serializer);\n\n// affects expect(value).toMatchSnapshot() assertions in the test file\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you add a snapshot serializer in individual test files instead of adding it to ",(0,s.jsx)(n.code,{children:"snapshotSerializers"})," configuration:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"You make the dependency explicit instead of implicit."}),"\n",(0,s.jsxs)(n.li,{children:["You avoid limits to configuration that might cause you to eject from ",(0,s.jsx)(n.a,{href:"https://github.com/facebookincubator/create-react-app",children:"create-react-app"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["A se vedea ",(0,s.jsx)(n.a,{href:"/ro/docs/configuration#snapshotserializers-arraystring",children:"configurarea Jest"})," pentru mai multe informa\u0163ii."]}),"\n",(0,s.jsx)(n.h3,{id:"expectextendmatchers",children:(0,s.jsx)(n.code,{children:"expect.extend(matchers)"})}),"\n",(0,s.jsxs)(n.p,{children:["Utiliza\u0163i ",(0,s.jsx)(n.code,{children:"expect.extend"})," pentru a ad\u0103uga proprii comparatorii. For example, let's say that you're testing a number utility library and you're frequently asserting that numbers appear within particular ranges of other numbers. You could abstract that into a ",(0,s.jsx)(n.code,{children:"toBeWithinRange"})," matcher:"]}),"\n",(0,s.jsxs)(r.Z,{groupId:"code-examples",children:[(0,s.jsxs)(a.Z,{value:"js",label:"JavaScript",children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'tab={"span":3} title="toBeWithinRange.js"',children:"import {expect} from '@jest/globals';\n\nfunction toBeWithinRange(actual, floor, ceiling) {\n  if (\n    typeof actual !== 'number' ||\n    typeof floor !== 'number' ||\n    typeof ceiling !== 'number'\n  ) {\n    throw new Error('These must be of type number!');\n  }\n\n  const pass = actual >= floor && actual <= ceiling;\n  if (pass) {\n    return {\n      message: () =>\n        `expected ${this.utils.printReceived(\n          actual,\n        )} not to be within range ${this.utils.printExpected(\n          `${floor} - ${ceiling}`,\n        )}`,\n      pass: true,\n    };\n  } else {\n    return {\n      message: () =>\n        `expected ${this.utils.printReceived(\n          actual,\n        )} to be within range ${this.utils.printExpected(\n          `${floor} - ${ceiling}`,\n        )}`,\n      pass: false,\n    };\n  }\n}\n\nexpect.extend({\n  toBeWithinRange,\n});\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'title="__tests__/ranges.test.js"',children:"import {expect, test} from '@jest/globals';\nimport '../toBeWithinRange';\n\ntest('is within range', () => expect(100).toBeWithinRange(90, 110));\n\ntest('is NOT within range', () => expect(101).not.toBeWithinRange(0, 100));\n\ntest('asymmetric ranges', () => {\n  expect({apples: 6, bananas: 3}).toEqual({\n    apples: expect.toBeWithinRange(1, 10),\n    bananas: expect.not.toBeWithinRange(11, 20),\n  });\n});\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="toBeWithinRange.d.ts"',children:"// optionally add a type declaration, e.g. it enables autocompletion in IDEs\ndeclare module 'expect' {\n  interface AsymmetricMatchers {\n    toBeWithinRange(floor: number, ceiling: number): void;\n  }\n  interface Matchers<R> {\n    toBeWithinRange(floor: number, ceiling: number): R;\n  }\n}\n\nexport {};\n"})})]}),(0,s.jsxs)(a.Z,{value:"ts",label:"TypeScript",children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'tab={"span":2} title="toBeWithinRange.ts"',children:"import {expect} from '@jest/globals';\nimport type {MatcherFunction} from 'expect';\n\nconst toBeWithinRange: MatcherFunction<[floor: unknown, ceiling: unknown]> =\n  // `floor` and `ceiling` get types from the line above\n  // it is recommended to type them as `unknown` and to validate the values\n  function (actual, floor, ceiling) {\n    if (\n      typeof actual !== 'number' ||\n      typeof floor !== 'number' ||\n      typeof ceiling !== 'number'\n    ) {\n      throw new Error('These must be of type number!');\n    }\n\n    const pass = actual >= floor && actual <= ceiling;\n    if (pass) {\n      return {\n        message: () =>\n          // `this` context will have correct typings\n          `expected ${this.utils.printReceived(\n            actual,\n          )} not to be within range ${this.utils.printExpected(\n            `${floor} - ${ceiling}`,\n          )}`,\n        pass: true,\n      };\n    } else {\n      return {\n        message: () =>\n          `expected ${this.utils.printReceived(\n            actual,\n          )} to be within range ${this.utils.printExpected(\n            `${floor} - ${ceiling}`,\n          )}`,\n        pass: false,\n      };\n    }\n  };\n\nexpect.extend({\n  toBeWithinRange,\n});\n\ndeclare module 'expect' {\n  interface AsymmetricMatchers {\n    toBeWithinRange(floor: number, ceiling: number): void;\n  }\n  interface Matchers<R> {\n    toBeWithinRange(floor: number, ceiling: number): R;\n  }\n}\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'tab title="__tests__/ranges.test.ts"',children:"import {expect, test} from '@jest/globals';\nimport '../toBeWithinRange';\n\ntest('is within range', () => expect(100).toBeWithinRange(90, 110));\n\ntest('is NOT within range', () => expect(101).not.toBeWithinRange(0, 100));\n\ntest('asymmetric ranges', () => {\n  expect({apples: 6, bananas: 3}).toEqual({\n    apples: expect.toBeWithinRange(1, 10),\n    bananas: expect.not.toBeWithinRange(11, 20),\n  });\n});\n"})})]})]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["The type declaration of the matcher can live in a ",(0,s.jsx)(n.code,{children:".d.ts"})," file or in an imported ",(0,s.jsx)(n.code,{children:".ts"})," module (see JS and TS examples above respectively). If you keep the declaration in a ",(0,s.jsx)(n.code,{children:".d.ts"})," file, make sure that it is included in the program and that it is a valid module, i.e. it has at least an empty ",(0,s.jsx)(n.code,{children:"export {}"}),"."]})}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsxs)(n.p,{children:["Instead of importing ",(0,s.jsx)(n.code,{children:"toBeWithinRange"})," module to the test file, you can enable the matcher for all tests by moving the ",(0,s.jsx)(n.code,{children:"expect.extend"})," call to a ",(0,s.jsx)(n.a,{href:"Configuration.md/#setupfilesafterenv-array",children:(0,s.jsx)(n.code,{children:"setupFilesAfterEnv"})})," script:"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import {expect} from '@jest/globals';\n// remember to export `toBeWithinRange` as well\nimport {toBeWithinRange} from './toBeWithinRange';\n\nexpect.extend({\n  toBeWithinRange,\n});\n"})})]}),"\n",(0,s.jsx)(n.h4,{id:"async-matchers",children:"Async Matchers"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.extend"})," also supports async matchers. Async matchers return a Promise so you will need to await the returned value. Let's use an example matcher to illustrate the usage of them. We are going to implement a matcher called ",(0,s.jsx)(n.code,{children:"toBeDivisibleByExternalValue"}),", where the divisible number is going to be pulled from an external source."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"expect.extend({\n  async toBeDivisibleByExternalValue(received) {\n    const externalValue = await getExternalValueFromRemoteSource();\n    const pass = received % externalValue == 0;\n    if (pass) {\n      return {\n        message: () =>\n          `expected ${received} not to be divisible by ${externalValue}`,\n        pass: true,\n      };\n    } else {\n      return {\n        message: () =>\n          `expected ${received} to be divisible by ${externalValue}`,\n        pass: false,\n      };\n    }\n  },\n});\n\ntest('is divisible by external value', async () => {\n  await expect(100).toBeDivisibleByExternalValue();\n  await expect(101).not.toBeDivisibleByExternalValue();\n});\n"})}),"\n",(0,s.jsx)(n.h4,{id:"custom-matchers-api",children:"Custom Matchers API"}),"\n",(0,s.jsxs)(n.p,{children:["Matchers should return an object (or a Promise of an object) with two keys. ",(0,s.jsx)(n.code,{children:"pass"})," indic\u0103 dac\u0103 a fost o potrivire sau nu, \u015fi ",(0,s.jsx)(n.code,{children:"message"})," ofer\u0103 o func\u0163ie f\u0103r\u0103 argumente care returneaz\u0103 un mesaj de eroare \xeen caz de e\u015fec. Astfel, atunci c\xe2nd ",(0,s.jsx)(n.code,{children:"pass"})," este fals, ",(0,s.jsx)(n.code,{children:"message"})," trebuie s\u0103 returneze mesajul de eroare pentru atunci c\xe2nd ",(0,s.jsx)(n.code,{children:"expect(x).yourMatcher()"})," e\u0219ueaz\u0103. Iar c\xe2nd ",(0,s.jsx)(n.code,{children:"pass"})," este adev\u0103rat, ",(0,s.jsx)(n.code,{children:"message"})," trebuie s\u0103 returneze mesajul de eroare pentru atunci c\xe2nd ",(0,s.jsx)(n.code,{children:"expect(x).not.yourMatcher()"})," e\u0219ueaz\u0103."]}),"\n",(0,s.jsxs)(n.p,{children:["Matchers are called with the argument passed to ",(0,s.jsx)(n.code,{children:"expect(x)"})," followed by the arguments passed to ",(0,s.jsx)(n.code,{children:".yourMatcher(y, z)"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"expect.extend({\n  yourMatcher(x, y, z) {\n    return {\n      pass: true,\n      message: () => '',\n    };\n  },\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["These helper functions and properties can be found on ",(0,s.jsx)(n.code,{children:"this"})," inside a custom matcher:"]}),"\n",(0,s.jsx)(n.h4,{id:"thisisnot",children:(0,s.jsx)(n.code,{children:"this.isNot"})}),"\n",(0,s.jsxs)(n.p,{children:["A boolean to let you know this matcher was called with the negated ",(0,s.jsx)(n.code,{children:".not"})," modifier allowing you to display a clear and correct matcher hint (see example code)."]}),"\n",(0,s.jsx)(n.h4,{id:"thispromise",children:(0,s.jsx)(n.code,{children:"this.promise"})}),"\n",(0,s.jsx)(n.p,{children:"A string allowing you to display a clear and correct matcher hint:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"'rejects'"})," if matcher was called with the promise ",(0,s.jsx)(n.code,{children:".rejects"})," modifier"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"'resolves'"})," if matcher was called with the promise ",(0,s.jsx)(n.code,{children:".resolves"})," modifier"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"''"})," if matcher was not called with a promise modifier"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"thisequalsa-b-customtesters-1",children:(0,s.jsx)(n.code,{children:"this.equals(a, b, customTesters?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Aceasta este o func\u0163ie de egalitate-\xeen-ad\xe2ncime, care va returna ",(0,s.jsx)(n.code,{children:"true"})," dac\u0103 dou\u0103 obiecte au acelea\u015fi valori (recursiv). It optionally takes a list of custom equality testers to apply to the deep equality checks (see ",(0,s.jsx)(n.code,{children:"this.customTesters"})," below)."]}),"\n",(0,s.jsx)(n.h4,{id:"thisexpand",children:(0,s.jsx)(n.code,{children:"this.expand"})}),"\n",(0,s.jsxs)(n.p,{children:["A boolean to let you know this matcher was called with an ",(0,s.jsx)(n.code,{children:"expand"})," option. When Jest is called with the ",(0,s.jsx)(n.code,{children:"--expand"})," flag, ",(0,s.jsx)(n.code,{children:"this.expand"})," can be used to determine if Jest is expected to show full diffs and errors."]}),"\n",(0,s.jsx)(n.h4,{id:"thisutils",children:(0,s.jsx)(n.code,{children:"this.utils"})}),"\n",(0,s.jsxs)(n.p,{children:["There are a number of helpful tools exposed on ",(0,s.jsx)(n.code,{children:"this.utils"})," primarily consisting of the exports from ",(0,s.jsx)(n.a,{href:"https://github.com/jestjs/jest/tree/main/packages/jest-matcher-utils",children:(0,s.jsx)(n.code,{children:"jest-matcher-utils"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Cele mai utile sunt ",(0,s.jsx)(n.code,{children:"matcherHint"}),", ",(0,s.jsx)(n.code,{children:"printExpected"})," \u015fi ",(0,s.jsx)(n.code,{children:"printReceived"})," pentru a formata frumos mesajele de eroare. De exemplu, s\u0103 arunc\u0103m o privire asupra implement\u0103rii pentru ",(0,s.jsx)(n.code,{children:"toBe"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {diff} = require('jest-diff');\nexpect.extend({\n  toBe(received, expected) {\n    const options = {\n      comment: 'Object.is equality',\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n\n    const pass = Object.is(received, expected);\n\n    const message = pass\n      ? () =>\n          // eslint-disable-next-line prefer-template\n          this.utils.matcherHint('toBe', undefined, undefined, options) +\n          '\\n\\n' +\n          `Expected: not ${this.utils.printExpected(expected)}\\n` +\n          `Received: ${this.utils.printReceived(received)}`\n      : () => {\n          const diffString = diff(expected, received, {\n            expand: this.expand,\n          });\n          return (\n            // eslint-disable-next-line prefer-template\n            this.utils.matcherHint('toBe', undefined, undefined, options) +\n            '\\n\\n' +\n            (diffString && diffString.includes('- Expect')\n              ? `Difference:\\n\\n${diffString}`\n              : `Expected: ${this.utils.printExpected(expected)}\\n` +\n                `Received: ${this.utils.printReceived(received)}`)\n          );\n        };\n\n    return {actual: received, message, pass};\n  },\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Acest lucru va afi\u0219a ceva similar:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'  expect(received).toBe(expected)\n\n    Expected value to be (using Object.is):\n      "banana"\n    Received:\n      "apple"\n'})}),"\n",(0,s.jsx)(n.p,{children:"Atunci c\xe2nd o aser\u0163iune e\u0219ueaz\u0103, mesajul de eroare ar trebui s\u0103 dea detalii suficiente pentru utilizator, astfel \xeenc\xe2t ei poat\u0103 rezolva problema rapid. Ar trebui s\u0103 construi\u021bi mesaje de eroare precise pentru a v\u0103 asigura c\u0103 utilizatorii de aser\u021biunilor voastre au o experien\u0163\u0103 bun\u0103."}),"\n",(0,s.jsx)(n.h4,{id:"thiscustomtesters",children:(0,s.jsx)(n.code,{children:"this.customTesters"})}),"\n",(0,s.jsxs)(n.p,{children:["If your matcher does a deep equality check using ",(0,s.jsx)(n.code,{children:"this.equals"}),", you may want to pass user-provided custom testers to ",(0,s.jsx)(n.code,{children:"this.equals"}),". The custom equality testers the user has provided using the ",(0,s.jsx)(n.code,{children:"addEqualityTesters"})," API are available on this property. The built-in Jest matchers pass ",(0,s.jsx)(n.code,{children:"this.customTesters"})," (along with other built-in testers) to ",(0,s.jsx)(n.code,{children:"this.equals"})," to do deep equality, and your custom matchers may want to do the same."]}),"\n",(0,s.jsx)(n.h4,{id:"custom-snapshot-matchers",children:"Custom snapshot matchers"}),"\n",(0,s.jsxs)(n.p,{children:["To use snapshot testing inside of your custom matcher you can import ",(0,s.jsx)(n.code,{children:"jest-snapshot"})," and use it from within your matcher."]}),"\n",(0,s.jsxs)(n.p,{children:["Here's a snapshot matcher that trims a string to store for a given length, ",(0,s.jsx)(n.code,{children:".toMatchTrimmedSnapshot(length)"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {toMatchSnapshot} = require('jest-snapshot');\n\nexpect.extend({\n  toMatchTrimmedSnapshot(received, length) {\n    return toMatchSnapshot.call(\n      this,\n      received.substring(0, length),\n      'toMatchTrimmedSnapshot',\n    );\n  },\n});\n\nit('stores only 10 characters', () => {\n  expect('extra long string oh my gerd').toMatchTrimmedSnapshot(10);\n});\n\n/*\nStored snapshot will look like:\n\nexports[`stores only 10 characters: toMatchTrimmedSnapshot 1`] = `\"extra long\"`;\n*/\n"})}),"\n",(0,s.jsx)(n.p,{children:"It's also possible to create custom matchers for inline snapshots, the snapshots will be correctly added to the custom matchers. However, inline snapshot will always try to append to the first argument or the second when the first argument is the property matcher, so it's not possible to accept custom arguments in the custom matchers."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {toMatchInlineSnapshot} = require('jest-snapshot');\n\nexpect.extend({\n  toMatchTrimmedInlineSnapshot(received, ...rest) {\n    return toMatchInlineSnapshot.call(this, received.substring(0, 10), ...rest);\n  },\n});\n\nit('stores only 10 characters', () => {\n  expect('extra long string oh my gerd').toMatchTrimmedInlineSnapshot();\n  /*\n  The snapshot will be added inline like\n  expect('extra long string oh my gerd').toMatchTrimmedInlineSnapshot(\n    `\"extra long\"`\n  );\n  */\n});\n"})}),"\n",(0,s.jsx)(n.h4,{id:"async",children:"async"}),"\n",(0,s.jsxs)(n.p,{children:["If your custom inline snapshot matcher is async i.e. uses ",(0,s.jsx)(n.code,{children:"async"}),"-",(0,s.jsx)(n.code,{children:"await"}),' you might encounter an error like "Multiple inline snapshots for the same call are not supported". Jest needs additional context information to find where the custom inline snapshot matcher was used to update the snapshots properly.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {toMatchInlineSnapshot} = require('jest-snapshot');\n\nexpect.extend({\n  async toMatchObservationInlineSnapshot(fn, ...rest) {\n    // The error (and its stacktrace) must be created before any `await`\n    this.error = new Error();\n\n    // The implementation of `observe` doesn't matter.\n    // It only matters that the custom snapshot matcher is async.\n    const observation = await observe(async () => {\n      await fn();\n    });\n\n    return toMatchInlineSnapshot.call(this, recording, ...rest);\n  },\n});\n\nit('observes something', async () => {\n  await expect(async () => {\n    return 'async action';\n  }).toMatchTrimmedInlineSnapshot();\n  /*\n  The snapshot will be added inline like\n  await expect(async () => {\n    return 'async action';\n  }).toMatchTrimmedInlineSnapshot(`\"async action\"`);\n  */\n});\n"})}),"\n",(0,s.jsx)(n.h4,{id:"bail-out",children:"Bail out"}),"\n",(0,s.jsxs)(n.p,{children:["Usually ",(0,s.jsx)(n.code,{children:"jest"})," tries to match every snapshot that is expected in a test."]}),"\n",(0,s.jsx)(n.p,{children:"Sometimes it might not make sense to continue the test if a prior snapshot failed. For example, when you make snapshots of a state-machine after various transitions you can abort the test once one transition produced the wrong state."}),"\n",(0,s.jsx)(n.p,{children:"In that case you can implement a custom snapshot matcher that throws on the first mismatch instead of collecting every mismatch."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {toMatchInlineSnapshot} = require('jest-snapshot');\n\nexpect.extend({\n  toMatchStateInlineSnapshot(...args) {\n    this.dontThrow = () => {};\n\n    return toMatchInlineSnapshot.call(this, ...args);\n  },\n});\n\nlet state = 'initial';\n\nfunction transition() {\n  // Typo in the implementation should cause the test to fail\n  if (state === 'INITIAL') {\n    state = 'pending';\n  } else if (state === 'pending') {\n    state = 'done';\n  }\n}\n\nit('transitions as expected', () => {\n  expect(state).toMatchStateInlineSnapshot(`\"initial\"`);\n\n  transition();\n  // Already produces a mismatch. No point in continuing the test.\n  expect(state).toMatchStateInlineSnapshot(`\"loading\"`);\n\n  transition();\n  expect(state).toMatchStateInlineSnapshot(`\"done\"`);\n});\n"})})]})}const m=function(e={}){const{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(x,e)})):x(e)}},9459:(e,n,t)=>{t.d(n,{ZP:()=>a});var s=t(4246),i=t(1670);function r(e){const n=Object.assign({admonition:"admonition",p:"p",pre:"pre",code:"code",a:"a"},(0,i.ah)(),e.components);return(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.p,{children:"The TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import {expect, jest, test} from '@jest/globals';\n"})}),(0,s.jsxs)(n.p,{children:["Consult the ",(0,s.jsx)(n.a,{href:"/ro/docs/getting-started#using-typescript",children:"Getting Started"})," guide for details on how to setup Jest with TypeScript."]})]})}const a=function(e={}){const{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(r,e)})):r(e)}}}]);