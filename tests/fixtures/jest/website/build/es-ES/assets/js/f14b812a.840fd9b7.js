"use strict";(self.webpackChunkjest_website=self.webpackChunkjest_website||[]).push([[5428],{5166:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>i,contentTitle:()=>r,default:()=>u,frontMatter:()=>t,metadata:()=>c,toc:()=>d});var a=n(4246),o=n(1670);const t={id:"bypassing-module-mocks",title:"Evitar mocks de m\xf3dulos"},r=void 0,c={unversionedId:"bypassing-module-mocks",id:"version-29.4/bypassing-module-mocks",title:"Evitar mocks de m\xf3dulos",description:"Jest te permite simular m\xf3dulos completos en tus pruebas, o que puede ser \xfatil para probar si tu c\xf3digo est\xe1 convocando correctamente las funciones de ese m\xf3dulo. Sin embargo, a veces puede que quieras usar parte de un modulo mock en tus archivos de test. En ese caso, es necesario que accedas a la implementaci\xf3n original y no la implementaci\xf3n mock.",source:"@site/i18n/es-ES/docusaurus-plugin-content-docs/version-29.4/BypassingModuleMocks.md",sourceDirName:".",slug:"/bypassing-module-mocks",permalink:"/es-ES/docs/29.4/bypassing-module-mocks",draft:!1,unlisted:!1,editUrl:"https://crowdin.com/project/jest-v2/es-ES",tags:[],version:"29.4",frontMatter:{id:"bypassing-module-mocks",title:"Evitar mocks de m\xf3dulos"},sidebar:"docs",previous:{title:"Mocks de clase ES6",permalink:"/es-ES/docs/29.4/es6-class-mocks"},next:{title:"ECMAScript Modules",permalink:"/es-ES/docs/29.4/ecmascript-modules"}},i={},d=[];function l(e){const s=Object.assign({p:"p",em:"em",code:"code",pre:"pre"},(0,o.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(s.p,{children:["Jest te permite simular m\xf3dulos completos en tus pruebas, o que puede ser \xfatil para probar si tu c\xf3digo est\xe1 convocando correctamente las funciones de ese m\xf3dulo. Sin embargo, a veces puede que quieras usar parte de un modulo mock en tus ",(0,a.jsx)(s.em,{children:"archivos de test"}),". En ese caso, es necesario que accedas a la implementaci\xf3n original y no la implementaci\xf3n mock."]}),"\n",(0,a.jsxs)(s.p,{children:["Considera escribir un test para la funci\xf3n ",(0,a.jsx)(s.code,{children:"crearUsuario"}),":"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-javascript",metastring:'title="createUser.js"',children:"import fetch from 'node-fetch';\n\nexport const createUser = async () => {\n  const response = await fetch('https://website.com/users', {method: 'POST'});\n  const userId = await response.text();\n  return userId;\n};\n"})}),"\n",(0,a.jsxs)(s.p,{children:["Tu test querr\xe1 ocupar un mock para la funci\xf3n ",(0,a.jsx)(s.code,{children:"fetch"}),", para que sepamos que ha sido llamada sin que en realidad haga una llamada en la red. Sin embargo, tambi\xe9n necesitaras crear un mock para el valor que regresa ",(0,a.jsx)(s.code,{children:"fetch"})," con una ",(0,a.jsx)(s.code,{children:"Response"})," (envuelta en una ",(0,a.jsx)(s.code,{children:"Promise"}),"), ya que nuestra funci\xf3n la ocupa para obtener el Id del usuario creado. De modo que inicialmente escribir\xedas un test como el siguiente:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-javascript",children:"jest.mock('node-fetch');\n\nimport fetch, {Response} from 'node-fetch';\nimport {createUser} from './createUser';\n\ntest('createUser calls fetch with the right args and returns the user id', async () => {\n  fetch.mockReturnValue(Promise.resolve(new Response('4')));\n\n  const userId = await createUser();\n\n  expect(fetch).toHaveBeenCalledTimes(1);\n  expect(fetch).toHaveBeenCalledWith('https://website.com/users', {\n    method: 'POST',\n  });\n  expect(userId).toBe('4');\n});\n"})}),"\n",(0,a.jsxs)(s.p,{children:["Sin embargo, te encontrar\xedas con que la funci\xf3n ",(0,a.jsx)(s.code,{children:"createUser"})," fallar\xeda, arrojando el error ",(0,a.jsx)(s.code,{children:"TypeError: respuesta.text is not a function"})," (Error de Tipo: respuesta.text no es una funci\xf3n). Esto es porque la clase ",(0,a.jsx)(s.code,{children:"Response"})," que importaste de ",(0,a.jsx)(s.code,{children:"node-fetch"})," ha sido sustituida por un mock (por la llamada a ",(0,a.jsx)(s.code,{children:"jest.mock"})," al principio del archivo test), as\xed que no se comporta de la manera esperada."]}),"\n",(0,a.jsxs)(s.p,{children:["Para evitar problemas como este, Jest proporciona la funci\xf3n ",(0,a.jsx)(s.code,{children:"jest.requireActual"})," . Para hacer que la prueba anterior funcione, haz los siguientes cambios a las importaciones en el archivo test:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-javascript",children:"// ANTES\njest.mock('node-fetch');\nimport fetch, {Response} from 'node-fetch';\n"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-javascript",children:"// DESPU\xc9S\njest.mock('node-fetch');\nimport fetch from 'node-fetch';\nconst {Response} = jest.requireActual('node-fetch');\n"})}),"\n",(0,a.jsxs)(s.p,{children:["Esto permite que el archivo test importe el objeto ",(0,a.jsx)(s.code,{children:"Response"})," real de ",(0,a.jsx)(s.code,{children:"node-fetch"}),", en lugar de una versi\xf3n mock. Esto significa que la prueba pasar\xe1 correctamente."]})]})}const u=function(e={}){const{wrapper:s}=Object.assign({},(0,o.ah)(),e.components);return s?(0,a.jsx)(s,Object.assign({},e,{children:(0,a.jsx)(l,e)})):l(e)}},1670:(e,s,n)=>{n.d(s,{Zo:()=>c,ah:()=>t});var a=n(7378);const o=a.createContext({});function t(e){const s=a.useContext(o);return a.useMemo((()=>"function"==typeof e?e(s):{...s,...e}),[s,e])}const r={};function c({components:e,children:s,disableParentContext:n}){let c;return c=n?"function"==typeof e?e({}):e||r:t(e),a.createElement(o.Provider,{value:c},s)}}}]);