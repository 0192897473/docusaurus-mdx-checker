"use strict";(self.webpackChunkjest_website=self.webpackChunkjest_website||[]).push([[7827],{2550:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var s=a(4246),t=a(1670);const o={id:"setup-teardown",title:"Inicializaci\xf3n y Finalizaci\xf3n"},r=void 0,i={unversionedId:"setup-teardown",id:"version-29.4/setup-teardown",title:"Inicializaci\xf3n y Finalizaci\xf3n",description:"Frecuentemente cuando escribes las pruebas tienes algo de trabajo de inicializaci\xf3n que necesita ejecutarse antes de correr las pruebas, y tienes trabajo de finalizaci\xf3n que debe ejecutarse luego de correr las pruebas. Jest provee funciones para manejar esto.",source:"@site/i18n/es-ES/docusaurus-plugin-content-docs/version-29.4/SetupAndTeardown.md",sourceDirName:".",slug:"/setup-teardown",permalink:"/es-ES/docs/29.4/setup-teardown",draft:!1,unlisted:!1,editUrl:"https://crowdin.com/project/jest-v2/es-ES",tags:[],version:"29.4",frontMatter:{id:"setup-teardown",title:"Inicializaci\xf3n y Finalizaci\xf3n"},sidebar:"docs",previous:{title:"Tests de c\xf3digo as\xedncrono",permalink:"/es-ES/docs/29.4/asynchronous"},next:{title:"Funciones Mock",permalink:"/es-ES/docs/29.4/mock-functions"}},c={},l=[{value:"Repeating Setup",id:"repeating-setup",level:2},{value:"Inicializaci\xf3n una vez antes de todos los tests",id:"inicializaci\xf3n-una-vez-antes-de-todos-los-tests",level:2},{value:"Alcance",id:"alcance",level:2},{value:"Order of Execution",id:"order-of-execution",level:2},{value:"Aviso General",id:"aviso-general",level:2}];function d(e){const n=Object.assign({p:"p",h2:"h2",code:"code",pre:"pre",a:"a",em:"em",admonition:"admonition"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Frecuentemente cuando escribes las pruebas tienes algo de trabajo de inicializaci\xf3n que necesita ejecutarse antes de correr las pruebas, y tienes trabajo de finalizaci\xf3n que debe ejecutarse luego de correr las pruebas. Jest provee funciones para manejar esto."}),"\n",(0,s.jsx)(n.h2,{id:"repeating-setup",children:"Repeating Setup"}),"\n",(0,s.jsxs)(n.p,{children:["If you have some work you need to do repeatedly for many tests, you can use ",(0,s.jsx)(n.code,{children:"beforeEach"})," and ",(0,s.jsx)(n.code,{children:"afterEach"})," hooks."]}),"\n",(0,s.jsxs)(n.p,{children:["Por ejemplo, digamos que varias pruebas interact\xfaan con la base de datos de ciudades. Tienes un m\xe9todo ",(0,s.jsx)(n.code,{children:"initializeCityDatabase()"})," que debe ser llamada antes de cada prueba, y un m\xe9todo ",(0,s.jsx)(n.code,{children:"clearCityDatabase()"})," que debe ser llamado luego de cada prueba. Puedes hacer esto con:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"beforeEach(() => {\n  initializeCityDatabase();\n});\n\nafterEach(() => {\n  clearCityDatabase();\n});\n\ntest('city database has Vienna', () => {\n  expect(isCity('Vienna')).toBeTruthy();\n});\n\ntest('city database has San Juan', () => {\n  expect(isCity('San Juan')).toBeTruthy();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"beforeEach"})," y ",(0,s.jsx)(n.code,{children:"afterEach"})," pueden manejar c\xf3digo as\xedncrono en el mismo modo que ",(0,s.jsx)(n.a,{href:"/es-ES/docs/29.4/asynchronous",children:"las pruebas manejan c\xf3digo as\xedncrono"})," - ambos pueden tomar ",(0,s.jsx)(n.code,{children:"done"})," como par\xe1metro o devolver una promesa. Por ejemplo, si ",(0,s.jsx)(n.code,{children:"initializeCityDatabase()"})," devuelve una promesa que es resuelta cuando la base de datos es inicializada, nos gustar\xeda que devuelva esa promesa:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"beforeEach(() => {\n  return initializeCityDatabase();\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"inicializaci\xf3n-una-vez-antes-de-todos-los-tests",children:"Inicializaci\xf3n una vez antes de todos los tests"}),"\n",(0,s.jsxs)(n.p,{children:["En algunos casos, solo necesitar\xe1s realizar la preparaci\xf3n una sola vez, al principio del archivo. Esto puede ser especialmente molesto cuando la inicializaci\xf3n es as\xedncrona, y no puede hacerse simplemente en una sola l\xednea. Jest provides ",(0,s.jsx)(n.code,{children:"beforeAll"})," and ",(0,s.jsx)(n.code,{children:"afterAll"})," hooks to handle this situation."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, if both ",(0,s.jsx)(n.code,{children:"initializeCityDatabase()"})," and ",(0,s.jsx)(n.code,{children:"clearCityDatabase()"})," returned promises, and the city database could be reused between tests, we could change our test code to:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"beforeAll(() => {\n  return initializeCityDatabase();\n});\n\nafterAll(() => {\n  return clearCityDatabase();\n});\n\ntest('city database has Vienna', () => {\n  expect(isCity('Vienna')).toBeTruthy();\n});\n\ntest('city database has San Juan', () => {\n  expect(isCity('San Juan')).toBeTruthy();\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"alcance",children:"Alcance"}),"\n",(0,s.jsxs)(n.p,{children:["The top level ",(0,s.jsx)(n.code,{children:"before*"})," and ",(0,s.jsx)(n.code,{children:"after*"})," hooks apply to every test in a file. The hooks declared inside a ",(0,s.jsx)(n.code,{children:"describe"})," block apply only to the tests within that ",(0,s.jsx)(n.code,{children:"describe"})," block."]}),"\n",(0,s.jsx)(n.p,{children:"Por ejemplo, supongamos que hemos tenido no s\xf3lo una base de datos de ciudades, sino tambi\xe9n una base de datos de alimentos. Podr\xedamos hacer una configuraci\xf3n diferente para diferentes pruebas:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Applies to all tests in this file\nbeforeEach(() => {\n  return initializeCityDatabase();\n});\n\ntest('city database has Vienna', () => {\n  expect(isCity('Vienna')).toBeTruthy();\n});\n\ntest('city database has San Juan', () => {\n  expect(isCity('San Juan')).toBeTruthy();\n});\n\ndescribe('matching cities to foods', () => {\n  // Applies only to tests in this describe block\n  beforeEach(() => {\n    return initializeFoodDatabase();\n  });\n\n  test('Vienna <3 veal', () => {\n    expect(isValidCityFoodPair('Vienna', 'Wiener Schnitzel')).toBe(true);\n  });\n\n  test('San Juan <3 plantains', () => {\n    expect(isValidCityFoodPair('San Juan', 'Mofongo')).toBe(true);\n  });\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Ten en cuenta que el ",(0,s.jsx)(n.code,{children:"beforeEach"})," de nivel superior ser\xe1 ejecutado antes del ",(0,s.jsx)(n.code,{children:"beforeEach"})," dentro del ",(0,s.jsx)(n.code,{children:"describe"}),". Puede ayudar a ilustrar el orden de ejecuci\xf3n de todos los hooks."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"beforeAll(() => console.log('1 - beforeAll'));\nafterAll(() => console.log('1 - afterAll'));\nbeforeEach(() => console.log('1 - beforeEach'));\nafterEach(() => console.log('1 - afterEach'));\n\ntest('', () => console.log('1 - test'));\n\ndescribe('Scoped / Nested block', () => {\n  beforeAll(() => console.log('2 - beforeAll'));\n  afterAll(() => console.log('2 - afterAll'));\n  beforeEach(() => console.log('2 - beforeEach'));\n  afterEach(() => console.log('2 - afterEach'));\n\n  test('', () => console.log('2 - test'));\n});\n\n// 1 - beforeAll\n// 1 - beforeEach\n// 1 - test\n// 1 - afterEach\n// 2 - beforeAll\n// 1 - beforeEach\n// 2 - beforeEach\n// 2 - test\n// 2 - afterEach\n// 1 - afterEach\n// 2 - afterAll\n// 1 - afterAll\n"})}),"\n",(0,s.jsx)(n.h2,{id:"order-of-execution",children:"Order of Execution"}),"\n",(0,s.jsxs)(n.p,{children:["Jest ejecuta todos los manejadores de los describes en el archivo de tests ",(0,s.jsx)(n.em,{children:"antes"})," que se ejecute alguno de los tests. This is another reason to do setup and teardown inside ",(0,s.jsx)(n.code,{children:"before*"})," and ",(0,s.jsx)(n.code,{children:"after*"})," handlers rather than inside the ",(0,s.jsx)(n.code,{children:"describe"})," blocks. Once the ",(0,s.jsx)(n.code,{children:"describe"})," blocks are complete, by default Jest runs all the tests serially in the order they were encountered in the collection phase, waiting for each to finish and be tidied up before moving on."]}),"\n",(0,s.jsx)(n.p,{children:"Considere el siguiente archivo de prueba ilustrativa y su respectiva salida:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('describe outer', () => {\n  console.log('describe outer-a');\n\n  describe('describe inner 1', () => {\n    console.log('describe inner 1');\n\n    test('test 1', () => console.log('test 1'));\n  });\n\n  console.log('describe outer-b');\n\n  test('test 2', () => console.log('test 2'));\n\n  describe('describe inner 2', () => {\n    console.log('describe inner 2');\n\n    test('test 3', () => console.log('test 3'));\n  });\n\n  console.log('describe outer-c');\n});\n\n// describe outer-a\n// describe inner 1\n// describe outer-b\n// describe inner 2\n// describe outer-c\n// test 1\n// test 2\n// test 3\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Just like the ",(0,s.jsx)(n.code,{children:"describe"})," and ",(0,s.jsx)(n.code,{children:"test"})," blocks Jest calls the ",(0,s.jsx)(n.code,{children:"before*"})," and ",(0,s.jsx)(n.code,{children:"after*"})," hooks in the order of declaration. Note that the ",(0,s.jsx)(n.code,{children:"after*"})," hooks of the enclosing scope are called first. For example, here is how you can set up and tear down resources which depend on each other:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"beforeEach(() => console.log('connection setup'));\nbeforeEach(() => console.log('database setup'));\n\nafterEach(() => console.log('database teardown'));\nafterEach(() => console.log('connection teardown'));\n\ntest('test 1', () => console.log('test 1'));\n\ndescribe('extra', () => {\n  beforeEach(() => console.log('extra database setup'));\n  afterEach(() => console.log('extra database teardown'));\n\n  test('test 2', () => console.log('test 2'));\n});\n\n// connection setup\n// database setup\n// test 1\n// database teardown\n// connection teardown\n\n// connection setup\n// database setup\n// extra database setup\n// test 2\n// extra database teardown\n// database teardown\n// connection teardown\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["If you are using ",(0,s.jsx)(n.code,{children:"jasmine2"})," test runner, take into account that it calls the ",(0,s.jsx)(n.code,{children:"after*"})," hooks in the reverse order of declaration. To have identical output, the above example should be altered like this:"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-diff",children:"  beforeEach(() => console.log('connection setup'));\n+ afterEach(() => console.log('connection teardown'));\n\n  beforeEach(() => console.log('database setup'));\n+ afterEach(() => console.log('database teardown'));\n\n- afterEach(() => console.log('database teardown'));\n- afterEach(() => console.log('connection teardown'));\n\n  // ...\n"})})]}),"\n",(0,s.jsx)(n.h2,{id:"aviso-general",children:"Aviso General"}),"\n",(0,s.jsxs)(n.p,{children:["Si una prueba falla, una de las primeras cosas a revisar deber\xeda ser si la prueba falla cuando se corre solo esa prueba. Para correr un \xfanico test en Jest, cambie temporalmente ",(0,s.jsx)(n.code,{children:"test"})," a ",(0,s.jsx)(n.code,{children:"test.only"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test.only('this will be the only test that runs', () => {\n  expect(true).toBe(false);\n});\n\ntest('this test will not run', () => {\n  expect('A').toBe('A');\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Si tienes una prueba que a veces falla cuando se ejecuta junto a toda la suite, pero no falla cuando la corres individualmente, es probable que no haya independencia entre los tests. A veces puedes arreglar esto limpiando estados compartidos con ",(0,s.jsx)(n.code,{children:"beforeEach"}),". Si no est\xe1s seguro de que algun estado compartido se est\xe9 modificando, puedes probar un ",(0,s.jsx)(n.code,{children:"beforeEach"})," que imprima los datos."]})]})}const u=function(e={}){const{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(d,e)})):d(e)}},1670:(e,n,a)=>{a.d(n,{Zo:()=>i,ah:()=>o});var s=a(7378);const t=s.createContext({});function o(e){const n=s.useContext(t);return s.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}const r={};function i({components:e,children:n,disableParentContext:a}){let i;return i=a?"function"==typeof e?e({}):e||r:o(e),s.createElement(t.Provider,{value:i},n)}}}]);