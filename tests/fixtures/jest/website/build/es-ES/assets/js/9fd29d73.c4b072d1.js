"use strict";(self.webpackChunkjest_website=self.webpackChunkjest_website||[]).push([[5951],{6135:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var s=n(4246),a=n(1670);const i={id:"timer-mocks",title:"Mocks Temporizados"},o=void 0,r={unversionedId:"timer-mocks",id:"version-29.5/timer-mocks",title:"Mocks Temporizados",description:"The native timer functions (i.e., setTimeout(), setInterval(), clearTimeout(), clearInterval()) are less than ideal for a testing environment since they depend on real time to elapse. Jest puede cambiar temporizadores con funciones que permiten controlar el paso del tiempo.  gran Scott!",source:"@site/i18n/es-ES/docusaurus-plugin-content-docs/version-29.5/TimerMocks.md",sourceDirName:".",slug:"/timer-mocks",permalink:"/es-ES/docs/29.5/timer-mocks",draft:!1,unlisted:!1,editUrl:"https://crowdin.com/project/jest-v2/es-ES",tags:[],version:"29.5",frontMatter:{id:"timer-mocks",title:"Mocks Temporizados"},sidebar:"docs",previous:{title:"Un ejemplo de Async",permalink:"/es-ES/docs/29.5/tutorial-async"},next:{title:"Manual Mocks",permalink:"/es-ES/docs/29.5/manual-mocks"}},l={},c=[{value:"Enable Fake Timers",id:"enable-fake-timers",level:2},{value:"Ejecutar todos los temporizadores",id:"ejecutar-todos-los-temporizadores",level:2},{value:"Ejecutar temporizadores pendientes",id:"ejecutar-temporizadores-pendientes",level:2},{value:"Temporizadores anticipados por tiempo",id:"temporizadores-anticipados-por-tiempo",level:2},{value:"Selective Faking",id:"selective-faking",level:2}];function d(e){const t=Object.assign({p:"p",code:"code",a:"a",admonition:"admonition",h2:"h2",pre:"pre"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["The native timer functions (i.e., ",(0,s.jsx)(t.code,{children:"setTimeout()"}),", ",(0,s.jsx)(t.code,{children:"setInterval()"}),", ",(0,s.jsx)(t.code,{children:"clearTimeout()"}),", ",(0,s.jsx)(t.code,{children:"clearInterval()"}),") are less than ideal for a testing environment since they depend on real time to elapse. Jest puede cambiar temporizadores con funciones que permiten controlar el paso del tiempo. ",(0,s.jsx)(t.a,{href:"https://www.youtube.com/watch?v=QZoJ2Pt27BY",children:" gran Scott!"})]}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsxs)(t.p,{children:["Also see ",(0,s.jsx)(t.a,{href:"/es-ES/docs/29.5/jest-object#fake-timers",children:"Fake Timers API"})," documentation."]})}),"\n",(0,s.jsx)(t.h2,{id:"enable-fake-timers",children:"Enable Fake Timers"}),"\n",(0,s.jsxs)(t.p,{children:["In the following example we enable fake timers by calling ",(0,s.jsx)(t.code,{children:"jest.useFakeTimers()"}),". This is replacing the original implementation of ",(0,s.jsx)(t.code,{children:"setTimeout()"})," and other timer functions. Timers can be restored to their normal behavior with ",(0,s.jsx)(t.code,{children:"jest.useRealTimers()"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",metastring:'title="timerGame.js"',children:"function timerGame(callback) {\n  console.log('Ready....go!');\n  setTimeout(() => {\n    console.log(\"Time's up -- stop!\");\n    callback && callback();\n  }, 1000);\n}\n\nmodule.exports = timerGame;\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",metastring:'title="__tests__/timerGame-test.js"',children:"jest.useFakeTimers();\njest.spyOn(global, 'setTimeout');\n\ntest('waits 1 second before ending the game', () => {\n  const timerGame = require('../timerGame');\n  timerGame();\n\n  expect(setTimeout).toHaveBeenCalledTimes(1);\n  expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 1000);\n});\n"})}),"\n",(0,s.jsx)(t.h2,{id:"ejecutar-todos-los-temporizadores",children:"Ejecutar todos los temporizadores"}),"\n",(0,s.jsx)(t.p,{children:"Another test we might want to write for this module is one that asserts that the callback is called after 1 second. To do this, we're going to use Jest's timer control APIs to fast-forward time right in the middle of the test:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"jest.useFakeTimers();\ntest('calls the callback after 1 second', () => {\n  const timerGame = require('../timerGame');\n  const callback = jest.fn();\n\n  timerGame(callback);\n\n  // At this point in time, the callback should not have been called yet\n  expect(callback).not.toBeCalled();\n\n  // Fast-forward until all timers have been executed\n  jest.runAllTimers();\n\n  // Now our callback should have been called!\n  expect(setTimeout).toHaveBeenCalledTimes(1);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 1000);\n\n    // Fast forward and exhaust only currently pending timers\n    // (but not any new timers that get created during that process)\n    jest.runOnlyPendingTimers();\n\n    // At this point, our 1-second timer should have fired it's callback\n    expect(callback).toBeCalled();\n\n    // And it should have created a new timer to start the game over in\n    // 10 seconds\n    expect(setTimeout).toHaveBeenCalledTimes(2);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 10000);\n  });\n});\n"})}),"\n",(0,s.jsx)(t.h2,{id:"ejecutar-temporizadores-pendientes",children:"Ejecutar temporizadores pendientes"}),"\n",(0,s.jsx)(t.p,{children:'There are also scenarios where you might have a recursive timer \u2013 that is a timer that sets a new timer in its own callback. For these, running all the timers would be an endless loop, throwing the following error: "Aborting after running 100000 timers, assuming an infinite loop!"'}),"\n",(0,s.jsxs)(t.p,{children:["If that is your case, using ",(0,s.jsx)(t.code,{children:"jest.runOnlyPendingTimers()"})," will solve the problem:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",metastring:'title="infiniteTimerGame.js"',children:"function infiniteTimerGame(callback) {\n  console.log('Ready....go!');\n\n  setTimeout(() => {\n    console.log(\"Time's up! 10 seconds before the next game starts...\");\n    callback && callback();\n\n    // Schedule the next game in 10 seconds\n    setTimeout(() => {\n      infiniteTimerGame(callback);\n    }, 10000);\n  }, 1000);\n}\n\nmodule.exports = infiniteTimerGame;\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",metastring:'title="__tests__/infiniteTimerGame-test.js"',children:"jest.useFakeTimers();\njest.spyOn(global, 'setTimeout');\n\ndescribe('infiniteTimerGame', () => {\n  test('schedules a 10-second timer after 1 second', () => {\n    const infiniteTimerGame = require('../infiniteTimerGame');\n    const callback = jest.fn();\n\n    infiniteTimerGame(callback);\n\n    // At this point in time, there should have been a single call to\n    // setTimeout to schedule the end of the game in 1 second.\n    expect(setTimeout).toHaveBeenCalledTimes(1);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 1000);\n\n    // Fast forward and exhaust only currently pending timers\n    // (but not any new timers that get created during that process)\n    jest.runOnlyPendingTimers();\n\n    // At this point, our 1-second timer should have fired its callback\n    expect(callback).toBeCalled();\n\n    // And it should have created a new timer to start the game over in\n    // 10 seconds\n    expect(setTimeout).toHaveBeenCalledTimes(2);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 10000);\n  });\n});\n"})}),"\n",(0,s.jsxs)(t.admonition,{type:"note",children:[(0,s.jsx)(t.p,{children:"For debugging or any other reason you can change the limit of timers that will be run before throwing an error:"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"jest.useFakeTimers({timerLimit: 100});\n"})})]}),"\n",(0,s.jsx)(t.h2,{id:"temporizadores-anticipados-por-tiempo",children:"Temporizadores anticipados por tiempo"}),"\n",(0,s.jsxs)(t.p,{children:["Otra posibilidad es usar ",(0,s.jsx)(t.code,{children:"jest.advanceTimersByTime(msToRun)"}),". Cuando este API es llamado, todos los timers son avanzados por milisegundos ",(0,s.jsx)(t.code,{children:"msToRun"}),". Cuando este API es llamado, todos los timers son avanzados por milisegundos ",(0,s.jsx)(t.code,{children:"msToRun"}),'. All pending "macro-tasks" that have been queued via setTimeout() or setInterval(), and would be executed during this time frame, will be executed.']}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",metastring:'title="timerGame.js"',children:"function timerGame(callback) {\n  console.log('Ready....go!');\n  setTimeout(() => {\n    console.log(\"Time's up -- stop!\");\n    callback && callback();\n  }, 1000);\n}\n\nmodule.exports = timerGame;\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",metastring:'title="__tests__/timerGame-test.js"',children:"jest.useFakeTimers();\nit('calls the callback after 1 second via advanceTimersByTime', () => {\n  const timerGame = require('../timerGame');\n  const callback = jest.fn();\n\n  timerGame(callback);\n\n  // At this point in time, the callback should not have been called yet\n  expect(callback).not.toBeCalled();\n\n  // Fast-forward until all timers have been executed\n  jest.advanceTimersByTime(1000);\n\n  // Now our callback should have been called!\n  expect(setTimeout).toHaveBeenCalledTimes(1);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 1000);\n\n    // Fast forward and exhaust only currently pending timers\n    // (but not any new timers that get created during that process)\n    jest.runOnlyPendingTimers();\n\n    // At this point, our 1-second timer should have fired it's callback\n    expect(callback).toBeCalled();\n\n    // And it should have created a new timer to start the game over in\n    // 10 seconds\n    expect(setTimeout).toHaveBeenCalledTimes(2);\n    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 10000);\n  });\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Lastly, it may occasionally be useful in some tests to be able to clear all of the pending timers. For this, we have ",(0,s.jsx)(t.code,{children:"jest.clearAllTimers()"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"selective-faking",children:"Selective Faking"}),"\n",(0,s.jsxs)(t.p,{children:["Sometimes your code may require to avoid overwriting the original implementation of one or another API. If that is the case, you can use ",(0,s.jsx)(t.code,{children:"doNotFake"})," option. For example, here is how you could provide a custom mock function for ",(0,s.jsx)(t.code,{children:"performance.mark()"})," in jsdom environment:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"/**\n * @jest-environment jsdom\n */\n\nconst mockPerformanceMark = jest.fn();\nwindow.performance.mark = mockPerformanceMark;\n\ntest('allows mocking `performance.mark()`', () => {\n  jest.useFakeTimers({doNotFake: ['performance']});\n\n  expect(window.performance.mark).toBe(mockPerformanceMark);\n});\n"})})]})}const m=function(e={}){const{wrapper:t}=Object.assign({},(0,a.ah)(),e.components);return t?(0,s.jsx)(t,Object.assign({},e,{children:(0,s.jsx)(d,e)})):d(e)}},1670:(e,t,n)=>{n.d(t,{Zo:()=>r,ah:()=>i});var s=n(7378);const a=s.createContext({});function i(e){const t=s.useContext(a);return s.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}const o={};function r({components:e,children:t,disableParentContext:n}){let r;return r=n?"function"==typeof e?e({}):e||o:i(e),s.createElement(a.Provider,{value:r},t)}}}]);