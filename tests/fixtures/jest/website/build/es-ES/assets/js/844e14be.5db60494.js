"use strict";(self.webpackChunkjest_website=self.webpackChunkjest_website||[]).push([[7049],{3843:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>d,default:()=>m,frontMatter:()=>l,metadata:()=>h,toc:()=>p});var s=t(4246),a=t(1670),o=t(8447),r=t(2599),i=t(1353),c=t(6294);const l={id:"expect",title:"Expect"},d=void 0,h={unversionedId:"expect",id:"version-29.4/expect",title:"Expect",description:"Cuando est\xe1s escribiendo tests, a menudo necesitas comprobar que los valores cumplen ciertas condiciones. expect te da acceso a un n\xfamero de marcadores que te permiten validar diferentes cosas.",source:"@site/i18n/es-ES/docusaurus-plugin-content-docs/version-29.4/ExpectAPI.md",sourceDirName:".",slug:"/expect",permalink:"/es-ES/docs/29.4/expect",draft:!1,unlisted:!1,editUrl:"https://crowdin.com/project/jest-v2/es-ES",tags:[],version:"29.4",frontMatter:{id:"expect",title:"Expect"},sidebar:"api",previous:{title:"Globales",permalink:"/es-ES/docs/29.4/api"},next:{title:"Funciones Mock",permalink:"/es-ES/docs/29.4/mock-function-api"}},u={},p=[{value:"Referencia",id:"referencia",level:2},{value:"Expect",id:"expect",level:2},{value:"<code>expect(value)</code>",id:"expectvalue",level:3},{value:"Modifiers",id:"modifiers",level:2},{value:"<code>.not</code>",id:"not",level:3},{value:"<code>.resolves</code>",id:"resolves",level:3},{value:"<code>.rejects</code>",id:"rejects",level:3},{value:"Matchers",id:"matchers",level:2},{value:"<code>.toBe(value)</code>",id:"tobevalue",level:3},{value:"<code>.toHaveBeenCalled()</code>",id:"tohavebeencalled",level:3},{value:"<code>.toHaveBeenCalledTimes(number)</code>",id:"tohavebeencalledtimesnumber",level:3},{value:"<code>.toHaveBeenCalledWith(arg1, arg2, ...)</code>",id:"tohavebeencalledwitharg1-arg2-",level:3},{value:"<code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code>",id:"tohavebeenlastcalledwitharg1-arg2-",level:3},{value:"<code>.toHaveBeenNthCalledWith(nthCall, arg1, arg2, ....)</code>",id:"tohavebeennthcalledwithnthcall-arg1-arg2-",level:3},{value:"<code>.toHaveReturned()</code>",id:"tohavereturned",level:3},{value:"<code>.toHaveReturnedTimes(number)</code>",id:"tohavereturnedtimesnumber",level:3},{value:"<code>.toHaveReturnedWith(value)</code>",id:"tohavereturnedwithvalue",level:3},{value:"<code>.toHaveLastReturnedWith(value)</code>",id:"tohavelastreturnedwithvalue",level:3},{value:"<code>.toHaveNthReturnedWith(nthCall, value)</code>",id:"tohaventhreturnedwithnthcall-value",level:3},{value:"<code>.toHaveLength(number)</code>",id:"tohavelengthnumber",level:3},{value:"<code>.toHaveProperty(pathLlave, valor?)</code>",id:"tohavepropertypathllave-valor",level:3},{value:"<code>.toBeCloseTo(n\xfamero, n\xfameroDigitos?)</code>",id:"tobecloseton\xfamero-n\xfamerodigitos",level:3},{value:"<code>.toBeDefined()</code>",id:"tobedefined",level:3},{value:"<code>.toBeFalsy()</code>",id:"tobefalsy",level:3},{value:"<code>.toBeGreaterThan(number | bigint)</code>",id:"tobegreaterthannumber--bigint",level:3},{value:"<code>.toBeGreaterThanOrEqual(number | bigint)</code>",id:"tobegreaterthanorequalnumber--bigint",level:3},{value:"<code>.toBeLessThan(number | bigint)</code>",id:"tobelessthannumber--bigint",level:3},{value:"<code>.toBeLessThanOrEqual(number | bigint)</code>",id:"tobelessthanorequalnumber--bigint",level:3},{value:"<code>.toBeInstanceOf(Class)</code>",id:"tobeinstanceofclass",level:3},{value:"<code>.toBeNull()</code>",id:"tobenull",level:3},{value:"<code>.toBeTruthy()</code>",id:"tobetruthy",level:3},{value:"<code>.toBeUndefined()</code>",id:"tobeundefined",level:3},{value:"<code>.toBeNaN()</code>",id:"tobenan",level:3},{value:"<code>.toContain(item)</code>",id:"tocontainitem",level:3},{value:"<code>.toContainEqual(item)</code>",id:"tocontainequalitem",level:3},{value:"<code>.toEqual(value)</code>",id:"toequalvalue",level:3},{value:"<code>.toMatch(regexp | string)</code>",id:"tomatchregexp--string",level:3},{value:"<code>.toMatchObject(object)</code>",id:"tomatchobjectobject",level:3},{value:"<code>.toMatchSnapshot(propertyMatchers?, hint?)</code>",id:"tomatchsnapshotpropertymatchers-hint",level:3},{value:"<code>.toMatchInlineSnapshot(propertyMatchers?, inlineSnapshot)</code>",id:"tomatchinlinesnapshotpropertymatchers-inlinesnapshot",level:3},{value:"<code>.toStrictEqual(value)</code>",id:"tostrictequalvalue",level:3},{value:"<code>.toThrow(error?)</code>",id:"tothrowerror",level:3},{value:"<code>.toThrowErrorMatchingSnapshot(hint?)</code>",id:"tothrowerrormatchingsnapshothint",level:3},{value:"<code>.toThrowErrorMatchingInlineSnapshot(inlineSnapshot)</code>",id:"tothrowerrormatchinginlinesnapshotinlinesnapshot",level:3},{value:"Asymmetric Matchers",id:"asymmetric-matchers",level:2},{value:"<code>expect.anything()</code>",id:"expectanything",level:3},{value:"<code>expect.any(constructor)</code>",id:"expectanyconstructor",level:3},{value:"<code>expect.arrayContaining(array)</code>",id:"expectarraycontainingarray",level:3},{value:"<code>expect.not.arrayContaining(array)</code>",id:"expectnotarraycontainingarray",level:3},{value:"<code>expect.closeTo(number, numDigits?)</code>",id:"expectclosetonumber-numdigits",level:3},{value:"<code>expect.objectContaining(object)</code>",id:"expectobjectcontainingobject",level:3},{value:"<code>expect.not.objectContaining(object)</code>",id:"expectnotobjectcontainingobject",level:3},{value:"<code>expect.stringContaining(string)</code>",id:"expectstringcontainingstring",level:3},{value:"<code>expect.not.stringContaining(string)</code>",id:"expectnotstringcontainingstring",level:3},{value:"<code>expect.stringMatching(string | regexp)</code>",id:"expectstringmatchingstring--regexp",level:3},{value:"<code>expect.not.stringMatching(string | regexp)</code>",id:"expectnotstringmatchingstring--regexp",level:3},{value:"Assertion Count",id:"assertion-count",level:2},{value:"<code>expect.assertions(number)</code>",id:"expectassertionsnumber",level:3},{value:"<code>expect.hasAssertions()</code>",id:"expecthasassertions",level:3},{value:"Extend Utilities",id:"extend-utilities",level:2},{value:"<code>expect.addEqualityTesters(testers)</code>",id:"expectaddequalitytesterstesters",level:3},{value:"Custom equality testers API",id:"custom-equality-testers-api",level:4},{value:"<code>this.equals(a, b, customTesters?)</code>",id:"thisequalsa-b-customtesters",level:4},{value:"Matchers vs Testers",id:"matchers-vs-testers",level:4},{value:"Recursive custom equality testers",id:"recursive-custom-equality-testers",level:4},{value:"<code>expect.addSnapshotSerializer(serializer)</code>",id:"expectaddsnapshotserializerserializer",level:3},{value:"<code>expect.extend(matchers)</code>",id:"expectextendmatchers",level:3},{value:"Async Matchers",id:"async-matchers",level:4},{value:"Custom Matchers API",id:"custom-matchers-api",level:4},{value:"<code>this.isNot</code>",id:"thisisnot",level:4},{value:"<code>this.promise</code>",id:"thispromise",level:4},{value:"<code>this.equals(a, b, customTesters?)</code>",id:"thisequalsa-b-customtesters-1",level:4},{value:"<code>this.expand</code>",id:"thisexpand",level:4},{value:"<code>this.utils</code>",id:"thisutils",level:4},{value:"<code>this.customTesters</code>",id:"thiscustomtesters",level:4},{value:"Custom snapshot matchers",id:"custom-snapshot-matchers",level:4},{value:"async",id:"async",level:4},{value:"Bail out",id:"bail-out",level:4}];function x(e){const n=Object.assign({p:"p",code:"code",admonition:"admonition",a:"a",h2:"h2",hr:"hr",h3:"h3",pre:"pre",strong:"strong",ul:"ul",li:"li",em:"em",h4:"h4"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Cuando est\xe1s escribiendo tests, a menudo necesitas comprobar que los valores cumplen ciertas condiciones. ",(0,s.jsx)(n.code,{children:"expect"})," te da acceso a un n\xfamero de marcadores que te permiten validar diferentes cosas."]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["For additional Jest matchers maintained by the Jest Community check out ",(0,s.jsx)(n.a,{href:"https://github.com/jest-community/jest-extended",children:(0,s.jsx)(n.code,{children:"jest-extended"})}),"."]})}),"\n","\n",(0,s.jsx)(i.ZP,{}),"\n",(0,s.jsx)(n.h2,{id:"referencia",children:"Referencia"}),"\n","\n","\n",(0,s.jsx)(c.Z,{toc:p.slice(1)}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"expect",children:"Expect"}),"\n",(0,s.jsx)(n.h3,{id:"expectvalue",children:(0,s.jsx)(n.code,{children:"expect(value)"})}),"\n",(0,s.jsxs)(n.p,{children:["La funci\xf3n ",(0,s.jsx)(n.code,{children:"expect"})," se utiliza cada vez que desea testear un valor. Rara vez se utiliza ",(0,s.jsx)(n.code,{children:"expect"})," por s\xed mismo. En su lugar, utilizar\xe1s ",(0,s.jsx)(n.code,{children:"expect"}),' junto a una funci\xf3n de "comparaci\xf3n" para afirmar algo sobre un valor.']}),"\n",(0,s.jsxs)(n.p,{children:["Es m\xe1s f\xe1cil entenderlo con este ejemplo. Digamos que tenemos un m\xe9todo ",(0,s.jsx)(n.code,{children:"mejorSabor()"})," que se supone que devuelve el texto ",(0,s.jsx)(n.code,{children:"'grapefruit'"}),". As\xed es c\xf3mo ser\xeda el test:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('el mejor sabor es de melocot\xf3n', () => {\n  expect(mejorSabor()).toBe('melocot\xf3n');\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["En este caso, ",(0,s.jsx)(n.code,{children:"toBe"})," es la funci\xf3n de comparaci\xf3n. Hay una gran cantidad de funciones matcher diferentes, documentadas a continuaci\xf3n, para ayudarte a probar cosas diferentes."]}),"\n",(0,s.jsxs)(n.p,{children:["El argumento ",(0,s.jsx)(n.code,{children:"expect"})," debe ser el valor que produce tu c\xf3digo, y cualquier argumento de comparaci\xf3n debe ser el valor correcto. Si los mezclas, tus test problablemente seguiran funcionando, pero los mensajes de error seran confusos."]}),"\n",(0,s.jsx)(n.h2,{id:"modifiers",children:"Modifiers"}),"\n",(0,s.jsx)(n.h3,{id:"not",children:(0,s.jsx)(n.code,{children:".not"})}),"\n",(0,s.jsxs)(n.p,{children:["Si sabes c\xf3mo testear algo, ",(0,s.jsx)(n.code,{children:".no"})," te permite comprobar su opuesto. Por ejemplo, este c\xf3digo testea que el mejor sabor de La Croix no es coco:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import serializer from 'my-serializer-module';\nexpect.addSnapshotSerializer(serializer);\n\n// afecta a las afirmaciones expect(value).toMatchSnapshot() en el archivo de test\n"})}),"\n",(0,s.jsx)(n.h3,{id:"resolves",children:(0,s.jsx)(n.code,{children:".resolves"})}),"\n",(0,s.jsxs)(n.p,{children:["Utiliza ",(0,s.jsx)(n.code,{children:"resolves"})," para desenvolver el valor de una promesa cumplida, para que as\xed cualquier otro marcados pueda ser encadenado. Si la promesa se rechaza la afirmaci\xf3n falla."]}),"\n",(0,s.jsxs)(n.p,{children:["Por ejemplo, este c\xf3digo testea que la promesa resuelve y que el valor resultando es ",(0,s.jsx)(n.code,{children:"'limon'"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('el mejor sabor no es coco', () => {\n  expect(mejorSaborLaCroix()).not.toBe('coco');\n});\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["Since you are still testing promises, the test is still asynchronous. Hence, you will need to ",(0,s.jsx)(n.a,{href:"/es-ES/docs/29.4/asynchronous#promises",children:"tell Jest to wait"})," by returning the unwrapped assertion."]}),(0,s.jsxs)(n.p,{children:["Alternativamente, se puede usar ",(0,s.jsx)(n.code,{children:"async/await"})," en combinaci\xf3n con ",(0,s.jsx)(n.code,{children:".resolves"}),":"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('resuelve a limon', () => {\n  // Es esencial que se agregue un statement de return\n  return expect(Promise.resolve('limon')).resolves.toBe('limon');\n});\n"})})]}),"\n",(0,s.jsx)(n.h3,{id:"rejects",children:(0,s.jsx)(n.code,{children:".rejects"})}),"\n",(0,s.jsxs)(n.p,{children:["Usa ",(0,s.jsx)(n.code,{children:".rejects"})," para desenvolver el valor de una promesa cumplida, para que as\xed cualquier otro marcados pueda ser encadenado. Si la promesa es rechazada la afirmaci\xf3n falla."]}),"\n",(0,s.jsxs)(n.p,{children:["Por ejemplo, este c\xf3digo prueba que la promesa rechaza con la raz\xf3n ",(0,s.jsx)(n.code,{children:"'octopus'"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('rejects to octopus', () => {\n  // make sure to add a return statement\n  return expect(Promise.reject(new Error('octopus'))).rejects.toThrow(\n    'octopus',\n  );\n});\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["Since you are still testing promises, the test is still asynchronous. Hence, you will need to ",(0,s.jsx)(n.a,{href:"/es-ES/docs/29.4/asynchronous#promises",children:"tell Jest to wait"})," by returning the unwrapped assertion."]}),(0,s.jsxs)(n.p,{children:["Alternativamente, puede utilizar ",(0,s.jsx)(n.code,{children:"async/await"})," combinado con ",(0,s.jsx)(n.code,{children:".rejects"}),"."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('rejects to octopus', async () => {\n  await expect(Promise.reject(new Error('octopus'))).rejects.toThrow('octopus');\n});\n"})})]}),"\n",(0,s.jsx)(n.h2,{id:"matchers",children:"Matchers"}),"\n",(0,s.jsx)(n.h3,{id:"tobevalue",children:(0,s.jsx)(n.code,{children:".toBe(value)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toBe"})," to compare primitive values or to check referential identity of object instances. It calls ",(0,s.jsx)(n.code,{children:"Object.is"})," to compare values, which is even better for testing than ",(0,s.jsx)(n.code,{children:"==="})," strict equality operator."]}),"\n",(0,s.jsxs)(n.p,{children:["Por ejemplo, el c\xf3digo a continuaci\xf3n valida algunas propiedades del objeto ",(0,s.jsx)(n.code,{children:"lata"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const lata = {\n  nombre: 'pomelo',\n  onzas : 12,\n};\n\ndescribe('la lata', () => {\n  test('tiene 12 onzas', () => {\n    expect(lata.onzas).toBe(12);\n  });\n\n  test('tiene un nombre sofisticado', () => {\n    expect(lata.nombre).toBe('pomelo');\n  });\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Don't use ",(0,s.jsx)(n.code,{children:".toBe"})," with floating-point numbers. Por ejemplo, debido al redondeo, en JavaScript ",(0,s.jsx)(n.code,{children:"0,2 + 0,1"})," no es estrictamente igual a ",(0,s.jsx)(n.code,{children:"0,3"}),". Si tienes n\xfameros de punto flotante, prueba ",(0,s.jsx)(n.code,{children:".toBeCloseTo"})," en su lugar."]}),"\n",(0,s.jsxs)(n.p,{children:["Although the ",(0,s.jsx)(n.code,{children:".toBe"})," matcher ",(0,s.jsx)(n.strong,{children:"checks"})," referential identity, it ",(0,s.jsx)(n.strong,{children:"reports"})," a deep comparison of values if the assertion fails. If differences between properties do not help you to understand why a test fails, especially if the report is large, then you might move the comparison into the ",(0,s.jsx)(n.code,{children:"expect"})," function. For example, to assert whether or not elements are the same instance:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["rewrite ",(0,s.jsx)(n.code,{children:"expect(received).toBe(expected)"})," as ",(0,s.jsx)(n.code,{children:"expect(Object.is(received, expected)).toBe(true)"})]}),"\n",(0,s.jsxs)(n.li,{children:["rewrite ",(0,s.jsx)(n.code,{children:"expect(received).not.toBe(expected)"})," as ",(0,s.jsx)(n.code,{children:"expect(Object.is(received, expected)).toBe(false)"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"tohavebeencalled",children:(0,s.jsx)(n.code,{children:".toHaveBeenCalled()"})}),"\n",(0,s.jsxs)(n.p,{children:["Tambi\xe9n bajo el alias: ",(0,s.jsx)(n.code,{children:".toBeCalled()"})]}),"\n",(0,s.jsxs)(n.p,{children:["Usa ",(0,s.jsx)(n.code,{children:".toHaveBeenCalledWith"})," para asegurar que una funci\xf3n mock haya sido llamada con argumentos espec\xedficos. The arguments are checked with the same algorithm that ",(0,s.jsx)(n.code,{children:".toEqual"})," uses."]}),"\n",(0,s.jsxs)(n.p,{children:["Por ejemplo, digamos que tienes una funci\xf3n ",(0,s.jsx)(n.code,{children:"beberCada(beber, Array<sabor>)"})," que toma una funci\xf3n ",(0,s.jsx)(n.code,{children:"beber"})," y la aplica a un arreglo de bebidas. Puede que quieras comprobar que la funci\xf3n beber se llam\xf3 un numero exacto de veces. Puedes hacerlo con esta serie de tests:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function drinkAll(callback, flavour) {\n  if (flavour !== 'octopus') {\n    callback(flavour);\n  }\n}\n\ndescribe('drinkAll', () => {\n  test('drinks something lemon-flavoured', () => {\n    const drink = jest.fn();\n    drinkAll(drink, 'lemon');\n    expect(drink).toHaveBeenCalled();\n  });\n\n  test('does not drink something octopus-flavoured', () => {\n    const drink = jest.fn();\n    drinkAll(drink, 'octopus');\n    expect(drink).not.toHaveBeenCalled();\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavebeencalledtimesnumber",children:(0,s.jsx)(n.code,{children:".toHaveBeenCalledTimes(number)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".toBeCalledTimes(number)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Usa ",(0,s.jsx)(n.code,{children:".toHaveBeenCalledTimes"}),' para asegurar que una funci\xf3n "mock" se llamo un n\xfamero de veces exacto.']}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's say you have a ",(0,s.jsx)(n.code,{children:"drinkAll(drink, flavour)"})," function that takes a ",(0,s.jsx)(n.code,{children:"drink"})," function and applies it to all available beverages. Puede que quieras comprobar que la funci\xf3n beber se llam\xf3 un numero exacto de veces. Puedes hacerlo con esta serie de tests:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('aplicarATodosLosSabores deja el mango para el final', () => {\n  const bebida = jest.fn();\n  aplicarATodosLosSabores(bebida);\n  expect(bebida).toHaveBeenLastCalledWith('mango');\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavebeencalledwitharg1-arg2-",children:(0,s.jsx)(n.code,{children:".toHaveBeenCalledWith(arg1, arg2, ...)"})}),"\n",(0,s.jsxs)(n.p,{children:["Tambi\xe9n bajo el alias: ",(0,s.jsx)(n.code,{children:".toBeCalledWith()"})]}),"\n",(0,s.jsxs)(n.p,{children:["Usa ",(0,s.jsx)(n.code,{children:".toHaveBeenCalledWith"})," para asegurar que una funci\xf3n mock haya sido llamada con argumentos espec\xedficos. The arguments are checked with the same algorithm that ",(0,s.jsx)(n.code,{children:".toEqual"})," uses."]}),"\n",(0,s.jsxs)(n.p,{children:["Por ejemplo, digamos que tienes una bebida con una funci\xf3n ",(0,s.jsx)(n.code,{children:"registrar"}),", y ",(0,s.jsx)(n.code,{children:"aplicarATodo(f)"})," que aplica la funci\xf3n ",(0,s.jsx)(n.code,{children:"f"})," a todas las bebidas registradas. Para asegurarte que funciona, puedes escribir:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('beberCada bebe cada bebida', () => {\n  const beber = jest.fn();\n  beberCada(beber, ['limon', 'pulpo']);\n  expect(beber).toHaveBeenCalledTimes(2);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavebeenlastcalledwitharg1-arg2-",children:(0,s.jsx)(n.code,{children:".toHaveBeenLastCalledWith(arg1, arg2, ...)"})}),"\n",(0,s.jsxs)(n.p,{children:["Tambi\xe9n bajo el alias: ",(0,s.jsx)(n.code,{children:".lastCalledWith(arg1, arg2, ...)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Si tienes una funci\xf3n mock, puedes usar ",(0,s.jsx)(n.code,{children:".toHaveBeenLastCalledWith"})," para ver los argumentos con los que fue llamada la ultima vez. Por ejemplo digamos que tienes una funci\xf3n ",(0,s.jsx)(n.code,{children:"aplicarATodosLosSabores(f)"})," que aplica la funci\xf3n ",(0,s.jsx)(n.code,{children:"f"})," a diversos sabores, y quieres asegurarte que la ultima vez que se llama a esta funci\xf3n el \xfaltimo sabor al que se le aplica la funci\xf3n es ",(0,s.jsx)(n.code,{children:"'mango'"}),". Puedes escribir:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('registro aplicado correctamente a La Croix naranja', () => {\n  const bebida = new LaCroix('naranja');\n  registrar(bebida);\n  const f = jest.fn();\n  aplicarATodo(f);\n  expect(f).toHaveBeenCalledWith(bebida);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavebeennthcalledwithnthcall-arg1-arg2-",children:(0,s.jsx)(n.code,{children:".toHaveBeenNthCalledWith(nthCall, arg1, arg2, ....)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".nthCalledWith(nthCall, arg1, arg2, ...)"})]}),"\n",(0,s.jsxs)(n.p,{children:["If you have a mock function, you can use ",(0,s.jsx)(n.code,{children:".toHaveBeenNthCalledWith"})," to test what arguments it was nth called with. For example, let's say you have a ",(0,s.jsx)(n.code,{children:"drinkEach(drink, Array<flavor>)"})," function that applies ",(0,s.jsx)(n.code,{children:"f"})," to a bunch of flavors, and you want to ensure that when you call it, the first flavor it operates on is ",(0,s.jsx)(n.code,{children:"'lemon'"})," and the second one is ",(0,s.jsx)(n.code,{children:"'octopus'"}),". Puedes escribir:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drinkEach drinks each drink', () => {\n  const drink = jest.fn();\n  drinkEach(drink, ['lemon', 'octopus']);\n  expect(drink).toHaveBeenNthCalledWith(1, 'lemon');\n  expect(drink).toHaveBeenNthCalledWith(2, 'octopus');\n});\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"The nth argument must be positive integer starting from 1."})}),"\n",(0,s.jsx)(n.h3,{id:"tohavereturned",children:(0,s.jsx)(n.code,{children:".toHaveReturned()"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".toReturn()"})]}),"\n",(0,s.jsxs)(n.p,{children:["If you have a mock function, you can use ",(0,s.jsx)(n.code,{children:".toHaveReturned"})," to test that the mock function successfully returned (i.e., did not throw an error) at least one time. For example, let's say you have a mock ",(0,s.jsx)(n.code,{children:"drink"})," that returns ",(0,s.jsx)(n.code,{children:"true"}),". Puedes escribir:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drinks returns', () => {\n  const drink = jest.fn(() => true);\n\n  drink();\n\n  expect(drink).toHaveReturned();\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavereturnedtimesnumber",children:(0,s.jsx)(n.code,{children:".toHaveReturnedTimes(number)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".toReturnTimes(number)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toHaveReturnedTimes"})," to ensure that a mock function returned successfully (i.e., did not throw an error) an exact number of times. Any calls to the mock function that throw an error are not counted toward the number of times the function returned."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's say you have a mock ",(0,s.jsx)(n.code,{children:"drink"})," that returns ",(0,s.jsx)(n.code,{children:"true"}),". Puedes escribir:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drink returns twice', () => {\n  const drink = jest.fn(() => true);\n\n  drink();\n  drink();\n\n  expect(drink).toHaveReturnedTimes(2);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavereturnedwithvalue",children:(0,s.jsx)(n.code,{children:".toHaveReturnedWith(value)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".toReturnWith(value)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toHaveReturnedWith"})," to ensure that a mock function returned a specific value."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's say you have a mock ",(0,s.jsx)(n.code,{children:"drink"})," that returns the name of the beverage that was consumed. Puedes escribir:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drink returns La Croix', () => {\n  const beverage = {name: 'La Croix'};\n  const drink = jest.fn(beverage => beverage.name);\n\n  drink(beverage);\n\n  expect(drink).toHaveReturnedWith('La Croix');\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavelastreturnedwithvalue",children:(0,s.jsx)(n.code,{children:".toHaveLastReturnedWith(value)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".lastReturnedWith(value)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toHaveLastReturnedWith"})," to test the specific value that a mock function last returned. If the last call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's say you have a mock ",(0,s.jsx)(n.code,{children:"drink"})," that returns the name of the beverage that was consumed. Puedes escribir:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drink returns La Croix (Orange) last', () => {\n  const beverage1 = {name: 'La Croix (Lemon)'};\n  const beverage2 = {name: 'La Croix (Orange)'};\n  const drink = jest.fn(beverage => beverage.name);\n\n  drink(beverage1);\n  drink(beverage2);\n\n  expect(drink).toHaveLastReturnedWith('La Croix (Orange)');\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohaventhreturnedwithnthcall-value",children:(0,s.jsx)(n.code,{children:".toHaveNthReturnedWith(nthCall, value)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".nthReturnedWith(nthCall, value)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toHaveNthReturnedWith"})," to test the specific value that a mock function returned for the nth call. If the nth call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's say you have a mock ",(0,s.jsx)(n.code,{children:"drink"})," that returns the name of the beverage that was consumed. Puedes escribir:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drink returns expected nth calls', () => {\n  const beverage1 = {name: 'La Croix (Lemon)'};\n  const beverage2 = {name: 'La Croix (Orange)'};\n  const drink = jest.fn(beverage => beverage.name);\n\n  drink(beverage1);\n  drink(beverage2);\n\n  expect(drink).toHaveNthReturnedWith(1, 'La Croix (Lemon)');\n  expect(drink).toHaveNthReturnedWith(2, 'La Croix (Orange)');\n});\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"The nth argument must be positive integer starting from 1."})}),"\n",(0,s.jsx)(n.h3,{id:"tohavelengthnumber",children:(0,s.jsx)(n.code,{children:".toHaveLength(number)"})}),"\n",(0,s.jsxs)(n.p,{children:["Utilice ",(0,s.jsx)(n.code,{children:".toHaveLength"})," para verificar que un objeto tenga longitud de ",(0,s.jsx)(n.code,{children:".length"})," y tenga cierto valor num\xe9rico."]}),"\n",(0,s.jsx)(n.p,{children:"Es especialmente \xfatil para verificar el tama\xf1o de cadenas o arreglos."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"expect([1, 2, 3]).toHaveLength(3);\nexpect('abc').toHaveLength(3);\nexpect('').not.toHaveLength(5);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavepropertypathllave-valor",children:(0,s.jsx)(n.code,{children:".toHaveProperty(pathLlave, valor?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Utilice ",(0,s.jsx)(n.code,{children:".toHaveProperty"})," para verificar si la propiedad en la referencia de ",(0,s.jsx)(n.code,{children:"pathLlave"})," existe para un objeto dado. For checking deeply nested properties in an object you may use ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors",children:"dot notation"})," or an array containing the keyPath for deep references."]}),"\n",(0,s.jsxs)(n.p,{children:["You can provide an optional ",(0,s.jsx)(n.code,{children:"value"})," argument to compare the received property value (recursively for all properties of object instances, also known as deep equality, like the ",(0,s.jsx)(n.code,{children:"toEqual"})," matcher)."]}),"\n",(0,s.jsxs)(n.p,{children:["El siguiente ejemplo contiene un objeto ",(0,s.jsx)(n.code,{children:"casaEnVenta"})," con propiedades anidadas. We are using ",(0,s.jsx)(n.code,{children:"toHaveProperty"})," to check for the existence and values of various properties in the object."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Object containing house features to be tested\nconst houseForSale = {\n  bath: true,\n  bedrooms: 4,\n  kitchen: {\n    amenities: ['oven', 'stove', 'washer'],\n    area: 20,\n    wallColor: 'white',\n    'nice.oven': true,\n  },\n  livingroom: {\n    amenities: [\n      {\n        couch: [\n          ['large', {dimensions: [20, 20]}],\n          ['small', {dimensions: [10, 10]}],\n        ],\n      },\n    ],\n  },\n  'ceiling.height': 2,\n};\n\ntest('this house has my desired features', () => {\n  // Example Referencing\n  expect(houseForSale).toHaveProperty('bath');\n  expect(houseForSale).toHaveProperty('bedrooms', 4);\n\n  expect(houseForSale).not.toHaveProperty('pool');\n\n  // Deep referencing using dot notation\n  expect(houseForSale).toHaveProperty('kitchen.area', 20);\n  expect(houseForSale).toHaveProperty('kitchen.amenities', [\n    'oven',\n    'stove',\n    'washer',\n  ]);\n\n  expect(houseForSale).not.toHaveProperty('kitchen.open');\n\n  // Deep referencing using an array containing the keyPath\n  expect(houseForSale).toHaveProperty(['kitchen', 'area'], 20);\n  expect(houseForSale).toHaveProperty(\n    ['kitchen', 'amenities'],\n    ['oven', 'stove', 'washer'],\n  );\n  expect(houseForSale).toHaveProperty(['kitchen', 'amenities', 0], 'oven');\n  expect(houseForSale).toHaveProperty(\n    'livingroom.amenities[0].couch[0][1].dimensions[0]',\n    20,\n  );\n  expect(houseForSale).toHaveProperty(['kitchen', 'nice.oven']);\n  expect(houseForSale).not.toHaveProperty(['kitchen', 'open']);\n\n  // Referencing keys with dot in the key itself\n  expect(houseForSale).toHaveProperty(['ceiling.height'], 'tall');\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobecloseton\xfamero-n\xfamerodigitos",children:(0,s.jsx)(n.code,{children:".toBeCloseTo(n\xfamero, n\xfameroDigitos?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"toBeCloseTo"})," to compare floating point numbers for approximate equality."]}),"\n",(0,s.jsxs)(n.p,{children:["The optional ",(0,s.jsx)(n.code,{children:"numDigits"})," argument limits the number of digits to check ",(0,s.jsx)(n.strong,{children:"after"})," the decimal point. For the default value ",(0,s.jsx)(n.code,{children:"2"}),", the test criterion is ",(0,s.jsx)(n.code,{children:"Math.abs(expected - received) < 0.005"})," (that is, ",(0,s.jsx)(n.code,{children:"10 ** -2 / 2"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"Intuitive equality comparisons often fail, because arithmetic on decimal (base 10) values often have rounding errors in limited precision binary (base 2) representation. For example, this test fails:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('adding works sanely with decimals', () => {\n  expect(0.2 + 0.1).toBe(0.3); // Fails!\n});\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It fails because in JavaScript, ",(0,s.jsx)(n.code,{children:"0.2 + 0.1"})," is actually ",(0,s.jsx)(n.code,{children:"0.30000000000000004"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"For example, this test passes with a precision of 5 digits:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('adding works sanely with decimals', () => {\n  expect(0.2 + 0.1).toBeCloseTo(0.3, 5);\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Because floating point errors are the problem that ",(0,s.jsx)(n.code,{children:"toBeCloseTo"})," solves, it does not support big integer values."]}),"\n",(0,s.jsx)(n.h3,{id:"tobedefined",children:(0,s.jsx)(n.code,{children:".toBeDefined()"})}),"\n",(0,s.jsxs)(n.p,{children:["Usa ",(0,s.jsx)(n.code,{children:".toBeDefined"})," para verificar que una variable no sea undefined. For example, if you want to check that a function ",(0,s.jsx)(n.code,{children:"fetchNewFlavorIdea()"})," returns ",(0,s.jsx)(n.em,{children:"something"}),", you can write:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('la mejor bebida con sabor a pulpo es undefined', () => {\n  expect(mejorBebidaPorSabor('pulpo')).toBeUndefined();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Puedes escribir ",(0,s.jsx)(n.code,{children:"expect(conseguirNuevaIdeaSabor()).not.toBe(undefined)"}),", pero es buena practica omitir el uso de ",(0,s.jsx)(n.code,{children:"undefined"})," directamente en el c\xf3digo."]}),"\n",(0,s.jsx)(n.h3,{id:"tobefalsy",children:(0,s.jsx)(n.code,{children:".toBeFalsy()"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toBeFalsy"})," when you don't care what a value is and you want to ensure a value is false in a boolean context. For example, let's say you have some application code that looks like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('hay una nueva idea de sabor', () => {\n  expect(conseguirNuevaIdeaSabor()).toBeDefined();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Puede que no te importe el valor que ",(0,s.jsx)(n.code,{children:"conseguirErrores"})," regrese, espec\xedficamente - podr\xeda regresar ",(0,s.jsx)(n.code,{children:"false"}),", ",(0,s.jsx)(n.code,{children:"null"}),", o ",(0,s.jsx)(n.code,{children:"0"}),", y el c\xf3digo funcionar\xeda correctamente. Si quieres probar que no hay errores despu\xe9s de tomar algo de La Croix, podr\xedas escribir:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"beberPocoLaCroix();\nif (!conseguirErrores()) {\n  beberMasLaCroix();\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:['En JavaScript, hay seis valores falsos en contexto booleano, o "falsy": ',(0,s.jsx)(n.code,{children:"false"}),", ",(0,s.jsx)(n.code,{children:"0"}),", ",(0,s.jsx)(n.code,{children:"''"}),", ",(0,s.jsx)(n.code,{children:"null"}),", ",(0,s.jsx)(n.code,{children:"undefined"}),", y ",(0,s.jsx)(n.code,{children:"NaN"}),'. Cualquier otro valor es verdadero en contexto booleano, o "truthy".']}),"\n",(0,s.jsx)(n.h3,{id:"tobegreaterthannumber--bigint",children:(0,s.jsx)(n.code,{children:".toBeGreaterThan(number | bigint)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"toBeGreaterThan"})," to compare ",(0,s.jsx)(n.code,{children:"received > expected"})," for number or big integer values. For example, test that ",(0,s.jsx)(n.code,{children:"ouncesPerCan()"})," returns a value of more than 10 ounces:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('beber LaCroix no provoca errores', () => {\n  beberPocoLaCroix();\n  expect(conseguirErrores()).toBeFalsy();\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobegreaterthanorequalnumber--bigint",children:(0,s.jsx)(n.code,{children:".toBeGreaterThanOrEqual(number | bigint)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"toBeGreaterThanOrEqual"})," to compare ",(0,s.jsx)(n.code,{children:"received >= expected"})," for number or big integer values. For example, test that ",(0,s.jsx)(n.code,{children:"ouncesPerCan()"})," returns a value of at least 12 ounces:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('onzas por lata es mayor a 10', () => {\n  expect(onzasPorLata()).toBeGreaterThan(10);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobelessthannumber--bigint",children:(0,s.jsx)(n.code,{children:".toBeLessThan(number | bigint)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"toBeLessThan"})," to compare ",(0,s.jsx)(n.code,{children:"received < expected"})," for number or big integer values. For example, test that ",(0,s.jsx)(n.code,{children:"ouncesPerCan()"})," returns a value of less than 20 ounces:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('onzas por lata es por lo menos 12', () => {\n  expect(onzasPorLata()).toBeGreaterThanOrEqual(12);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobelessthanorequalnumber--bigint",children:(0,s.jsx)(n.code,{children:".toBeLessThanOrEqual(number | bigint)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"toBeLessThanOrEqual"})," to compare ",(0,s.jsx)(n.code,{children:"received <= expected"})," for number or big integer values. For example, test that ",(0,s.jsx)(n.code,{children:"ouncesPerCan()"})," returns a value of at most 12 ounces:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('onzas por lata es menor a 20', () => {\n  expect(onzasPorLata()).toBeLessThan(20);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobeinstanceofclass",children:(0,s.jsx)(n.code,{children:".toBeInstanceOf(Class)"})}),"\n",(0,s.jsxs)(n.p,{children:["Utiliza ",(0,s.jsx)(n.code,{children:".toBeInstanceOf(Class)"})," para verificar que un objeto es instancia de cierta clase. Esta comparaci\xf3n se realiza de manera interna ocupando ",(0,s.jsx)(n.code,{children:"instanceof"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('onzas por lata es a lo mucho 12', () => {\n  expect(onzasPorLata()).toBeLessThanOrEqual(12);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobenull",children:(0,s.jsx)(n.code,{children:".toBeNull()"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:".toBeNull()"})," es id\xe9ntico a ",(0,s.jsx)(n.code,{children:".toBe(null)"})," pero con mensajes de error m\xe1s claros. Por tanto, es preferible usar ",(0,s.jsx)(n.code,{children:".toBeNull()"})," para verificar si algo es nulo."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class A {}\n\nexpect(new A()).toBeInstanceOf(A);\nexpect(() => {}).toBeInstanceOf(Function);\nexpect(new A()).toBeInstanceOf(Function); // avienta error\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobetruthy",children:(0,s.jsx)(n.code,{children:".toBeTruthy()"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toBeTruthy"})," when you don't care what a value is and you want to ensure a value is true in a boolean context. For example, let's say you have some application code that looks like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function bloop() {\n  return null;\n}\n\ntest('bloop regresa null', () => {\n  expect(bloop()).toBeNull();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Puede que no te importe el valor que ",(0,s.jsx)(n.code,{children:"infoSed"})," regrese, espec\xedficamente - podr\xeda regresar ",(0,s.jsx)(n.code,{children:"true"}),"o un objeto complejo, y el c\xf3digo funcionar\xeda correctamente. So if you want to test that ",(0,s.jsx)(n.code,{children:"thirstInfo"})," will be truthy after drinking some La Croix, you could write:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"beberPocoLaCroix();\nif (infoSed()) {\n  beberMasLaCroix();\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:['En JavaScript, hay seis valores falsos en contexto booleano, o "falsy": ',(0,s.jsx)(n.code,{children:"false"}),", ",(0,s.jsx)(n.code,{children:"0"}),", ",(0,s.jsx)(n.code,{children:"''"}),", ",(0,s.jsx)(n.code,{children:"null"}),", ",(0,s.jsx)(n.code,{children:"undefined"}),", y ",(0,s.jsx)(n.code,{children:"NaN"}),'. Cualquier otro valor es verdadero en contexto booleano, o "truthy".']}),"\n",(0,s.jsx)(n.h3,{id:"tobeundefined",children:(0,s.jsx)(n.code,{children:".toBeUndefined()"})}),"\n",(0,s.jsxs)(n.p,{children:["Usa ",(0,s.jsx)(n.code,{children:".toBeDefined"})," para verificar que una variable es undefined. Por ejemplo, si quieres verificar que la funci\xf3n ",(0,s.jsx)(n.code,{children:"mejorBebidaPorSabor(sabor)"})," regresa ",(0,s.jsx)(n.code,{children:"undefined"})," para el sabor ",(0,s.jsx)(n.code,{children:"'pulpo'"}),", porque no existe ninguna bebida con sabor a pulpo que sepa bien:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('beber La Croix lleva a conseguir info de sed', () => {\n  beberPocoLaCroix();\n  expect(infoSed()).toBeTruthy();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Podr\xeda escribir ",(0,s.jsx)(n.code,{children:"expect(mejorBebidaPorSabor('pulpo')).toBe(undefined)"}),", pero es buena practica omitir el uso de ",(0,s.jsx)(n.code,{children:"undefined"})," directamente en el c\xf3digo."]}),"\n",(0,s.jsx)(n.h3,{id:"tobenan",children:(0,s.jsx)(n.code,{children:".toBeNaN()"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toBeNaN"})," when checking a value is ",(0,s.jsx)(n.code,{children:"NaN"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('passes when value is NaN', () => {\n  expect(NaN).toBeNaN();\n  expect(1).not.toBeNaN();\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tocontainitem",children:(0,s.jsx)(n.code,{children:".toContain(item)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toContain"})," when you want to check that an item is in an array. For testing the items in the array, this uses ",(0,s.jsx)(n.code,{children:"==="}),", a strict equality check. ",(0,s.jsx)(n.code,{children:".toContain"})," can also check whether a string is a substring of another string."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, if ",(0,s.jsx)(n.code,{children:"getAllFlavors()"})," returns an array of flavors and you want to be sure that ",(0,s.jsx)(n.code,{children:"lime"})," is in there, you can write:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('la lista de sabores contiene lima', () => {\n  expect(conseguirTodosSabores()).toContain('lima');\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"This matcher also accepts others iterables such as strings, sets, node lists and HTML collections."}),"\n",(0,s.jsx)(n.h3,{id:"tocontainequalitem",children:(0,s.jsx)(n.code,{children:".toContainEqual(item)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toContainEqual"})," when you want to check that an item with a specific structure and values is contained in an array. For testing the items in the array, this matcher recursively checks the equality of all fields, rather than checking for object identity."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('la lista de sabores contiene lima', () => {\n  expect(conseguirTodosSabores()).toContain('lima');\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"toequalvalue",children:(0,s.jsx)(n.code,{children:".toEqual(value)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toEqual"}),' to compare recursively all properties of object instances (also known as "deep" equality). It calls ',(0,s.jsx)(n.code,{children:"Object.is"})," to compare primitive values, which is even better for testing than ",(0,s.jsx)(n.code,{children:"==="})," strict equality operator."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, ",(0,s.jsx)(n.code,{children:".toEqual"})," and ",(0,s.jsx)(n.code,{children:".toBe"})," behave differently in this test suite, so all the tests pass:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('mi bebida', () => {\n  test('es deliciosa y no es agr\xeda', () => {\n    const miBebida = {deliciosa: true, agria: false};\n    expect(misBebidas()).toContainEqual(miBebida);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"toEqual"})," ignores object keys with ",(0,s.jsx)(n.code,{children:"undefined"})," properties, ",(0,s.jsx)(n.code,{children:"undefined"})," array items, array sparseness, or object type mismatch. To take these into account use ",(0,s.jsx)(n.a,{href:"#tostrictequalvalue",children:(0,s.jsx)(n.code,{children:".toStrictEqual"})})," instead."]})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:".toEqual"})," won't perform a ",(0,s.jsx)(n.em,{children:"deep equality"})," check for two errors. S\xf3lo la propiedad ",(0,s.jsx)(n.code,{children:"message"})," de un error se verifica para comparar igualdad. Se recomienda utilizar el m\xe9todo ",(0,s.jsx)(n.code,{children:".toThrow"})," para probar errores."]})}),"\n",(0,s.jsxs)(n.p,{children:["If differences between properties do not help you to understand why a test fails, especially if the report is large, then you might move the comparison into the ",(0,s.jsx)(n.code,{children:"expect"})," function. For example, use ",(0,s.jsx)(n.code,{children:"equals"})," method of ",(0,s.jsx)(n.code,{children:"Buffer"})," class to assert whether or not buffers contain the same content:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["rewrite ",(0,s.jsx)(n.code,{children:"expect(received).toEqual(expected)"})," as ",(0,s.jsx)(n.code,{children:"expect(received.equals(expected)).toBe(true)"})]}),"\n",(0,s.jsxs)(n.li,{children:["rewrite ",(0,s.jsx)(n.code,{children:"expect(received).not.toEqual(expected)"})," as ",(0,s.jsx)(n.code,{children:"expect(received.equals(expected)).toBe(false)"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"tomatchregexp--string",children:(0,s.jsx)(n.code,{children:".toMatch(regexp | string)"})}),"\n",(0,s.jsxs)(n.p,{children:["Utilice ",(0,s.jsx)(n.code,{children:".toMatch"})," para verificar que la cadena coincida con una expresi\xf3n regular (Regex)."]}),"\n",(0,s.jsxs)(n.p,{children:["Por ejemplo, puede que no sepas el valor exacto que ",(0,s.jsx)(n.code,{children:"ensayoSobreElMejorSabor()"})," regresa, pero sabes que es una cadena muy larga, y que la cadena ",(0,s.jsx)(n.code,{children:"toronja"})," es parte del contenido. Podemos probarlo con:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const lata1 = {\n  sabor: 'toronja',\n  onzas: 12,\n};\nconst lata2 = {\n  sabor: 'toronja',\n  onzas: 12,\n};\n\ndescribe('las latas de La Croix en mi escritorio', () => {\n  test('tienen las mismas propiedades', () => {\n    expect(lata1).toEqual(lata2);\n  });\n  test('no son la misma lata', () => {\n    expect(lata1).not.toBe(lata2);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Este m\xe9todo acepta tambi\xe9n una cadena, con la que va a intentar coincidir:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('un ensayo sobre el mejor sabor', () => {\n  test('menciona toronja', () => {\n    expect(ensayoSobreElMejorSabor()).toMatch(/toronja/);\n    expect(ensayoSobreElMejorSabor()).toMatch(new RegExp('toronja'));\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tomatchobjectobject",children:(0,s.jsx)(n.code,{children:".toMatchObject(object)"})}),"\n",(0,s.jsxs)(n.p,{children:["Usa ",(0,s.jsx)(n.code,{children:".toMatchObject"})," para comprobar que un objeto de JavaScript coincide con un subconjunto de las propiedades de un objeto. Har\xe1 match de objetos recibidos cuyas propiedades ",(0,s.jsx)(n.strong,{children:"no"})," est\xe1n en el objeto esperado."]}),"\n",(0,s.jsxs)(n.p,{children:["Tambi\xe9n se puede pasar un arreglo de objetos, en cuyo caso el m\xe9todo regresara true solo si cada objeto en el arreglo hace match (como descrito en ",(0,s.jsx)(n.code,{children:"toMatchObject"})," anteriormente) con el objeto correspondiente en el arreglo esperado. Esto es \xfatil si se desea verificar que dos arreglos coinciden en el n\xfamero de sus elementos, opuesto a ",(0,s.jsx)(n.code,{children:"arrayContaining"}),", lo cual permite que el arreglo recibido contenga elementos adicionales."]}),"\n",(0,s.jsx)(n.p,{children:"Se puede hacer match de propiedades a trav\xe9s de sus valores o con matchers."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('las toronjas son saludables', () => {\n  test('las toronjas son frutas', () => {\n    expect('toronjas').toMatch('fruta');\n  });\n});\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('toMatchObject applied to arrays', () => {\n  test('the number of elements must match exactly', () => {\n    expect([{foo: 'bar'}, {baz: 1}]).toMatchObject([{foo: 'bar'}, {baz: 1}]);\n  });\n\n  test('.toMatchObject is called for each elements, so extra object properties are okay', () => {\n    expect([{foo: 'bar'}, {baz: 1, extra: 'quux'}]).toMatchObject([\n      {foo: 'bar'},\n      {baz: 1},\n    ]);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tomatchsnapshotpropertymatchers-hint",children:(0,s.jsx)(n.code,{children:".toMatchSnapshot(propertyMatchers?, hint?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Esto garantiza que un valor coincide con el snapshot m\xe1s reciente. V\xe9ase la ",(0,s.jsx)(n.a,{href:"/es-ES/docs/29.4/snapshot-testing",children:"guia de Snapshot Testing"})," para m\xe1s informaci\xf3n."]}),"\n",(0,s.jsxs)(n.p,{children:["You can provide an optional ",(0,s.jsx)(n.code,{children:"propertyMatchers"})," object argument, which has asymmetric matchers as values of a subset of expected properties, ",(0,s.jsx)(n.strong,{children:"if"})," the received value will be an ",(0,s.jsx)(n.strong,{children:"object"})," instance. It is like ",(0,s.jsx)(n.code,{children:"toMatchObject"})," with flexible criteria for a subset of properties, followed by a snapshot test as exact criteria for the rest of the properties."]}),"\n",(0,s.jsxs)(n.p,{children:["You can provide an optional ",(0,s.jsx)(n.code,{children:"hint"})," string argument that is appended to the test name. Although Jest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate ",(0,s.jsx)(n.strong,{children:"multiple"})," snapshots in a ",(0,s.jsx)(n.strong,{children:"single"})," ",(0,s.jsx)(n.code,{children:"it"})," or ",(0,s.jsx)(n.code,{children:"test"})," block. Jest sorts snapshots by name in the corresponding ",(0,s.jsx)(n.code,{children:".snap"})," file."]}),"\n",(0,s.jsx)(n.h3,{id:"tomatchinlinesnapshotpropertymatchers-inlinesnapshot",children:(0,s.jsx)(n.code,{children:".toMatchInlineSnapshot(propertyMatchers?, inlineSnapshot)"})}),"\n",(0,s.jsx)(n.p,{children:"Ensures that a value matches the most recent snapshot."}),"\n",(0,s.jsxs)(n.p,{children:["You can provide an optional ",(0,s.jsx)(n.code,{children:"propertyMatchers"})," object argument, which has asymmetric matchers as values of a subset of expected properties, ",(0,s.jsx)(n.strong,{children:"if"})," the received value will be an ",(0,s.jsx)(n.strong,{children:"object"})," instance. It is like ",(0,s.jsx)(n.code,{children:"toMatchObject"})," with flexible criteria for a subset of properties, followed by a snapshot test as exact criteria for the rest of the properties."]}),"\n",(0,s.jsxs)(n.p,{children:["Jest adds the ",(0,s.jsx)(n.code,{children:"inlineSnapshot"})," string argument to the matcher in the test file (instead of an external ",(0,s.jsx)(n.code,{children:".snap"})," file) the first time that the test runs."]}),"\n",(0,s.jsxs)(n.p,{children:["Check out the section on ",(0,s.jsx)(n.a,{href:"/es-ES/docs/29.4/snapshot-testing#inline-snapshots",children:"Inline Snapshots"})," for more info."]}),"\n",(0,s.jsx)(n.h3,{id:"tostrictequalvalue",children:(0,s.jsx)(n.code,{children:".toStrictEqual(value)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toStrictEqual"})," to test that objects have the same structure and type."]}),"\n",(0,s.jsxs)(n.p,{children:["Differences from ",(0,s.jsx)(n.code,{children:".toEqual"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["keys with ",(0,s.jsx)(n.code,{children:"undefined"})," properties are checked, e.g. ",(0,s.jsx)(n.code,{children:"{a: undefined, b: 2}"})," will not equal ",(0,s.jsx)(n.code,{children:"{b: 2}"}),";"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"undefined"})," items are taken into account, e.g. ",(0,s.jsx)(n.code,{children:"[2]"})," will not equal ",(0,s.jsx)(n.code,{children:"[2, undefined]"}),";"]}),"\n",(0,s.jsxs)(n.li,{children:["array sparseness is checked, e.g. ",(0,s.jsx)(n.code,{children:"[, 1]"})," will not equal ",(0,s.jsx)(n.code,{children:"[undefined, 1]"}),";"]}),"\n",(0,s.jsxs)(n.li,{children:["object types are checked, e.g. a class instance with fields ",(0,s.jsx)(n.code,{children:"a"})," and ",(0,s.jsx)(n.code,{children:"b"})," will not equal a literal object with fields ",(0,s.jsx)(n.code,{children:"a"})," and ",(0,s.jsx)(n.code,{children:"b"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class LaCroix {\n  constructor(flavor) {\n    this.flavor = flavor;\n  }\n}\n\ndescribe('the La Croix cans on my desk', () => {\n  test('are not semantically the same', () => {\n    expect(new LaCroix('lemon')).toEqual({flavor: 'lemon'});\n    expect(new LaCroix('lemon')).not.toStrictEqual({flavor: 'lemon'});\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tothrowerror",children:(0,s.jsx)(n.code,{children:".toThrow(error?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".toThrowError(error?)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Utilice ",(0,s.jsx)(n.code,{children:".toThrow"})," en una prueba para verificar que una funci\xf3n arroja un error cuando se llama. Por ejemplo, si deseamos probar que ",(0,s.jsx)(n.code,{children:"beberSabor('pulpo')"})," arroja un error, porque el sabor a pulpo es demasiado repugnante para beber, podemos escribir:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('arroja error en pulpo', () => {\n  function beberPulpo() {\n    beberSabor('pulpo');\n  }\n\n  expect(beberPulpo).toThrowErrorMatchingSnapshot();\n});\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"You must wrap the code in a function, otherwise the error will not be caught and the assertion will fail."})}),"\n",(0,s.jsx)(n.p,{children:"You can provide an optional argument to test that a specific error is thrown:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["regular expression: error message ",(0,s.jsx)(n.strong,{children:"matches"})," the pattern"]}),"\n",(0,s.jsxs)(n.li,{children:["string: error message ",(0,s.jsx)(n.strong,{children:"includes"})," the substring"]}),"\n",(0,s.jsxs)(n.li,{children:["error object: error message is ",(0,s.jsx)(n.strong,{children:"equal to"})," the message property of the object"]}),"\n",(0,s.jsxs)(n.li,{children:["error class: error object is ",(0,s.jsx)(n.strong,{children:"instance of"})," class"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Por ejemplo, digamos que el c\xf3digo de ",(0,s.jsx)(n.code,{children:"beberSabor"})," es el siguiente:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('arroja error en pulpo', () => {\n  expect(() => {\n    beberSabor('pulpo');\n  }).toThrow();\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Podr\xedamos probar que este error lanza una excepci\xf3n de varias formas:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('throws on octopus', () => {\n  function drinkOctopus() {\n    drinkFlavor('octopus');\n  }\n\n  // Test that the error message says \"yuck\" somewhere: these are equivalent\n  expect(drinkOctopus).toThrow(/yuck/);\n  expect(drinkOctopus).toThrow('yuck');\n\n  // Test the exact error message\n  expect(drinkOctopus).toThrow(/^yuck, octopus flavor$/);\n  expect(drinkOctopus).toThrow(new Error('yuck, octopus flavor'));\n\n  // Test that we get a DisgustingFlavorError\n  expect(drinkOctopus).toThrow(DisgustingFlavorError);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tothrowerrormatchingsnapshothint",children:(0,s.jsx)(n.code,{children:".toThrowErrorMatchingSnapshot(hint?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Utilice ",(0,s.jsx)(n.code,{children:".toThrowErrorMatchingSnapshot"})," para probar que una funci\xf3n arroja un error igual al snapshot m\xe1s reciente cuando es llamada."]}),"\n",(0,s.jsxs)(n.p,{children:["You can provide an optional ",(0,s.jsx)(n.code,{children:"hint"})," string argument that is appended to the test name. Although Jest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate ",(0,s.jsx)(n.strong,{children:"multiple"})," snapshots in a ",(0,s.jsx)(n.strong,{children:"single"})," ",(0,s.jsx)(n.code,{children:"it"})," or ",(0,s.jsx)(n.code,{children:"test"})," block. Jest sorts snapshots by name in the corresponding ",(0,s.jsx)(n.code,{children:".snap"})," file."]}),"\n",(0,s.jsxs)(n.p,{children:["Por ejemplo, digamos que tienes una funci\xf3n ",(0,s.jsx)(n.code,{children:"beberSabor"})," que arroja un error cuando el sabor es ",(0,s.jsx)(n.code,{children:"'pulpo'"}),", y su c\xf3digo es el siguiente:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('arroja error en pulpo', () => {\n  expect(() => {\n    beberSabor('pulpo');\n  }).toThrow();\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"El test para esta funci\xf3n se ver\xe1 as\xed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function beberSabor(sabor) {\n  if (sabor == 'pulpo') {\n    throw new ErrorSaborRepugnante('guac! sabor a pulpo');\n  }\n  // Funcionalidad extra\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Y generar\xe1 el siguiente snapshot:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'exports[`drinking flavors throws on octopus 1`] = `"yuck, octopus flavor"`;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Check out ",(0,s.jsx)(n.a,{href:"/blog/2016/07/27/jest-14",children:"React Tree Snapshot Testing"})," for more information on snapshot testing."]}),"\n",(0,s.jsx)(n.h3,{id:"tothrowerrormatchinginlinesnapshotinlinesnapshot",children:(0,s.jsx)(n.code,{children:".toThrowErrorMatchingInlineSnapshot(inlineSnapshot)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toThrowErrorMatchingInlineSnapshot"})," to test that a function throws an error matching the most recent snapshot when it is called."]}),"\n",(0,s.jsxs)(n.p,{children:["Jest adds the ",(0,s.jsx)(n.code,{children:"inlineSnapshot"})," string argument to the matcher in the test file (instead of an external ",(0,s.jsx)(n.code,{children:".snap"})," file) the first time that the test runs."]}),"\n",(0,s.jsxs)(n.p,{children:["Check out the section on ",(0,s.jsx)(n.a,{href:"/es-ES/docs/29.4/snapshot-testing#inline-snapshots",children:"Inline Snapshots"})," for more info."]}),"\n",(0,s.jsx)(n.h2,{id:"asymmetric-matchers",children:"Asymmetric Matchers"}),"\n",(0,s.jsx)(n.h3,{id:"expectanything",children:(0,s.jsx)(n.code,{children:"expect.anything()"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.anything()"})," aprobar\xe1 cualquier cosa excepto ",(0,s.jsx)(n.code,{children:"null"})," o ",(0,s.jsx)(n.code,{children:"undefined"}),". Pedes usarlo dentro de ",(0,s.jsx)(n.code,{children:"toEqual"})," o ",(0,s.jsx)(n.code,{children:"toBeCalledWith"})," en vez de usar un valor literal. Por ejemplo, si quieres asegurarte de que un mock ha sido llamado con un argumento que no sea null:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('map calls its argument with a non-null argument', () => {\n  const mock = jest.fn();\n  [1].map(x => mock(x));\n  expect(mock).toHaveBeenCalledWith(expect.anything());\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectanyconstructor",children:(0,s.jsx)(n.code,{children:"expect.any(constructor)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.any(constructor)"})," matches anything that was created with the given constructor or if it's a primitive that is of the passed type. Pedes usarlo dentro de ",(0,s.jsx)(n.code,{children:"toEqual"})," o ",(0,s.jsx)(n.code,{children:"toBeCalledWith"})," en vez de usar un valor literal. Por ejemplo, si quieres asegurarte de que un mock ha sido llamado con un n\xfamero:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class Cat {}\nfunction getCat(fn) {\n  return fn(new Cat());\n}\n\ntest('randocall calls its callback with a class instance', () => {\n  const mock = jest.fn();\n  getCat(mock);\n  expect(mock).toHaveBeenCalledWith(expect.any(Cat));\n});\n\nfunction randocall(fn) {\n  return fn(Math.floor(Math.random() * 6 + 1));\n}\n\ntest('randocall calls its callback with a number', () => {\n  const mock = jest.fn();\n  randocall(mock);\n  expect(mock).toHaveBeenCalledWith(expect.any(Number));\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectarraycontainingarray",children:(0,s.jsx)(n.code,{children:"expect.arrayContaining(array)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.arrayContaining(array)"})," aprueba que la matriz recibida contiene todos los elementos de la matriz esperada. Eso significa que la matriz esperada es un ",(0,s.jsx)(n.strong,{children:"subconjunto"})," de la matriz recibida. Por tanto, aprueba una matriz recibida que contenga elementos que ",(0,s.jsx)(n.strong,{children:"no"})," est\xe9n en la matriz esperada."]}),"\n",(0,s.jsx)(n.p,{children:"Puedes utilizarla en vez de usar un valor literal:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["in ",(0,s.jsx)(n.code,{children:"toEqual"})," or ",(0,s.jsx)(n.code,{children:"toBeCalledWith"})]}),"\n",(0,s.jsxs)(n.li,{children:["to match a property in ",(0,s.jsx)(n.code,{children:"objectContaining"})," or ",(0,s.jsx)(n.code,{children:"toMatchObject"})]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('arrayContaining', () => {\n  const expected = ['Alice', 'Bob'];\n  it('matches even if received contains additional elements', () => {\n    expect(['Alice', 'Bob', 'Eve']).toEqual(expect.arrayContaining(expected));\n  });\n  it('does not match if received does not contain expected elements', () => {\n    expect(['Bob', 'Eve']).not.toEqual(expect.arrayContaining(expected));\n  });\n});\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('Beware of a misunderstanding! A sequence of dice rolls', () => {\n  const expected = [1, 2, 3, 4, 5, 6];\n  it('matches even with an unexpected number 7', () => {\n    expect([4, 1, 6, 7, 3, 5, 2, 5, 4, 6]).toEqual(\n      expect.arrayContaining(expected),\n    );\n  });\n  it('does not match without an expected number 2', () => {\n    expect([4, 1, 6, 7, 3, 5, 7, 5, 4, 6]).not.toEqual(\n      expect.arrayContaining(expected),\n    );\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectnotarraycontainingarray",children:(0,s.jsx)(n.code,{children:"expect.not.arrayContaining(array)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.not.arrayContaining(array)"})," matches a received array which does not contain all of the elements in the expected array. That is, the expected array ",(0,s.jsx)(n.strong,{children:"is not a subset"})," of the received array."]}),"\n",(0,s.jsxs)(n.p,{children:["It is the inverse of ",(0,s.jsx)(n.code,{children:"expect.arrayContaining"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('not.arrayContaining', () => {\n  const expected = ['Samantha'];\n\n  it('matches if the actual array does not contain the expected elements', () => {\n    expect(['Alice', 'Bob', 'Eve']).toEqual(\n      expect.not.arrayContaining(expected),\n    );\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectclosetonumber-numdigits",children:(0,s.jsx)(n.code,{children:"expect.closeTo(number, numDigits?)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.closeTo(number, numDigits?)"})," is useful when comparing floating point numbers in object properties or array item. If you need to compare a number, please use ",(0,s.jsx)(n.code,{children:".toBeCloseTo"})," instead."]}),"\n",(0,s.jsxs)(n.p,{children:["The optional ",(0,s.jsx)(n.code,{children:"numDigits"})," argument limits the number of digits to check ",(0,s.jsx)(n.strong,{children:"after"})," the decimal point. For the default value ",(0,s.jsx)(n.code,{children:"2"}),", the test criterion is ",(0,s.jsx)(n.code,{children:"Math.abs(expected - received) < 0.005 (that is, 10 ** -2 / 2)"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"For example, this test passes with a precision of 5 digits:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('compare float in object properties', () => {\n  expect({\n    title: '0.1 + 0.2',\n    sum: 0.1 + 0.2,\n  }).toEqual({\n    title: '0.1 + 0.2',\n    sum: expect.closeTo(0.3, 5),\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectobjectcontainingobject",children:(0,s.jsx)(n.code,{children:"expect.objectContaining(object)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.objectContaining(object)"})," compara recursivamente con cualquier objeto recibido que cumpla con las propiedades esperadas. Es decir, el objeto esperado es un ",(0,s.jsx)(n.strong,{children:"subconjunto"})," del objeto recibido. Therefore, it matches a received object which contains properties that ",(0,s.jsx)(n.strong,{children:"are present"})," in the expected object."]}),"\n",(0,s.jsxs)(n.p,{children:["En lugar de verificar los valores de propiedades en el objeto esperado, se pueden ocupar matchers, como ",(0,s.jsx)(n.code,{children:"expect.anything()"}),", entre otros."]}),"\n",(0,s.jsxs)(n.p,{children:["Por ejemplo, si se espera que la funci\xf3n ",(0,s.jsx)(n.code,{children:"onPress"})," sea llamada con el objeto ",(0,s.jsx)(n.code,{children:"Event"}),", y solo se necesita verificar que el evento tiene las propiedades ",(0,s.jsx)(n.code,{children:"event.x"})," y ",(0,s.jsx)(n.code,{children:"event.y"}),". Puedes hacer esto con:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('onPress gets called with the right thing', () => {\n  const onPress = jest.fn();\n  simulatePresses(onPress);\n  expect(onPress).toHaveBeenCalledWith(\n    expect.objectContaining({\n      x: expect.any(Number),\n      y: expect.any(Number),\n    }),\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectnotobjectcontainingobject",children:(0,s.jsx)(n.code,{children:"expect.not.objectContaining(object)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.not.objectContaining(object)"})," matches any received object that does not recursively match the expected properties. That is, the expected object ",(0,s.jsx)(n.strong,{children:"is not a subset"})," of the received object. De tal manera que, hace match con un objeto que contiene propiedades que ",(0,s.jsx)(n.strong,{children:"no"})," se encuentran en el objeto esperado."]}),"\n",(0,s.jsxs)(n.p,{children:["It is the inverse of ",(0,s.jsx)(n.code,{children:"expect.objectContaining"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('not.objectContaining', () => {\n  const expected = {foo: 'bar'};\n\n  it('matches if the actual object does not contain expected key: value pairs', () => {\n    expect({bar: 'baz'}).toEqual(expect.not.objectContaining(expected));\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectstringcontainingstring",children:(0,s.jsx)(n.code,{children:"expect.stringContaining(string)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.stringContaining(string)"})," matches the received value if it is a string that contains the exact expected string."]}),"\n",(0,s.jsx)(n.h3,{id:"expectnotstringcontainingstring",children:(0,s.jsx)(n.code,{children:"expect.not.stringContaining(string)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.not.stringContaining(string)"})," matches the received value if it is not a string or if it is a string that does not contain the exact expected string."]}),"\n",(0,s.jsxs)(n.p,{children:["It is the inverse of ",(0,s.jsx)(n.code,{children:"expect.stringContaining"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('not.stringContaining', () => {\n  const expected = 'Hello world!';\n\n  it('matches if the received value does not contain the expected substring', () => {\n    expect('How are you?').toEqual(expect.not.stringContaining(expected));\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectstringmatchingstring--regexp",children:(0,s.jsx)(n.code,{children:"expect.stringMatching(string | regexp)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.stringMatching(string | regexp)"})," matches the received value if it is a string that matches the expected string or regular expression."]}),"\n",(0,s.jsx)(n.p,{children:"Puedes utilizarla en vez de usar un valor literal:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["in ",(0,s.jsx)(n.code,{children:"toEqual"})," or ",(0,s.jsx)(n.code,{children:"toBeCalledWith"})]}),"\n",(0,s.jsxs)(n.li,{children:["to match an element in ",(0,s.jsx)(n.code,{children:"arrayContaining"})]}),"\n",(0,s.jsxs)(n.li,{children:["to match a property in ",(0,s.jsx)(n.code,{children:"objectContaining"})," or ",(0,s.jsx)(n.code,{children:"toMatchObject"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Este ejemplo tambi\xe9n muestra c\xf3mo se pueden anidar m\xfaltiples marcadores de comparaci\xf3n asim\xe9tricas, con ",(0,s.jsx)(n.code,{children:"expect.stringMatching"})," dentro de ",(0,s.jsx)(n.code,{children:"expect.arrayContaining"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('stringMatching in arrayContaining', () => {\n  const expected = [\n    expect.stringMatching(/^Alic/),\n    expect.stringMatching(/^[BR]ob/),\n  ];\n  it('matches even if received contains additional elements', () => {\n    expect(['Alicia', 'Roberto', 'Evelina']).toEqual(\n      expect.arrayContaining(expected),\n    );\n  });\n  it('does not match if received does not contain expected elements', () => {\n    expect(['Roberto', 'Evelina']).not.toEqual(\n      expect.arrayContaining(expected),\n    );\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectnotstringmatchingstring--regexp",children:(0,s.jsx)(n.code,{children:"expect.not.stringMatching(string | regexp)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.not.stringMatching(string | regexp)"})," matches the received value if it is not a string or if it is a string that does not match the expected string or regular expression."]}),"\n",(0,s.jsxs)(n.p,{children:["It is the inverse of ",(0,s.jsx)(n.code,{children:"expect.stringMatching"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('not.stringMatching', () => {\n  const expected = /Hello world!/;\n\n  it('matches if the received value does not match the expected regex', () => {\n    expect('How are you?').toEqual(expect.not.stringMatching(expected));\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"assertion-count",children:"Assertion Count"}),"\n",(0,s.jsx)(n.h3,{id:"expectassertionsnumber",children:(0,s.jsx)(n.code,{children:"expect.assertions(number)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.assertions(number)"})," verifica que un cierto n\xfamero de afirmaciones han sido realizadas durante un test. Esto es \xfatil a la hora de probar c\xf3digo as\xedncrono para asegurarnos de que las afirmaciones de un callback fueron llamadas."]}),"\n",(0,s.jsxs)(n.p,{children:["Por ejemplo, supongamos que tenemos una funci\xf3n ",(0,s.jsx)(n.code,{children:"doAsync"})," que recibe dos devoluciones de llamada ",(0,s.jsx)(n.code,{children:"callback1"})," y ",(0,s.jsx)(n.code,{children:"callback2"}),", asincr\xf3nicamente se llamar\xe1 a ambas en un orden desconocido. Podemos comprobarlo con:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('prepareState prepara un estado valido', () => {\n  expect.hasAssertions();\n  prepareState(state => {\n    expect(validateState(estado)).toBeTruthy();\n  });\n  return waitOnState();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["La llamada de ",(0,s.jsx)(n.code,{children:"expect.assertions(2)"})," asegura que ambas devoluciones de llamada son efectivamente ejecutadas."]}),"\n",(0,s.jsx)(n.h3,{id:"expecthasassertions",children:(0,s.jsx)(n.code,{children:"expect.hasAssertions()"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.hasAssertions()"})," verifica que al menos una verificaci\xf3n es llamada durante un test. Esto es \xfatil a la hora de probar c\xf3digo as\xedncrono para asegurarnos de que las afirmaciones de un callback fueron llamadas."]}),"\n",(0,s.jsxs)(n.p,{children:["Por ejemplo, digamos que tenemos unas pocas funciones y todas tratan con un estado. ",(0,s.jsx)(n.code,{children:"prepareState"})," llama a una devoluci\xf3n de llamada con un objeto de estado, ",(0,s.jsx)(n.code,{children:"validateState"})," se ejecuta en este objeto de estado, y ",(0,s.jsx)(n.code,{children:"waitOnState"})," devuelve una promesa que espera hasta que las devoluciones de llamada de ",(0,s.jsx)(n.code,{children:"prepareState"})," completen. Podemos comprobarlo con:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('doAsync llama a ambos callbacks', () => {\n  expect.assertions(2);\n  function callback1(data) {\n    expect(data).toBeTruthy();\n  }\n  function callback2(data) {\n    expect(data).toBeTruthy();\n  }\n\n  doAsync(callback1, callback2);\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["La llamada de ",(0,s.jsx)(n.code,{children:"expect.hasAssertions()"})," asegura que ambas devoluciones de llamada de ",(0,s.jsx)(n.code,{children:"prepareState"})," son efectivamente ejecutadas."]}),"\n",(0,s.jsx)(n.h2,{id:"extend-utilities",children:"Extend Utilities"}),"\n",(0,s.jsx)(n.h3,{id:"expectaddequalitytesterstesters",children:(0,s.jsx)(n.code,{children:"expect.addEqualityTesters(testers)"})}),"\n",(0,s.jsxs)(n.p,{children:["You can use ",(0,s.jsx)(n.code,{children:"expect.addEqualityTesters"})," to add your own methods to test if two objects are equal. For example, let's say you have a class in your code that represents volume and can determine if two volumes using different units are equal. You may want ",(0,s.jsx)(n.code,{children:"toEqual"})," (and other equality matchers) to use this custom equality method when comparing to Volume classes. You can add a custom equality tester to have ",(0,s.jsx)(n.code,{children:"toEqual"})," detect and apply custom logic when comparing Volume classes:"]}),"\n",(0,s.jsxs)(o.Z,{groupId:"code-examples",children:[(0,s.jsxs)(r.Z,{value:"js",label:"JavaScript",children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'tab={"span":3} title="Volume.js"',children:"// For simplicity in this example, we'll just support the units 'L' and 'mL'\nexport class Volume {\n  constructor(amount, unit) {\n    this.amount = amount;\n    this.unit = unit;\n  }\n\n  toString() {\n    return `[Volume ${this.amount}${this.unit}]`;\n  }\n\n  equals(other) {\n    if (this.unit === other.unit) {\n      return this.amount === other.amount;\n    } else if (this.unit === 'L' && other.unit === 'mL') {\n      return this.amount * 1000 === other.unit;\n    } else {\n      return this.amount === other.unit * 1000;\n    }\n  }\n}\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'title="areVolumesEqual.js"',children:"import {expect} from '@jest/globals';\nimport {Volume} from './Volume.js';\n\nfunction areVolumesEqual(a, b) {\n  const isAVolume = a instanceof Volume;\n  const isBVolume = b instanceof Volume;\n\n  if (isAVolume && isBVolume) {\n    return a.equals(b);\n  } else if (isAVolume !== isBVolume) {\n    return false;\n  } else {\n    return undefined;\n  }\n}\n\nexpect.addEqualityTesters([areVolumesEqual]);\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'title="__tests__/Volume.test.js"',children:"import {expect, test} from '@jest/globals';\nimport {Volume} from '../Volume.js';\nimport '../areVolumesEqual.js';\n\ntest('are equal with different units', () => {\n  expect(new Volume(1, 'L')).toEqual(new Volume(1000, 'mL'));\n});\n"})})]}),(0,s.jsxs)(r.Z,{value:"ts",label:"TypeScript",children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'tab={"span":3} title="Volume.ts"',children:"// For simplicity in this example, we'll just support the units 'L' and 'mL'\nexport class Volume {\n  public amount: number;\n  public unit: 'L' | 'mL';\n\n  constructor(amount: number, unit: 'L' | 'mL') {\n    this.amount = amount;\n    this.unit = unit;\n  }\n\n  toString(): string {\n    return `[Volume ${this.amount}${this.unit}]`;\n  }\n\n  equals(other: Volume): boolean {\n    if (this.unit === other.unit) {\n      return this.amount === other.amount;\n    } else if (this.unit === 'L' && other.unit === 'mL') {\n      return this.amount * 1000 === other.amount;\n    } else {\n      return this.amount === other.amount * 1000;\n    }\n  }\n}\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="areVolumesEqual.ts"',children:"import {expect} from '@jest/globals';\nimport {Volume} from './Volume.js';\n\nfunction areVolumesEqual(a: unknown, b: unknown): boolean | undefined {\n  const isAVolume = a instanceof Volume;\n  const isBVolume = b instanceof Volume;\n\n  if (isAVolume && isBVolume) {\n    return a.equals(b);\n  } else if (isAVolume !== isBVolume) {\n    return false;\n  } else {\n    return undefined;\n  }\n}\n\nexpect.addEqualityTesters([areVolumesEqual]);\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="__tests__/Volume.test.ts"',children:"import {expect, test} from '@jest/globals';\nimport {Volume} from '../Volume.js';\nimport '../areVolumesEqual.js';\n\ntest('are equal with different units', () => {\n  expect(new Volume(1, 'L')).toEqual(new Volume(1000, 'mL'));\n});\n"})})]})]}),"\n",(0,s.jsx)(n.h4,{id:"custom-equality-testers-api",children:"Custom equality testers API"}),"\n",(0,s.jsxs)(n.p,{children:["Custom testers are functions that return either the result (",(0,s.jsx)(n.code,{children:"true"})," or ",(0,s.jsx)(n.code,{children:"false"}),") of comparing the equality of the two given arguments or ",(0,s.jsx)(n.code,{children:"undefined"})," if the tester does not handle the given objects and wants to delegate equality to other testers (for example, the builtin equality testers)."]}),"\n",(0,s.jsx)(n.p,{children:"Custom testers are called with 3 arguments: the two objects to compare and the array of custom testers (used for recursive testers, see the section below)."}),"\n",(0,s.jsxs)(n.p,{children:["These helper functions and properties can be found on ",(0,s.jsx)(n.code,{children:"this"})," inside a custom tester:"]}),"\n",(0,s.jsx)(n.h4,{id:"thisequalsa-b-customtesters",children:(0,s.jsx)(n.code,{children:"this.equals(a, b, customTesters?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Esta es una funci\xf3n de igualdad profunda que regresar\xe1 ",(0,s.jsx)(n.code,{children:"true"})," si dos objetos tienen los mismos valores (recursivamente). It optionally takes a list of custom equality testers to apply to the deep equality checks. If you use this function, pass through the custom testers your tester is given so further equality checks ",(0,s.jsx)(n.code,{children:"equals"})," applies can also use custom testers the test author may have configured. See the example in the ",(0,s.jsx)(n.a,{href:"#recursive-custom-equality-testers",children:"Recursive custom equality testers"})," section for more details."]}),"\n",(0,s.jsx)(n.h4,{id:"matchers-vs-testers",children:"Matchers vs Testers"}),"\n",(0,s.jsxs)(n.p,{children:["Matchers are methods available on ",(0,s.jsx)(n.code,{children:"expect"}),", for example ",(0,s.jsx)(n.code,{children:"expect().toEqual()"}),". ",(0,s.jsx)(n.code,{children:"toEqual"})," is a matcher. A tester is a method used by matchers that do equality checks to determine if objects are the same."]}),"\n",(0,s.jsxs)(n.p,{children:["Custom matchers are good to use when you want to provide a custom assertion that test authors can use in their tests. For example, the ",(0,s.jsx)(n.code,{children:"toBeWithinRange"})," example in the ",(0,s.jsx)(n.a,{href:"#expectextendmatchers",children:(0,s.jsx)(n.code,{children:"expect.extend"})})," section is a good example of a custom matcher. Sometimes a test author may want to assert two numbers are exactly equal and should use ",(0,s.jsx)(n.code,{children:"toBe"}),". Other times, however, a test author may want to allow for some flexibility in their test, and ",(0,s.jsx)(n.code,{children:"toBeWithinRange"})," may be a more appropriate assertion."]}),"\n",(0,s.jsxs)(n.p,{children:["Custom equality testers are good for globally extending Jest matchers to apply custom equality logic for all equality comparisons. Test authors can't turn on custom testers for certain assertions and turn them off for others (a custom matcher should be used instead if that behavior is desired). For example, defining how to check if two ",(0,s.jsx)(n.code,{children:"Volume"})," objects are equal for all matchers would be a good custom equality tester."]}),"\n",(0,s.jsx)(n.h4,{id:"recursive-custom-equality-testers",children:"Recursive custom equality testers"}),"\n",(0,s.jsxs)(n.p,{children:["If your custom equality testers are testing objects with properties you'd like to do deep equality with, you should use the ",(0,s.jsx)(n.code,{children:"this.equals"})," helper available to equality testers. This ",(0,s.jsx)(n.code,{children:"equals"})," method is the same deep equals method Jest uses internally for all of its deep equality comparisons. It's the method that invokes your custom equality tester. It accepts an array of custom equality testers as a third argument. Custom equality testers are also given an array of custom testers as their third argument. Pass this argument into the third argument of ",(0,s.jsx)(n.code,{children:"equals"})," so that any further equality checks deeper into your object can also take advantage of custom equality testers."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's say you have a ",(0,s.jsx)(n.code,{children:"Book"})," class that contains an array of ",(0,s.jsx)(n.code,{children:"Author"})," classes and both of these classes have custom testers. The ",(0,s.jsx)(n.code,{children:"Book"})," custom tester would want to do a deep equality check on the array of ",(0,s.jsx)(n.code,{children:"Author"}),"s and pass in the custom testers given to it, so the ",(0,s.jsx)(n.code,{children:"Author"}),"s custom equality tester is applied:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'title="customEqualityTesters.js"',children:"function areAuthorEqual(a, b) {\n  const isAAuthor = a instanceof Author;\n  const isBAuthor = b instanceof Author;\n\n  if (isAAuthor && isBAuthor) {\n    // Authors are equal if they have the same name\n    return a.name === b.name;\n  } else if (isAAuthor !== isBAuthor) {\n    return false;\n  } else {\n    return undefined;\n  }\n}\n\nfunction areBooksEqual(a, b, customTesters) {\n  const isABook = a instanceof Book;\n  const isBBook = b instanceof Book;\n\n  if (isABook && isBBook) {\n    // Books are the same if they have the same name and author array. We need\n    // to pass customTesters to equals here so the Author custom tester will be\n    // used when comparing Authors\n    return (\n      a.name === b.name && this.equals(a.authors, b.authors, customTesters)\n    );\n  } else if (isABook !== isBBook) {\n    return false;\n  } else {\n    return undefined;\n  }\n}\n\nexpect.addEqualityTesters([areAuthorsEqual, areBooksEqual]);\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Remember to define your equality testers as regular functions and ",(0,s.jsx)(n.strong,{children:"not"})," arrow functions in order to access the tester context helpers (e.g. ",(0,s.jsx)(n.code,{children:"this.equals"}),")."]})}),"\n",(0,s.jsx)(n.h3,{id:"expectaddsnapshotserializerserializer",children:(0,s.jsx)(n.code,{children:"expect.addSnapshotSerializer(serializer)"})}),"\n",(0,s.jsxs)(n.p,{children:["Puedes llamar a ",(0,s.jsx)(n.code,{children:"expect.addSnapshotSerializer"})," para agregar un m\xf3dulo que formatee estructuras de datos espec\xedficas de la aplicaci\xf3n."]}),"\n",(0,s.jsxs)(n.p,{children:["Para un archivo de test individual, un m\xf3dulo a\xf1adido precede a los m\xf3dulos de ",(0,s.jsx)(n.code,{children:"snapshotSerializers"})," en la configuraci\xf3n, que preceden los serializadores de instant\xe1nea predeterminados para tipos de JavaScript integrados y elementos de React. El \xfaltimo m\xf3dulo a\xf1adido, es el primero m\xf3dulo testeado."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import serializer from 'my-serializer-module';\nexpect.addSnapshotSerializer(serializer);\n\n// afecta a las afirmaciones expect(value).toMatchSnapshot() en el archivo de test\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you add a snapshot serializer in individual test files instead of adding it to ",(0,s.jsx)(n.code,{children:"snapshotSerializers"})," configuration:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"You make the dependency explicit instead of implicit."}),"\n",(0,s.jsxs)(n.li,{children:["You avoid limits to configuration that might cause you to eject from ",(0,s.jsx)(n.a,{href:"https://github.com/facebookincubator/create-react-app",children:"create-react-app"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["V\xe9ase ",(0,s.jsx)(n.a,{href:"/es-ES/docs/29.4/configuration#snapshotserializers-arraystring",children:"configurando Jest"})," para m\xe1s informaci\xf3n."]}),"\n",(0,s.jsx)(n.h3,{id:"expectextendmatchers",children:(0,s.jsx)(n.code,{children:"expect.extend(matchers)"})}),"\n",(0,s.jsxs)(n.p,{children:["Puedes utilizar ",(0,s.jsx)(n.code,{children:"expect.extend"})," para a\xf1adir tus propios comparadores a Jest. For example, let's say that you're testing a number utility library and you're frequently asserting that numbers appear within particular ranges of other numbers. You could abstract that into a ",(0,s.jsx)(n.code,{children:"toBeWithinRange"})," matcher:"]}),"\n",(0,s.jsxs)(o.Z,{groupId:"code-examples",children:[(0,s.jsxs)(r.Z,{value:"js",label:"JavaScript",children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'tab={"span":3} title="toBeWithinRange.js"',children:"import {expect} from '@jest/globals';\n\nfunction toBeWithinRange(actual, floor, ceiling) {\n  if (\n    typeof actual !== 'number' ||\n    typeof floor !== 'number' ||\n    typeof ceiling !== 'number'\n  ) {\n    throw new Error('These must be of type number!');\n  }\n\n  const pass = actual >= floor && actual <= ceiling;\n  if (pass) {\n    return {\n      message: () =>\n        `expected ${this.utils.printReceived(\n          actual,\n        )} not to be within range ${this.utils.printExpected(\n          `${floor} - ${ceiling}`,\n        )}`,\n      pass: true,\n    };\n  } else {\n    return {\n      message: () =>\n        `expected ${this.utils.printReceived(\n          actual,\n        )} to be within range ${this.utils.printExpected(\n          `${floor} - ${ceiling}`,\n        )}`,\n      pass: false,\n    };\n  }\n}\n\nexpect.extend({\n  toBeWithinRange,\n});\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'title="__tests__/ranges.test.js"',children:"import {expect, test} from '@jest/globals';\nimport '../toBeWithinRange';\n\ntest('is within range', () => expect(100).toBeWithinRange(90, 110));\n\ntest('is NOT within range', () => expect(101).not.toBeWithinRange(0, 100));\n\ntest('asymmetric ranges', () => {\n  expect({apples: 6, bananas: 3}).toEqual({\n    apples: expect.toBeWithinRange(1, 10),\n    bananas: expect.not.toBeWithinRange(11, 20),\n  });\n});\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="toBeWithinRange.d.ts"',children:"// optionally add a type declaration, e.g. it enables autocompletion in IDEs\ndeclare module 'expect' {\n  interface AsymmetricMatchers {\n    toBeWithinRange(floor: number, ceiling: number): void;\n  }\n  interface Matchers<R> {\n    toBeWithinRange(floor: number, ceiling: number): R;\n  }\n}\n\nexport {};\n"})})]}),(0,s.jsxs)(r.Z,{value:"ts",label:"TypeScript",children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'tab={"span":2} title="toBeWithinRange.ts"',children:"import {expect} from '@jest/globals';\nimport type {MatcherFunction} from 'expect';\n\nconst toBeWithinRange: MatcherFunction<[floor: unknown, ceiling: unknown]> =\n  // `floor` and `ceiling` get types from the line above\n  // it is recommended to type them as `unknown` and to validate the values\n  function (actual, floor, ceiling) {\n    if (\n      typeof actual !== 'number' ||\n      typeof floor !== 'number' ||\n      typeof ceiling !== 'number'\n    ) {\n      throw new Error('These must be of type number!');\n    }\n\n    const pass = actual >= floor && actual <= ceiling;\n    if (pass) {\n      return {\n        message: () =>\n          // `this` context will have correct typings\n          `expected ${this.utils.printReceived(\n            actual,\n          )} not to be within range ${this.utils.printExpected(\n            `${floor} - ${ceiling}`,\n          )}`,\n        pass: true,\n      };\n    } else {\n      return {\n        message: () =>\n          `expected ${this.utils.printReceived(\n            actual,\n          )} to be within range ${this.utils.printExpected(\n            `${floor} - ${ceiling}`,\n          )}`,\n        pass: false,\n      };\n    }\n  };\n\nexpect.extend({\n  toBeWithinRange,\n});\n\ndeclare module 'expect' {\n  interface AsymmetricMatchers {\n    toBeWithinRange(floor: number, ceiling: number): void;\n  }\n  interface Matchers<R> {\n    toBeWithinRange(floor: number, ceiling: number): R;\n  }\n}\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'tab title="__tests__/ranges.test.ts"',children:"import {expect, test} from '@jest/globals';\nimport '../toBeWithinRange';\n\ntest('is within range', () => expect(100).toBeWithinRange(90, 110));\n\ntest('is NOT within range', () => expect(101).not.toBeWithinRange(0, 100));\n\ntest('asymmetric ranges', () => {\n  expect({apples: 6, bananas: 3}).toEqual({\n    apples: expect.toBeWithinRange(1, 10),\n    bananas: expect.not.toBeWithinRange(11, 20),\n  });\n});\n"})})]})]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["The type declaration of the matcher can live in a ",(0,s.jsx)(n.code,{children:".d.ts"})," file or in an imported ",(0,s.jsx)(n.code,{children:".ts"})," module (see JS and TS examples above respectively). If you keep the declaration in a ",(0,s.jsx)(n.code,{children:".d.ts"})," file, make sure that it is included in the program and that it is a valid module, i.e. it has at least an empty ",(0,s.jsx)(n.code,{children:"export {}"}),"."]})}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsxs)(n.p,{children:["Instead of importing ",(0,s.jsx)(n.code,{children:"toBeWithinRange"})," module to the test file, you can enable the matcher for all tests by moving the ",(0,s.jsx)(n.code,{children:"expect.extend"})," call to a ",(0,s.jsx)(n.a,{href:"Configuration.md/#setupfilesafterenv-array",children:(0,s.jsx)(n.code,{children:"setupFilesAfterEnv"})})," script:"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import {expect} from '@jest/globals';\n// remember to export `toBeWithinRange` as well\nimport {toBeWithinRange} from './toBeWithinRange';\n\nexpect.extend({\n  toBeWithinRange,\n});\n"})})]}),"\n",(0,s.jsx)(n.h4,{id:"async-matchers",children:"Async Matchers"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.extend"})," also supports async matchers. Async matchers return a Promise so you will need to await the returned value. Let's use an example matcher to illustrate the usage of them. We are going to implement a matcher called ",(0,s.jsx)(n.code,{children:"toBeDivisibleByExternalValue"}),", where the divisible number is going to be pulled from an external source."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"expect.extend({\n  async toBeDivisibleByExternalValue(received) {\n    const externalValue = await getExternalValueFromRemoteSource();\n    const pass = received % externalValue == 0;\n    if (pass) {\n      return {\n        message: () =>\n          `expected ${received} not to be divisible by ${externalValue}`,\n        pass: true,\n      };\n    } else {\n      return {\n        message: () =>\n          `expected ${received} to be divisible by ${externalValue}`,\n        pass: false,\n      };\n    }\n  },\n});\n\ntest('is divisible by external value', async () => {\n  await expect(100).toBeDivisibleByExternalValue();\n  await expect(101).not.toBeDivisibleByExternalValue();\n});\n"})}),"\n",(0,s.jsx)(n.h4,{id:"custom-matchers-api",children:"Custom Matchers API"}),"\n",(0,s.jsxs)(n.p,{children:["Matchers should return an object (or a Promise of an object) with two keys. ",(0,s.jsx)(n.code,{children:"pass"})," indica si hubo un acierto o no, y ",(0,s.jsx)(n.code,{children:"message"})," proporciona una funci\xf3n sin argumentos que devuelve un mensaje de error en caso de fallo. As\xed, cuando ",(0,s.jsx)(n.code,{children:"pass"})," es falso, ",(0,s.jsx)(n.code,{children:"message"})," debe devolver el mensaje de error para cuando ",(0,s.jsx)(n.code,{children:"expect(x).tuComparador()"}),". Y cuando ",(0,s.jsx)(n.code,{children:"pass"})," es 'true', ",(0,s.jsx)(n.code,{children:"message"})," debe devolver el mensaje de error para cuando ",(0,s.jsx)(n.code,{children:"expect(x).not.tuComparador()"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Matchers are called with the argument passed to ",(0,s.jsx)(n.code,{children:"expect(x)"})," followed by the arguments passed to ",(0,s.jsx)(n.code,{children:".yourMatcher(y, z)"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"expect.extend({\n  yourMatcher(x, y, z) {\n    return {\n      pass: true,\n      message: () => '',\n    };\n  },\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["These helper functions and properties can be found on ",(0,s.jsx)(n.code,{children:"this"})," inside a custom matcher:"]}),"\n",(0,s.jsx)(n.h4,{id:"thisisnot",children:(0,s.jsx)(n.code,{children:"this.isNot"})}),"\n",(0,s.jsxs)(n.p,{children:["A boolean to let you know this matcher was called with the negated ",(0,s.jsx)(n.code,{children:".not"})," modifier allowing you to display a clear and correct matcher hint (see example code)."]}),"\n",(0,s.jsx)(n.h4,{id:"thispromise",children:(0,s.jsx)(n.code,{children:"this.promise"})}),"\n",(0,s.jsx)(n.p,{children:"A string allowing you to display a clear and correct matcher hint:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"'rejects'"})," if matcher was called with the promise ",(0,s.jsx)(n.code,{children:".rejects"})," modifier"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"'resolves'"})," if matcher was called with the promise ",(0,s.jsx)(n.code,{children:".resolves"})," modifier"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"''"})," if matcher was not called with a promise modifier"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"thisequalsa-b-customtesters-1",children:(0,s.jsx)(n.code,{children:"this.equals(a, b, customTesters?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Esta es una funci\xf3n de igualdad profunda que regresar\xe1 ",(0,s.jsx)(n.code,{children:"true"})," si dos objetos tienen los mismos valores (recursivamente). It optionally takes a list of custom equality testers to apply to the deep equality checks (see ",(0,s.jsx)(n.code,{children:"this.customTesters"})," below)."]}),"\n",(0,s.jsx)(n.h4,{id:"thisexpand",children:(0,s.jsx)(n.code,{children:"this.expand"})}),"\n",(0,s.jsxs)(n.p,{children:["A boolean to let you know this matcher was called with an ",(0,s.jsx)(n.code,{children:"expand"})," option. When Jest is called with the ",(0,s.jsx)(n.code,{children:"--expand"})," flag, ",(0,s.jsx)(n.code,{children:"this.expand"})," can be used to determine if Jest is expected to show full diffs and errors."]}),"\n",(0,s.jsx)(n.h4,{id:"thisutils",children:(0,s.jsx)(n.code,{children:"this.utils"})}),"\n",(0,s.jsxs)(n.p,{children:["There are a number of helpful tools exposed on ",(0,s.jsx)(n.code,{children:"this.utils"})," primarily consisting of the exports from ",(0,s.jsx)(n.a,{href:"https://github.com/jestjs/jest/tree/main/packages/jest-matcher-utils",children:(0,s.jsx)(n.code,{children:"jest-matcher-utils"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Las m\xe1s \xfatiles son ",(0,s.jsx)(n.code,{children:"matcherHint"}),", ",(0,s.jsx)(n.code,{children:"printExpected"})," y ",(0,s.jsx)(n.code,{children:"printReceived"})," para dar formato mas agradable a los mensajes de error. Por ejemplo, echa un vistazo en la implementaci\xf3n para el comparador ",(0,s.jsx)(n.code,{children:"toBe"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {diff} = require('jest-diff');\nexpect.extend({\n  toBe(received, expected) {\n    const options = {\n      comment: 'Object.is equality',\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n\n    const pass = Object.is(received, expected);\n\n    const message = pass\n      ? () =>\n          // eslint-disable-next-line prefer-template\n          this.utils.matcherHint('toBe', undefined, undefined, options) +\n          '\\n\\n' +\n          `Expected: not ${this.utils.printExpected(expected)}\\n` +\n          `Received: ${this.utils.printReceived(received)}`\n      : () => {\n          const diffString = diff(expected, received, {\n            expand: this.expand,\n          });\n          return (\n            // eslint-disable-next-line prefer-template\n            this.utils.matcherHint('toBe', undefined, undefined, options) +\n            '\\n\\n' +\n            (diffString && diffString.includes('- Expect')\n              ? `Difference:\\n\\n${diffString}`\n              : `Expected: ${this.utils.printExpected(expected)}\\n` +\n                `Received: ${this.utils.printReceived(received)}`)\n          );\n        };\n\n    return {actual: received, message, pass};\n  },\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Esto mostrar\xe1 algo as\xed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'  expect(received).toBe(expected)\n\n    Expected value to be (using Object.is):\n      "banana"\n    Received:\n      "apple"\n'})}),"\n",(0,s.jsx)(n.p,{children:"Cuando una afirmaci\xf3n falla, el mensaje de error deber\xeda dar las se\xf1ales necesarias para que el usuario pueda resolver sus problemas r\xe1pidamente. Deber\xedas crear mensajes de errores precisos para que los usuarios de tus afirmaciones personalizadas se sientan c\xf3modos us\xe1ndolas."}),"\n",(0,s.jsx)(n.h4,{id:"thiscustomtesters",children:(0,s.jsx)(n.code,{children:"this.customTesters"})}),"\n",(0,s.jsxs)(n.p,{children:["If your matcher does a deep equality check using ",(0,s.jsx)(n.code,{children:"this.equals"}),", you may want to pass user-provided custom testers to ",(0,s.jsx)(n.code,{children:"this.equals"}),". The custom equality testers the user has provided using the ",(0,s.jsx)(n.code,{children:"addEqualityTesters"})," API are available on this property. The built-in Jest matchers pass ",(0,s.jsx)(n.code,{children:"this.customTesters"})," (along with other built-in testers) to ",(0,s.jsx)(n.code,{children:"this.equals"})," to do deep equality, and your custom matchers may want to do the same."]}),"\n",(0,s.jsx)(n.h4,{id:"custom-snapshot-matchers",children:"Custom snapshot matchers"}),"\n",(0,s.jsxs)(n.p,{children:["To use snapshot testing inside of your custom matcher you can import ",(0,s.jsx)(n.code,{children:"jest-snapshot"})," and use it from within your matcher."]}),"\n",(0,s.jsxs)(n.p,{children:["Here's a snapshot matcher that trims a string to store for a given length, ",(0,s.jsx)(n.code,{children:".toMatchTrimmedSnapshot(length)"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {toMatchSnapshot} = require('jest-snapshot');\n\nexpect.extend({\n  toMatchTrimmedSnapshot(received, length) {\n    return toMatchSnapshot.call(\n      this,\n      received.substring(0, length),\n      'toMatchTrimmedSnapshot',\n    );\n  },\n});\n\nit('stores only 10 characters', () => {\n  expect('extra long string oh my gerd').toMatchTrimmedSnapshot(10);\n});\n\n/*\nStored snapshot will look like:\n\nexports[`stores only 10 characters: toMatchTrimmedSnapshot 1`] = `\"extra long\"`;\n*/\n"})}),"\n",(0,s.jsx)(n.p,{children:"It's also possible to create custom matchers for inline snapshots, the snapshots will be correctly added to the custom matchers. However, inline snapshot will always try to append to the first argument or the second when the first argument is the property matcher, so it's not possible to accept custom arguments in the custom matchers."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {toMatchInlineSnapshot} = require('jest-snapshot');\n\nexpect.extend({\n  toMatchTrimmedInlineSnapshot(received, ...rest) {\n    return toMatchInlineSnapshot.call(this, received.substring(0, 10), ...rest);\n  },\n});\n\nit('stores only 10 characters', () => {\n  expect('extra long string oh my gerd').toMatchTrimmedInlineSnapshot();\n  /*\n  The snapshot will be added inline like\n  expect('extra long string oh my gerd').toMatchTrimmedInlineSnapshot(\n    `\"extra long\"`\n  );\n  */\n});\n"})}),"\n",(0,s.jsx)(n.h4,{id:"async",children:"async"}),"\n",(0,s.jsxs)(n.p,{children:["If your custom inline snapshot matcher is async i.e. uses ",(0,s.jsx)(n.code,{children:"async"}),"-",(0,s.jsx)(n.code,{children:"await"}),' you might encounter an error like "Multiple inline snapshots for the same call are not supported". Jest needs additional context information to find where the custom inline snapshot matcher was used to update the snapshots properly.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {toMatchInlineSnapshot} = require('jest-snapshot');\n\nexpect.extend({\n  async toMatchObservationInlineSnapshot(fn, ...rest) {\n    // The error (and its stacktrace) must be created before any `await`\n    this.error = new Error();\n\n    // The implementation of `observe` doesn't matter.\n    // It only matters that the custom snapshot matcher is async.\n    const observation = await observe(async () => {\n      await fn();\n    });\n\n    return toMatchInlineSnapshot.call(this, recording, ...rest);\n  },\n});\n\nit('observes something', async () => {\n  await expect(async () => {\n    return 'async action';\n  }).toMatchTrimmedInlineSnapshot();\n  /*\n  The snapshot will be added inline like\n  await expect(async () => {\n    return 'async action';\n  }).toMatchTrimmedInlineSnapshot(`\"async action\"`);\n  */\n});\n"})}),"\n",(0,s.jsx)(n.h4,{id:"bail-out",children:"Bail out"}),"\n",(0,s.jsxs)(n.p,{children:["Usually ",(0,s.jsx)(n.code,{children:"jest"})," tries to match every snapshot that is expected in a test."]}),"\n",(0,s.jsx)(n.p,{children:"Sometimes it might not make sense to continue the test if a prior snapshot failed. For example, when you make snapshots of a state-machine after various transitions you can abort the test once one transition produced the wrong state."}),"\n",(0,s.jsx)(n.p,{children:"In that case you can implement a custom snapshot matcher that throws on the first mismatch instead of collecting every mismatch."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {toMatchInlineSnapshot} = require('jest-snapshot');\n\nexpect.extend({\n  toMatchStateInlineSnapshot(...args) {\n    this.dontThrow = () => {};\n\n    return toMatchInlineSnapshot.call(this, ...args);\n  },\n});\n\nlet state = 'initial';\n\nfunction transition() {\n  // Typo in the implementation should cause the test to fail\n  if (state === 'INITIAL') {\n    state = 'pending';\n  } else if (state === 'pending') {\n    state = 'done';\n  }\n}\n\nit('transitions as expected', () => {\n  expect(state).toMatchStateInlineSnapshot(`\"initial\"`);\n\n  transition();\n  // Already produces a mismatch. No point in continuing the test.\n  expect(state).toMatchStateInlineSnapshot(`\"loading\"`);\n\n  transition();\n  expect(state).toMatchStateInlineSnapshot(`\"done\"`);\n});\n"})})]})}const m=function(e={}){const{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(x,e)})):x(e)}},1353:(e,n,t)=>{t.d(n,{ZP:()=>r});var s=t(4246),a=t(1670);function o(e){const n=Object.assign({admonition:"admonition",p:"p",pre:"pre",code:"code",a:"a"},(0,a.ah)(),e.components);return(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.p,{children:"The TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import {expect, jest, test} from '@jest/globals';\n"})}),(0,s.jsxs)(n.p,{children:["Consult the ",(0,s.jsx)(n.a,{href:"/es-ES/docs/29.4/getting-started#using-typescript",children:"Getting Started"})," guide for details on how to setup Jest with TypeScript."]})]})}const r=function(e={}){const{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(o,e)})):o(e)}}}]);