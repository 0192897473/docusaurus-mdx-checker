"use strict";(self.webpackChunkjest_website=self.webpackChunkjest_website||[]).push([[9173],{3908:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var s=t(4246),r=t(1670);const a={id:"asynchronous",title:"Tester du code asynchrone"},c=void 0,o={unversionedId:"asynchronous",id:"asynchronous",title:"Tester du code asynchrone",description:"Il est fr\xe9quent en JavaScript que le code s'ex\xe9cute de mani\xe8re asynchrone. Lorsque vous avez du code qui s\u2019ex\xe9cute de fa\xe7on asynchrone, Jest doit savoir quand le code qu'il teste est termin\xe9, avant de passer \xe0 un autre test. Jest a plusieurs fa\xe7ons de g\xe9rer cela.",source:"@site/i18n/fr/docusaurus-plugin-content-docs/current/TestingAsyncCode.md",sourceDirName:".",slug:"/asynchronous",permalink:"/fr/docs/next/asynchronous",draft:!1,unlisted:!1,editUrl:"https://crowdin.com/project/jest-v2/fr",tags:[],version:"current",frontMatter:{id:"asynchronous",title:"Tester du code asynchrone"},sidebar:"docs",previous:{title:"Utilisation des comparateurs",permalink:"/fr/docs/next/using-matchers"},next:{title:"Pr\xe9paration et nettoyage",permalink:"/fr/docs/next/setup-teardown"}},i={},l=[{value:"Promesses",id:"promesses",level:2},{value:"Async/Await",id:"asyncawait",level:2},{value:"Fonctions de rappel (Callbacks)",id:"fonctions-de-rappel-callbacks",level:2},{value:"<code>.resolves</code> / <code>.rejects</code>",id:"resolves--rejects",level:2}];function u(e){const n=Object.assign({p:"p",h2:"h2",code:"code",pre:"pre",admonition:"admonition",em:"em"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Il est fr\xe9quent en JavaScript que le code s'ex\xe9cute de mani\xe8re asynchrone. Lorsque vous avez du code qui s\u2019ex\xe9cute de fa\xe7on asynchrone, Jest doit savoir quand le code qu'il teste est termin\xe9, avant de passer \xe0 un autre test. Jest a plusieurs fa\xe7ons de g\xe9rer cela."}),"\n",(0,s.jsx)(n.h2,{id:"promesses",children:"Promesses"}),"\n",(0,s.jsx)(n.p,{children:"Renvoie une promesse depuis votre test, et Jest attendra que cette promesse soit r\xe9solue. Si la promesse est rejet\xe9e, le test \xe9chouera."}),"\n",(0,s.jsxs)(n.p,{children:["Par exemple, disons que ",(0,s.jsx)(n.code,{children:"fetchData"})," renvoie une promesse qui est cens\xe9e se r\xe9soudre par la cha\xeene ",(0,s.jsx)(n.code,{children:"'peanut butter'"}),". On pourrait le tester avec :"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('la donn\xe9e est peanut butter', () => {\n  return fetchData().then(data => {\n    expect(data).toBe('peanut butter');\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"asyncawait",children:"Async/Await"}),"\n",(0,s.jsxs)(n.p,{children:["Vous pouvez \xe9galement utiliser ",(0,s.jsx)(n.code,{children:"async"})," et ",(0,s.jsx)(n.code,{children:"await"})," dans vos tests. Pour \xe9crire un test asynchrone, utilisez le mot cl\xe9 ",(0,s.jsx)(n.code,{children:"async"})," devant la fonction pass\xe9e \xe0 ",(0,s.jsx)(n.code,{children:"test"}),". Par exemple, le m\xeame sc\xe9nario ",(0,s.jsx)(n.code,{children:"fetchData"})," peut \xeatre test\xe9 avec\xa0:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('la donn\xe9e est peanut butter', async () => {\n  const data = await fetchData();\n  expect(data).toBe('peanut butter');\n});\n\ntest('la r\xe9cup\xe9ration \xe9choue avec une erreur', async () => {\n  expect.assertions(1);\n  try {\n    await fetchData();\n  } catch (e) {\n    expect(e).toMatch('error');\n  }\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Vous pouvez combiner ",(0,s.jsx)(n.code,{children:"async"})," et ",(0,s.jsx)(n.code,{children:"await"})," avec ",(0,s.jsx)(n.code,{children:".resolves"})," ou ",(0,s.jsx)(n.code,{children:".rejects"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('la donn\xe9e est peanut butter', async () => {\n  await expect(fetchData()).resolves.toBe('peanut butter');\n});\n\ntest('la r\xe9cup\xe9ration \xe9choue avec une erreur', async () => {\n  await expect(fetchData()).rejects.toMatch('error');\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Dans ces cas, ",(0,s.jsx)(n.code,{children:"async"})," et ",(0,s.jsx)(n.code,{children:"await"})," sont effectivement du sucre syntaxique pour la m\xeame logique que celle utilis\xe9e dans l'exemple des promesses."]}),"\n",(0,s.jsx)(n.admonition,{title:"attention",type:"caution",children:(0,s.jsxs)(n.p,{children:["Assurez-vous de retourner (ou ",(0,s.jsx)(n.code,{children:"attendre"})," la promesse) - si vous omettez l'instruction ",(0,s.jsx)(n.code,{children:"return"}),"/",(0,s.jsx)(n.code,{children:"await"}),", votre test se terminera avant que la promesse retourn\xe9e par ",(0,s.jsx)(n.code,{children:"fetchData"})," ne se r\xe9sout ou ne se rejette."]})}),"\n",(0,s.jsxs)(n.p,{children:["Si vous vous attendez \xe0 ce qu'une promesse soit rejet\xe9e, utilisez la m\xe9thode ",(0,s.jsx)(n.code,{children:".catch"}),". Assurez-vous de rajouter ",(0,s.jsx)(n.code,{children:"expect.assertions"})," pour v\xe9rifier qu'un certain nombre d'assertions sont appel\xe9es. Sinon, une promesse accomplie ne passerait pas le test."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('la r\xe9cup\xe9ration \xe9choue avec une erreur', () => {\n  expect.assertions(1);\n  return fetchData().catch(e => expect(e).toMatch('error'));\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"fonctions-de-rappel-callbacks",children:"Fonctions de rappel (Callbacks)"}),"\n",(0,s.jsxs)(n.p,{children:["Si vous n'utilisez pas de promesses, vous pouvez utiliser des callbacks. Par exemple, supposons que ",(0,s.jsx)(n.code,{children:"fetchData"}),", au lieu de retourner une promesse, attend un callback, par exemple il r\xe9cup\xe8re des donn\xe9es et appelle ",(0,s.jsx)(n.code,{children:"callback(null, data)"})," quand il est termin\xe9. Vous voulez v\xe9rifier que les donn\xe9es retourn\xe9es correspondent \xe0 la cha\xeene ",(0,s.jsx)(n.code,{children:"'peanut butter'"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Par d\xe9faut, les tests Jest se terminent lorsqu'ils parviennent \xe0 la fin de leur ex\xe9cution. Cela signifie que ce test ",(0,s.jsx)(n.em,{children:"ne fonctionnera pas"})," comme pr\xe9vu\xa0:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"//\xa0Ne faites pas \xe7a\xa0!\ntest('la donn\xe9e est peanut butter', () => {\n  function callback(error, data) {\n    if (error) {\n      throw error;\n    }\n    expect(data).toBe('peanut butter');\n  }\n\n  fetchData(callback);\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Le probl\xe8me est le suivant\xa0: le test se terminera d\xe8s que ",(0,s.jsx)(n.code,{children:"fetchData"})," sera effectu\xe9, avant m\xeame d'appeler le callback."]}),"\n",(0,s.jsxs)(n.p,{children:["Il y a une autre forme de ",(0,s.jsx)(n.code,{children:"test"})," qui r\xe9sout ce probl\xe8me. Au lieu de mettre le test dans une fonction avec un argument vide, utilisez un seul argument appel\xe9 ",(0,s.jsx)(n.code,{children:"done"}),". Jest attendra que le callback ",(0,s.jsx)(n.code,{children:"done"})," soit appel\xe9 avant de terminer le test."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('la donn\xe9e est peanut butter', done => {\n  function callback(error, data) {\n    if (error) {\n      done(error);\n      return;\n    }\n    try {\n      expect(data).toBe('peanut butter');\n      done();\n    } catch (error) {\n      done(error);\n    }\n  }\n\n  fetchData(callback);\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Si ",(0,s.jsx)(n.code,{children:"done()"})," n'est jamais appel\xe9, le test \xe9chouera (avec une erreur de timeout), ce qui correspond \xe0 votre souhait."]}),"\n",(0,s.jsxs)(n.p,{children:["Si l'instruction ",(0,s.jsx)(n.code,{children:"expect"})," \xe9choue, elle lance une erreur et ",(0,s.jsx)(n.code,{children:"done()"})," n'est pas appel\xe9. Si nous voulons voir dans le journal de test pourquoi il a \xe9chou\xe9, nous devons envelopper ",(0,s.jsx)(n.code,{children:"expect"})," dans un bloc ",(0,s.jsx)(n.code,{children:"try"})," et passer l'erreur dans le bloc ",(0,s.jsx)(n.code,{children:"catch"})," \xe0 ",(0,s.jsx)(n.code,{children:"done"}),". Autrement, nous nous retrouvons avec une erreur de timeout opaque qui ne montre pas quelle valeur a \xe9t\xe9 re\xe7ue par ",(0,s.jsx)(n.code,{children:"expect(data)"}),"."]}),"\n",(0,s.jsx)(n.admonition,{title:"attention",type:"caution",children:(0,s.jsxs)(n.p,{children:["Jest will throw an error, if the same test function is passed a ",(0,s.jsx)(n.code,{children:"done()"})," callback and returns a promise. This is done as a precaution to avoid memory leaks in your tests."]})}),"\n",(0,s.jsxs)(n.h2,{id:"resolves--rejects",children:[(0,s.jsx)(n.code,{children:".resolves"})," / ",(0,s.jsx)(n.code,{children:".rejects"})]}),"\n",(0,s.jsxs)(n.p,{children:["Vous pouvez \xe9galement utiliser le comparateur ",(0,s.jsx)(n.code,{children:".resolves"})," dans votre instruction expect, et Jest attendra la r\xe9solution de cette promesse. Si la promesse est rejet\xe9e, le test \xe9chouera automatiquement."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('la donn\xe9e est peanut butter', () => {\n  return expect(fetchData()).resolves.toBe('peanut butter');\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Assurez-vous de renvoyer l'assertion - si vous omettez cette d\xe9claration ",(0,s.jsx)(n.code,{children:"return"}),", votre test se terminera avant que la promesse renvoy\xe9e par ",(0,s.jsx)(n.code,{children:"fetchData"})," ne se soit r\xe9solue et que then() ait une chance d'ex\xe9cuter le callback."]}),"\n",(0,s.jsxs)(n.p,{children:["Si vous vous attendez \xe0 ce qu'une promesse soit rejet\xe9e, utilisez le comparateur ",(0,s.jsx)(n.code,{children:".rejects"}),". Il fonctionne de mani\xe8re analogue au comparateur ",(0,s.jsx)(n.code,{children:".resolves"}),". Si la promesse est accomplie, le test \xe9choue automatiquement."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('la r\xe9cup\xe9ration \xe9choue avec une erreur', () => {\n  return expect(fetchData()).rejects.toMatch('error');\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Aucune de ces formulations n'est particuli\xe8rement sup\xe9rieure aux autres, et vous pouvez les m\xe9langer dans une base de code ou m\xeame dans un seul fichier. Cela d\xe9pend simplement du style qui, selon vous, simplifie vos tests."})]})}const d=function(e={}){const{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(u,e)})):u(e)}},1670:(e,n,t)=>{t.d(n,{Zo:()=>o,ah:()=>a});var s=t(7378);const r=s.createContext({});function a(e){const n=s.useContext(r);return s.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}const c={};function o({components:e,children:n,disableParentContext:t}){let o;return o=t?"function"==typeof e?e({}):e||c:a(e),s.createElement(r.Provider,{value:o},n)}}}]);