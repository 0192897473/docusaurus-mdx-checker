"use strict";(self.webpackChunkjest_website=self.webpackChunkjest_website||[]).push([[4253],{1754:(e,a,s)=>{s.r(a),s.d(a,{assets:()=>d,contentTitle:()=>n,default:()=>u,frontMatter:()=>o,metadata:()=>c,toc:()=>i});var t=s(4246),r=s(1670);const o={id:"asynchronous",title:"Testando C\xf3digo Ass\xedncrono"},n=void 0,c={unversionedId:"asynchronous",id:"version-29.5/asynchronous",title:"Testando C\xf3digo Ass\xedncrono",description:"\xc9 comum em JavaScript executar c\xf3digo de forma ass\xedncrona. Quando voc\xea tiver o c\xf3digo que \xe9 executado de forma ass\xedncrona, Jest precisa saber quando o c\xf3digo que est\xe1 testando for conclu\xeddo, antes que possa passar para outro teste. Jest tem v\xe1rias maneiras de lidar com isso.",source:"@site/i18n/pt-BR/docusaurus-plugin-content-docs/version-29.5/TestingAsyncCode.md",sourceDirName:".",slug:"/asynchronous",permalink:"/pt-BR/docs/29.5/asynchronous",draft:!1,unlisted:!1,editUrl:"https://crowdin.com/project/jest-v2/pt-BR",tags:[],version:"29.5",frontMatter:{id:"asynchronous",title:"Testando C\xf3digo Ass\xedncrono"},sidebar:"docs",previous:{title:"Usando Matchers",permalink:"/pt-BR/docs/29.5/using-matchers"},next:{title:"Configura\xe7\xe3o e Desmontagem",permalink:"/pt-BR/docs/29.5/setup-teardown"}},d={},i=[{value:"Promises",id:"promises",level:2},{value:"Async/Await",id:"asyncawait",level:2},{value:"Callbacks",id:"callbacks",level:2},{value:"<code>.resolves</code> / <code>.rejects</code>",id:"resolves--rejects",level:2}];function l(e){const a=Object.assign({p:"p",h2:"h2",code:"code",pre:"pre",admonition:"admonition",em:"em"},(0,r.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(a.p,{children:"\xc9 comum em JavaScript executar c\xf3digo de forma ass\xedncrona. Quando voc\xea tiver o c\xf3digo que \xe9 executado de forma ass\xedncrona, Jest precisa saber quando o c\xf3digo que est\xe1 testando for conclu\xeddo, antes que possa passar para outro teste. Jest tem v\xe1rias maneiras de lidar com isso."}),"\n",(0,t.jsx)(a.h2,{id:"promises",children:"Promises"}),"\n",(0,t.jsx)(a.p,{children:"Retorne uma promise do seu teste, e o Jest vai esperar essa promise ser resolvida. Se a promessa for rejeitada, o teste ir\xe1 falhar."}),"\n",(0,t.jsxs)(a.p,{children:["Por exemplo, digamos que ",(0,t.jsx)(a.code,{children:"fetchData"})," retorna uma promessa que \xe9 esperada ser resolvida na string ",(0,t.jsx)(a.code,{children:"'peanut butter'"}),". Podemos fazer um teste com:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-js",children:"test('the data is peanut butter', () => {\n  return fetchData().then(data => {\n    expect(data).toBe('peanut butter');\n  });\n});\n"})}),"\n",(0,t.jsx)(a.h2,{id:"asyncawait",children:"Async/Await"}),"\n",(0,t.jsxs)(a.p,{children:["Como alternativa, voc\xea pode usar ",(0,t.jsx)(a.code,{children:"async"})," e ",(0,t.jsx)(a.code,{children:"await"})," em seus testes. Para escrever um teste ass\xedncrono, basta usar a palavra-chave ",(0,t.jsx)(a.code,{children:"async"})," na frente da fun\xe7\xe3o passada para ",(0,t.jsx)(a.code,{children:"test"}),". Por exemplo, o mesmo cen\xe1rio de ",(0,t.jsx)(a.code,{children:"fetchData"})," pode ser testado com:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-js",children:"test('the data is peanut butter', async () => {\n  const data = await fetchData();\n  expect(data).toBe('peanut butter');\n});\n\ntest('the fetch fails with an error', async () => {\n  expect.assertions(1);\n  try {\n    await fetchData();\n  } catch (e) {\n    expect(e).toMatch('error');\n  }\n});\n"})}),"\n",(0,t.jsxs)(a.p,{children:["Voc\xea pode combinar ",(0,t.jsx)(a.code,{children:"async"})," e ",(0,t.jsx)(a.code,{children:"await"})," com ",(0,t.jsx)(a.code,{children:".resolves"})," ou ",(0,t.jsx)(a.code,{children:".rejects"}),"."]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-js",children:"test('the data is peanut butter', async () => {\n  await expect(fetchData()).resolves.toBe('peanut butter');\n});\n\ntest('the fetch fails with an error', async () => {\n  await expect(fetchData()).rejects.toMatch('error');\n});\n"})}),"\n",(0,t.jsxs)(a.p,{children:["Nestes casos, ",(0,t.jsx)(a.code,{children:"async"})," e ",(0,t.jsx)(a.code,{children:"await"})," s\xe3o efetivamente apenas uma sintaxe mais simples da mesma l\xf3gica dos exemplos de uso de promessas."]}),"\n",(0,t.jsx)(a.admonition,{type:"caution",children:(0,t.jsxs)(a.p,{children:["Be sure to return (or ",(0,t.jsx)(a.code,{children:"await"}),") the promise - if you omit the ",(0,t.jsx)(a.code,{children:"return"}),"/",(0,t.jsx)(a.code,{children:"await"})," statement, your test will complete before the promise returned from ",(0,t.jsx)(a.code,{children:"fetchData"})," resolves or rejects."]})}),"\n",(0,t.jsxs)(a.p,{children:["Se voc\xea espera que a promessa seja rejeitada, use o m\xe9todo ",(0,t.jsx)(a.code,{children:".catch"}),". Se certifique de adicionar ",(0,t.jsx)(a.code,{children:"expect.assertions"})," para verificar que um certo n\xfamero de afirma\xe7\xf5es s\xe3o chamadas. Otherwise, a fulfilled promise would not fail the test."]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-js",children:"test('the fetch fails with an error', () => {\n  expect.assertions(1);\n  return fetchData().catch(e => expect(e).toMatch('error'));\n});\n"})}),"\n",(0,t.jsx)(a.h2,{id:"callbacks",children:"Callbacks"}),"\n",(0,t.jsxs)(a.p,{children:["If you don't use promises, you can use callbacks. For example, let's say that ",(0,t.jsx)(a.code,{children:"fetchData"}),", instead of returning a promise, expects a callback, i.e. fetches some data and calls ",(0,t.jsx)(a.code,{children:"callback(null, data)"})," when it is complete. Voc\xea deseja testar que este dado retornado seja apenas a string ",(0,t.jsx)(a.code,{children:"'peanut butter'"}),"."]}),"\n",(0,t.jsxs)(a.p,{children:["Por padr\xe3o, testes de Jest completam uma vez que eles chegam ao fim da sua execu\xe7\xe3o. Isso significa que este teste ",(0,t.jsx)(a.em,{children:"n\xe3o"})," ir\xe1 funcionar como o esperado:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-js",children:"// N\xe3o fa\xe7a isso!\ntest('the data is peanut butter', () => {\n  function callback(error, data) {\n    if (error) {\n      throw error;\n    }\n    expect(data).toBe('peanut butter');\n  }\n\n  fetchData(callback);\n});\n"})}),"\n",(0,t.jsxs)(a.p,{children:["O problema \xe9 que o teste ser\xe1 conclu\xeddo logo que ",(0,t.jsx)(a.code,{children:"fetchData"}),' completa, antes de sequer chamar a "callback".']}),"\n",(0,t.jsxs)(a.p,{children:["H\xe1 uma forma alternativa de ",(0,t.jsx)(a.code,{children:"test"})," que corrige isto. Em vez de colocar o teste em uma fun\xe7\xe3o com um argumento vazio, use um \xfanico argumento chamado ",(0,t.jsx)(a.code,{children:"done"}),'. Jest aguardar\xe1 at\xe9 que a "callback" ',(0,t.jsx)(a.code,{children:"done"})," \xe9 chamada antes de terminar o teste."]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-js",children:"test('the data is peanut butter', done => {\n  function callback(error, data) {\n    if (error) {\n      done(error);\n      return;\n    }\n    try {\n      expect(data).toBe('peanut butter');\n      done();\n    } catch (error) {\n      done(error);\n    }\n  }\n\n  fetchData(callback);\n});\n"})}),"\n",(0,t.jsxs)(a.p,{children:["Se ",(0,t.jsx)(a.code,{children:"done()"})," nunca for chamado, o teste ir\xe1 falhar (com erro de timeout), que \xe9 o que voc\xea quer que aconte\xe7a."]}),"\n",(0,t.jsxs)(a.p,{children:["Se a instru\xe7\xe3o ",(0,t.jsx)(a.code,{children:"expect"})," falhar, ele lan\xe7a um erro e ",(0,t.jsx)(a.code,{children:"done()"})," n\xe3o \xe9 chamado. Se queremos ver no log de testes por que falhou, precisamos encapsular ",(0,t.jsx)(a.code,{children:"expect"})," em um bloco ",(0,t.jsx)(a.code,{children:"try"})," e passar o erro no bloco ",(0,t.jsx)(a.code,{children:"catch"})," para o ",(0,t.jsx)(a.code,{children:"done"}),". Caso contr\xe1rio, ficamos com um erro de timeout, que n\xe3o mostra o valor recebido por ",(0,t.jsx)(a.code,{children:"expect(data)"}),"."]}),"\n",(0,t.jsx)(a.admonition,{type:"caution",children:(0,t.jsxs)(a.p,{children:["Jest will throw an error, if the same test function is passed a ",(0,t.jsx)(a.code,{children:"done()"})," callback and returns a promise. This is done as a precaution to avoid memory leaks in your tests."]})}),"\n",(0,t.jsxs)(a.h2,{id:"resolves--rejects",children:[(0,t.jsx)(a.code,{children:".resolves"})," / ",(0,t.jsx)(a.code,{children:".rejects"})]}),"\n",(0,t.jsxs)(a.p,{children:['Voc\xea tamb\xe9m pode usar o "matcher" ',(0,t.jsx)(a.code,{children:".resolves"})," em sua declara\xe7\xe3o esperada, e Jest ir\xe1 aguardar a promessa resolver. Se a promessa for rejeitada, o teste automaticamente ir\xe1 falhar."]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-js",children:"test('the data is peanut butter', () => {\n  return expect(fetchData()).resolves.toBe('peanut butter');\n});\n"})}),"\n",(0,t.jsxs)(a.p,{children:["Certifique-se de retornar a afirma\xe7\xe3o \u2014 se voc\xea omitir esta instru\xe7\xe3o de ",(0,t.jsx)(a.code,{children:"retorno"}),", seu teste ser\xe1 conclu\xeddo antes que a promessa retornada de ",(0,t.jsx)(a.code,{children:"fetchData"})," seja resolvida e then() tenha a chance de executar a callback."]}),"\n",(0,t.jsxs)(a.p,{children:['Se voc\xea espera que uma promessa seja rejeitada, use o "matcher" ',(0,t.jsx)(a.code,{children:".rejects"}),'. Ele funciona analogicamente para o "matcher" ',(0,t.jsx)(a.code,{children:".resolves"}),". Se a promessa \xe9 cumprida, o teste automaticamente ir\xe1 falhar."]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-js",children:"test('the fetch fails with an error', () => {\n  return expect(fetchData()).rejects.toMatch('error');\n});\n"})}),"\n",(0,t.jsx)(a.p,{children:"Nenhuma dessas formas \xe9 particularmente superior \xe0s outras, e voc\xea pode misturar e combin\xe1-las atrav\xe9s de uma base de c\xf3digo, ou at\xe9 mesmo em um \xfanico arquivo. Apenas vai depender de qual estilo torna os testes mais simples. S\xf3 depende do estilo que voc\xea sente que torna seus testes mais simples."})]})}const u=function(e={}){const{wrapper:a}=Object.assign({},(0,r.ah)(),e.components);return a?(0,t.jsx)(a,Object.assign({},e,{children:(0,t.jsx)(l,e)})):l(e)}},1670:(e,a,s)=>{s.d(a,{Zo:()=>c,ah:()=>o});var t=s(7378);const r=t.createContext({});function o(e){const a=t.useContext(r);return t.useMemo((()=>"function"==typeof e?e(a):{...a,...e}),[a,e])}const n={};function c({components:e,children:a,disableParentContext:s}){let c;return c=s?"function"==typeof e?e({}):e||n:o(e),t.createElement(r.Provider,{value:c},a)}}}]);