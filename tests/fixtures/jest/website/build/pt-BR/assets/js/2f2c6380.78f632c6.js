"use strict";(self.webpackChunkjest_website=self.webpackChunkjest_website||[]).push([[4366],{2536:(e,s,o)=>{o.r(s),o.d(s,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>c,toc:()=>i});var t=o(4246),n=o(1670);const r={id:"bypassing-module-mocks",title:"Passando pelo m\xf3dulo de mock"},a=void 0,c={unversionedId:"bypassing-module-mocks",id:"bypassing-module-mocks",title:"Passando pelo m\xf3dulo de mock",description:"O Jest permite voc\xea mockar todos os m\xf3dulos sem seus testes, o que pode ser \xfatil para testar se seu c\xf3digo est\xe1 chamando fun\xe7\xf5es daquele m\xf3dulo corretamente. Entretanto, as vezes voc\xea deseja usar partes do m\xf3dulo mockado em seus arquivo de teste, nesse caso voc\xea precisa acessar a implementa\xe7\xe3o original, ao inv\xe9s de uma vers\xe3o mockada.",source:"@site/i18n/pt-BR/docusaurus-plugin-content-docs/current/BypassingModuleMocks.md",sourceDirName:".",slug:"/bypassing-module-mocks",permalink:"/pt-BR/docs/next/bypassing-module-mocks",draft:!1,unlisted:!1,editUrl:"https://crowdin.com/project/jest-v2/pt-BR",tags:[],version:"current",frontMatter:{id:"bypassing-module-mocks",title:"Passando pelo m\xf3dulo de mock"},sidebar:"docs",previous:{title:"Simula\xe7\xe3o de Classes ES6",permalink:"/pt-BR/docs/next/es6-class-mocks"},next:{title:"M\xf3dulos ECMAScript",permalink:"/pt-BR/docs/next/ecmascript-modules"}},d={},i=[];function m(e){const s=Object.assign({p:"p",em:"em",code:"code",pre:"pre"},(0,n.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(s.p,{children:["O Jest permite voc\xea mockar todos os m\xf3dulos sem seus testes, o que pode ser \xfatil para testar se seu c\xf3digo est\xe1 chamando fun\xe7\xf5es daquele m\xf3dulo corretamente. Entretanto, as vezes voc\xea deseja usar partes do m\xf3dulo mockado em seus ",(0,t.jsx)(s.em,{children:"arquivo de teste"}),", nesse caso voc\xea precisa acessar a implementa\xe7\xe3o original, ao inv\xe9s de uma vers\xe3o mockada."]}),"\n",(0,t.jsxs)(s.p,{children:["Considere escrever um caso de testes para a fun\xe7\xe3o ",(0,t.jsx)(s.code,{children:"createUser"}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-javascript",metastring:'title="createUser.js"',children:"import fetch from 'node-fetch';\n\nexport const createUser = async () => {\n  const response = await fetch('https://website.com/users', {method: 'POST'});\n  const userId = await response.text();\n  return userId;\n};\n"})}),"\n",(0,t.jsxs)(s.p,{children:['Seu teste provavelmente ir\xe1 "mockar" (mock) a fun\xe7\xe3o ',(0,t.jsx)(s.code,{children:"fetch"}),' para que possamos ter certeza que esta ser\xe1 chamada sem realmente fazer um request ao endpoint. Contudo, voc\xea tamb\xe9m precisar\xe1 "mockar" o valor de retorno da fun\xe7\xe3o ',(0,t.jsx)(s.code,{children:"fetch"})," com uma ",(0,t.jsx)(s.code,{children:"Response"})," (encapsulada em uma ",(0,t.jsx)(s.code,{children:"Promise"}),"). Ent\xe3o voc\xea pode inicialmente tentar escrever um teste como este:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-javascript",children:"jest.mock('node-fetch');\n\nimport fetch, {Response} from 'node-fetch';\nimport {createUser} from './createUser';\n\ntest('createUser calls fetch with the right args and returns the user id', async () => {\n  fetch.mockReturnValue(Promise.resolve(new Response('4')));\n\n  const userId = await createUser();\n\n  expect(fetch).toHaveBeenCalledTimes(1);\n  expect(fetch).toHaveBeenCalledWith('https://website.com/users', {\n    method: 'POST',\n  });\n  expect(userId).toBe('4');\n});\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Se voc\xea rodar este teste voc\xea ver\xe1 que a fun\xe7\xe3o ",(0,t.jsx)(s.code,{children:"createUser"})," falhar\xe1, disparando a excess\xe3o: ",(0,t.jsx)(s.code,{children:"TypeError: response.text is not a function"}),". Isto porque o ",(0,t.jsx)(s.code,{children:"Response"})," que voc\xea importou de ",(0,t.jsx)(s.code,{children:"node-fetch"}),' foi "mockado" (atrav\xe9s do script ',(0,t.jsx)(s.code,{children:"jest.mock"})," chamado no come\xe7o do arquivo) ent\xe3o n\xe3o se comporta mais como deveria."]}),"\n",(0,t.jsxs)(s.p,{children:["Para contornar problemas como este, Jest fornece o helper ",(0,t.jsx)(s.code,{children:"jest.requireActual"}),". Para fazer o teste acima funcionar, fa\xe7a as seguintes altera\xe7\xf5es aos imports no arquivo de testes:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-javascript",children:"// DEPOIS\njest.mock('node-fetch');\nimport fetch from 'node-fetch';\nconst {Response} = jest.requireActual('node-fetch');\n"})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-javascript",children:"// DEPOIS\njest.mock('node-fetch');\nimport fetch from 'node-fetch';\nconst {Response} = jest.requireActual('node-fetch');\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Isto permite que seu arquivo de testes importe o objeto ",(0,t.jsx)(s.code,{children:"Response"})," de ",(0,t.jsx)(s.code,{children:"node-fetch"}),', em vez da vers\xe3o "mockada". Isto quer dizer que o teste agora passar\xe1 corretamente.']})]})}const u=function(e={}){const{wrapper:s}=Object.assign({},(0,n.ah)(),e.components);return s?(0,t.jsx)(s,Object.assign({},e,{children:(0,t.jsx)(m,e)})):m(e)}},1670:(e,s,o)=>{o.d(s,{Zo:()=>c,ah:()=>r});var t=o(7378);const n=t.createContext({});function r(e){const s=t.useContext(n);return t.useMemo((()=>"function"==typeof e?e(s):{...s,...e}),[s,e])}const a={};function c({components:e,children:s,disableParentContext:o}){let c;return c=o?"function"==typeof e?e({}):e||a:r(e),t.createElement(n.Provider,{value:c},s)}}}]);