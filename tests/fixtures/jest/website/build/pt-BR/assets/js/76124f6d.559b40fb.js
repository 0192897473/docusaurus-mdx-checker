"use strict";(self.webpackChunkjest_website=self.webpackChunkjest_website||[]).push([[1074],{8910:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>m,frontMatter:()=>s,metadata:()=>r,toc:()=>i});var t=o(4246),a=o(1670);const s={id:"mock-functions",title:"Fun\xe7\xf5es de Simula\xe7\xe3o"},c=void 0,r={unversionedId:"mock-functions",id:"mock-functions",title:"Fun\xe7\xf5es de Simula\xe7\xe3o",description:"Fun\xe7\xf5es de simula\xe7\xe3o ( mocks em ingl\xeas ) permitem que voc\xea teste os links entre c\xf3digos, apagando a implementa\xe7\xe3o real de uma fun\xe7\xe3o, capturando chamadas para a fun\xe7\xe3o (e os par\xe2metros passados nessas chamadas), capturar inst\xe2ncias do construtor de fun\xe7\xf5es quando instanciado com new, e permitindo configura\xe7\xe3o em tempo de teste de valores de retorno.",source:"@site/i18n/pt-BR/docusaurus-plugin-content-docs/current/MockFunctions.md",sourceDirName:".",slug:"/mock-functions",permalink:"/pt-BR/docs/next/mock-functions",draft:!1,unlisted:!1,editUrl:"https://crowdin.com/project/jest-v2/pt-BR",tags:[],version:"current",frontMatter:{id:"mock-functions",title:"Fun\xe7\xf5es de Simula\xe7\xe3o"},sidebar:"docs",previous:{title:"Configura\xe7\xe3o e Desmontagem",permalink:"/pt-BR/docs/next/setup-teardown"},next:{title:"Plataforma Jest",permalink:"/pt-BR/docs/next/jest-platform"}},l={},i=[{value:"Usando uma fun\xe7\xe3o de simula\xe7\xe3o",id:"usando-uma-fun\xe7\xe3o-de-simula\xe7\xe3o",level:2},{value:"Propriedade <code>.mock</code>",id:"propriedade-mock",level:2},{value:"Mock Valores de Retorno",id:"mock-valores-de-retorno",level:2},{value:"Simulando m\xf3dulos",id:"simulando-m\xf3dulos",level:2},{value:"Mocking Partials",id:"mocking-partials",level:2},{value:"Implementa\xe7\xf5es de Mock",id:"implementa\xe7\xf5es-de-mock",level:2},{value:"Nome das fun\xe7\xf5es de simula\xe7\xe3o (Mock names)",id:"nome-das-fun\xe7\xf5es-de-simula\xe7\xe3o-mock-names",level:2},{value:"Matchers personalizados",id:"matchers-personalizados",level:2}];function d(e){const n=Object.assign({p:"p",code:"code",a:"a",h2:"h2",pre:"pre"},(0,a.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Fun\xe7\xf5es de simula\xe7\xe3o ( mocks em ingl\xeas ) permitem que voc\xea teste os links entre c\xf3digos, apagando a implementa\xe7\xe3o real de uma fun\xe7\xe3o, capturando chamadas para a fun\xe7\xe3o (e os par\xe2metros passados nessas chamadas), capturar inst\xe2ncias do construtor de fun\xe7\xf5es quando instanciado com ",(0,t.jsx)(n.code,{children:"new"}),", e permitindo configura\xe7\xe3o em tempo de teste de valores de retorno."]}),"\n",(0,t.jsxs)(n.p,{children:["Existem duas maneiras de simular fun\xe7\xf5es: Seja criando uma fun\xe7\xe3o simulada para usar no c\xf3digo de teste, ou escrevendo uma ",(0,t.jsx)(n.a,{href:"ManuaalMocks.md",children:(0,t.jsx)(n.code,{children:"simula\xe7\xe3o manual"})})," para sobrescrever uma depend\xeancia de modulo."]}),"\n",(0,t.jsx)(n.h2,{id:"usando-uma-fun\xe7\xe3o-de-simula\xe7\xe3o",children:"Usando uma fun\xe7\xe3o de simula\xe7\xe3o"}),"\n",(0,t.jsxs)(n.p,{children:["Vamos imaginar que estamos testando uma implementa\xe7\xe3o de uma fun\xe7\xe3o ",(0,t.jsx)(n.code,{children:"forEach"}),', que invoca uma "callback" para cada item em um array fornecido.']}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:'title="forEach.js"',children:"export function forEach(items, callback) {\n  for (let index = 0; index < items.length; index++) {\n    callback(items[index]);\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:'Para testar esta fun\xe7\xe3o, podemos usar uma fun\xe7\xe3o de simula\xe7\xe3o e inspecionar o estado da simula\xe7\xe3o para garantir que a "callback" \xe9 invocada como esperado.'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:'title="forEach.test.js"',children:"const forEach = require('./forEach');\n\nconst mockCallback = jest.fn(x => 42 + x);\n\ntest('forEach mock function', () => {\n  forEach([0, 1], mockCallback);\n\n  // The mock function was called twice\n  expect(mockCallback.mock.calls).toHaveLength(2);\n\n  // The first argument of the first call to the function was 0\n  expect(mockCallback.mock.calls[0][0]).toBe(0);\n\n  // The first argument of the second call to the function was 1\n  expect(mockCallback.mock.calls[1][0]).toBe(1);\n\n  // The return value of the first call to the function was 42\n  expect(mockCallback.mock.results[0].value).toBe(42);\n});\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"propriedade-mock",children:["Propriedade ",(0,t.jsx)(n.code,{children:".mock"})]}),"\n",(0,t.jsxs)(n.p,{children:["Todas as fun\xe7\xf5es de simula\xe7\xe3o (.mock) possuem esta especial propriedade ",(0,t.jsx)(n.code,{children:".mock, que \xe9 onde os dados sobre como a fun\xe7\xe3o   a qual foi chamada s\xe3o mantidos. A propriedade <code>.mock"})," tamb\xe9m pode rastrear o valor do ",(0,t.jsx)(n.code,{children:"this"})," para cada chamada, ent\xe3o \xe9 poss\xedvel inspecionar isso tamb\xe9m:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const myMock1 = jest.fn();\nconst a = new myMock1();\nconsole.log(myMock1.mock.instances);\n// > [ <a> ]\n\nconst myMock2 = jest.fn();\nconst b = {};\nconst bound = myMock2.bind(b);\nbound();\nconsole.log(myMock2.mock.contexts);\n// > [ <b> ]\n"})}),"\n",(0,t.jsx)(n.p,{children:"As fun\xe7\xf5es de simula\xe7\xe3o (mock) s\xe3o muito \xfateis nos testes permitindo a verifica\xe7\xe3o de como essas fun\xe7\xf5es ent\xe3o sendo chamadas, instanciadas, ou o que retornam:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// The function was called exactly once\nexpect(someMockFunction.mock.calls).toHaveLength(1);\n\n// The first arg of the first call to the function was 'first arg'\nexpect(someMockFunction.mock.calls[0][0]).toBe('first arg');\n\n// The second arg of the first call to the function was 'second arg'\nexpect(someMockFunction.mock.calls[0][1]).toBe('second arg');\n\n// The return value of the first call to the function was 'return value'\nexpect(someMockFunction.mock.results[0].value).toBe('return value');\n\n// The function was called with a certain `this` context: the `element` object.\nexpect(someMockFunction.mock.contexts[0]).toBe(element);\n\n// This function was instantiated exactly twice\nexpect(someMockFunction.mock.instances.length).toBe(2);\n\n// The object returned by the first instantiation of this function\n// had a `name` property whose value was set to 'test'\nexpect(someMockFunction.mock.instances[0].name).toBe('test');\n\n// The first argument of the last call to the function was 'test'\nexpect(someMockFunction.mock.lastCall[0]).toBe('test');\n"})}),"\n",(0,t.jsx)(n.h2,{id:"mock-valores-de-retorno",children:"Mock Valores de Retorno"}),"\n",(0,t.jsx)(n.p,{children:"Mock functions can also be used to inject test values into your code during a test:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const myMock = jest.fn();\nconsole.log(myMock());\n// > undefined\n\nmyMock.mockReturnValueOnce(10).mockReturnValueOnce('x').mockReturnValue(true);\n\nconsole.log(myMock(), myMock(), myMock(), myMock());\n// > 10, 'x', true, true\n"})}),"\n",(0,t.jsx)(n.p,{children:"Mock functions are also very effective in code that uses a functional continuation-passing style. Code written in this style helps avoid the need for complicated stubs that recreate the behavior of the real component they're standing in for, in favor of injecting values directly into the test right before they're used."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const filterTestFn = jest.fn();\n\n// Make the mock return `true` for the first call,\n// and `false` for the second call\nfilterTestFn.mockReturnValueOnce(true).mockReturnValueOnce(false);\n\nconst result = [11, 12].filter(num => filterTestFn(num));\n\nconsole.log(result);\n// > [11]\nconsole.log(filterTestFn.mock.calls[0][0]); // 11\nconsole.log(filterTestFn.mock.calls[1][0]); // 12\n"})}),"\n",(0,t.jsx)(n.p,{children:"Most real-world examples actually involve getting ahold of a mock function on a dependent component and configuring that, but the technique is the same. In these cases, try to avoid the temptation to implement logic inside of any function that's not directly being tested."}),"\n",(0,t.jsx)(n.h2,{id:"simulando-m\xf3dulos",children:"Simulando m\xf3dulos"}),"\n",(0,t.jsxs)(n.p,{children:["Vamos supor que temos uma classe que traz usu\xe1rios da nossa API. A classe usa ",(0,t.jsx)(n.a,{href:"https://github.com/axios/axios",children:"axios"})," para chamar a API, e ent\xe3o retorna o atributo ",(0,t.jsx)(n.code,{children:"data"})," onde cont\xe9m todos os usu\xe1rios:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:'title="users.js"',children:"import axios from 'axios';\n\nclass Users {\n  static all() {\n    return axios.get('/users.json').then(resp => resp.data);\n  }\n}\n\nexport default Users;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Agora, para testar este m\xe9todo sem consumir a API (e assim, criando testes lentos e fr\xe1geis), n\xf3s podemos usar a fun\xe7\xe3o ",(0,t.jsx)(n.code,{children:"jest.mock(...)"})," para simular automaticamente o m\xf3dulo do axios."]}),"\n",(0,t.jsxs)(n.p,{children:["Assim que simulamos o m\xf3dulo, podemos fornecer uma ",(0,t.jsx)(n.code,{children:" mockResolvedValue"})," para o ",(0,t.jsx)(n.code,{children:".get"})," que retorna os dados que queremos que nosso teste afirme contra. Assim, estamos dizendo que queremos que o ",(0,t.jsx)(n.code,{children:"axios.get('/users.json')"})," retorne uma resposta falsa."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:'title="users.test.js"',children:"import axios from 'axios';\nimport Users from './users';\n\njest.mock('axios');\n\ntest('deve buscar os usu\xe1rios', () => {\n  const users = [{name: 'Bob'}];\n  const resp = {data: users};\n  axios.get.mockResolvedValue(resp);\n\n  // ou voc\xea poder\xe1 usar o c\xf3digo abaixo dependendo do seu caso de uso: \n  // axios.get.mockImplementation(() => Promise.resolve(resp))\n\n  return Users.all().then(data => expect(data).toEqual(users));\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"mocking-partials",children:"Mocking Partials"}),"\n",(0,t.jsx)(n.p,{children:"Subsets of a module can be mocked and the rest of the module can keep their actual implementation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:'title="foo-bar-baz.js"',children:"export const foo = 'foo';\nexport const bar = () => 'bar';\nexport default () => 'baz';\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"//test.js\nimport defaultExport, {bar, foo} from '../foo-bar-baz';\n\njest.mock('../foo-bar-baz', () => {\n  const originalModule = jest.requireActual('../foo-bar-baz');\n\n  //Mock the default export and named export 'foo'\n  return {\n    __esModule: true,\n    ...originalModule,\n    default: jest.fn(() => 'mocked baz'),\n    foo: 'mocked foo',\n  };\n});\n\ntest('should do a partial mock', () => {\n  const defaultExportResult = defaultExport();\n  expect(defaultExportResult).toBe('mocked baz');\n  expect(defaultExport).toHaveBeenCalled();\n\n  expect(foo).toBe('mocked foo');\n  expect(bar()).toBe('bar');\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"implementa\xe7\xf5es-de-mock",children:"Implementa\xe7\xf5es de Mock"}),"\n",(0,t.jsxs)(n.p,{children:["Still, there are cases where it's useful to go beyond the ability to specify return values and full-on replace the implementation of a mock function. This can be done with ",(0,t.jsx)(n.code,{children:"jest.fn"})," or the ",(0,t.jsx)(n.code,{children:"mockImplementationOnce"})," method on mock functions."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const myMockFn = jest.fn(cb => cb(null, true));\n\nmyMockFn((err, val) => console.log(val));\n// > true\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"mockImplementation"})," method is useful when you need to define the default implementation of a mock function that is created from another module:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:'title="foo.js"',children:"module.exports = function () {\n  // some implementation;\n};\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:'title="test.js"',children:"jest.mock('../foo'); // this happens automatically with automocking\nconst foo = require('../foo');\n\n// foo is a mock function\nfoo.mockImplementation(() => 42);\nfoo();\n// > 42\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When you need to recreate a complex behavior of a mock function such that multiple function calls produce different results, use the ",(0,t.jsx)(n.code,{children:"mockImplementationOnce"})," method:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const myMockFn = jest\n  .fn()\n  .mockImplementationOnce(cb => cb(null, true))\n  .mockImplementationOnce(cb => cb(null, false));\n\nmyMockFn((err, val) => console.log(val));\n// > true\n\nmyMockFn((err, val) => console.log(val));\n// > false\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When the mocked function runs out of implementations defined with ",(0,t.jsx)(n.code,{children:"mockImplementationOnce"}),", it will execute the default implementation set with ",(0,t.jsx)(n.code,{children:"jest.fn"})," (if it is defined):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const myMockFn = jest\n  .fn(() => 'default')\n  .mockImplementationOnce(() => 'first call')\n  .mockImplementationOnce(() => 'second call');\n\nconsole.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());\n// > 'first call', 'second call', 'default', 'default'\n"})}),"\n",(0,t.jsxs)(n.p,{children:["For cases where we have methods that are typically chained (and thus always need to return ",(0,t.jsx)(n.code,{children:"this"}),"), we have a sugary API to simplify this in the form of a ",(0,t.jsx)(n.code,{children:".mockReturnThis()"})," function that also sits on all mocks:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const myObj = {\n  myMethod: jest.fn().mockReturnThis(),\n};\n\n// is the same as\n\nconst otherObj = {\n  myMethod: jest.fn(function () {\n    return this;\n  }),\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"nome-das-fun\xe7\xf5es-de-simula\xe7\xe3o-mock-names",children:"Nome das fun\xe7\xf5es de simula\xe7\xe3o (Mock names)"}),"\n",(0,t.jsxs)(n.p,{children:["You can optionally provide a name for your mock functions, which will be displayed instead of ",(0,t.jsx)(n.code,{children:"'jest.fn()'"})," in the test error output. Use ",(0,t.jsx)(n.a,{href:"MockFunctionAPI.md/#mockfnmocknamename",children:(0,t.jsx)(n.code,{children:".mockName()"})})," if you want to be able to quickly identify the mock function reporting an error in your test output."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const myMockFn = jest\n  .fn()\n  .mockReturnValue('default')\n  .mockImplementation(scalar => 42 + scalar)\n  .mockName('add42');\n"})}),"\n",(0,t.jsx)(n.h2,{id:"matchers-personalizados",children:"Matchers personalizados"}),"\n",(0,t.jsx)(n.p,{children:"Finally, in order to make it less demanding to assert how mock functions have been called, we've added some custom matcher functions for you:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// The mock function was called at least once\nexpect(mockFunc).toHaveBeenCalled();\n\n// The mock function was called at least once with the specified args\nexpect(mockFunc).toHaveBeenCalledWith(arg1, arg2);\n\n// The last call to the mock function was called with the specified args\nexpect(mockFunc).toHaveBeenLastCalledWith(arg1, arg2);\n\n// All calls and the name of the mock is written as a snapshot\nexpect(mockFunc).toMatchSnapshot();\n"})}),"\n",(0,t.jsxs)(n.p,{children:["These matchers are sugar for common forms of inspecting the ",(0,t.jsx)(n.code,{children:".mock"})," property. You can always do this manually yourself if that's more to your taste or if you need to do something more specific:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// The mock function was called at least once\nexpect(mockFunc.mock.calls.length).toBeGreaterThan(0);\n\n// The mock function was called at least once with the specified args\nexpect(mockFunc.mock.calls).toContainEqual([arg1, arg2]);\n\n// The last call to the mock function was called with the specified args\nexpect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1]).toEqual([\n  arg1,\n  arg2,\n]);\n\n// The first arg of the last call to the mock function was `42`\n// (note that there is no sugar helper for this specific of an assertion)\nexpect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1][0]).toBe(42);\n\n// A snapshot will check that a mock was invoked the same number of times,\n// in the same order, with the same arguments. Ele tamb\xe9m ir\xe1 testar o nome da fun\xe7\xe3o de simula\xe7\xe3o.\nexpect(mockFunc.mock.calls).toEqual([[arg1, arg2]]);\nexpect(mockFunc.getMockName()).toBe('a mock name');\n"})}),"\n",(0,t.jsxs)(n.p,{children:['Para obter uma lista completa de "matchers", confira a ',(0,t.jsx)(n.a,{href:"/pt-BR/docs/next/expect",children:"documenta\xe7\xe3o de refer\xeancia"}),"."]})]})}const m=function(e={}){const{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(d,e)})):d(e)}},1670:(e,n,o)=>{o.d(n,{Zo:()=>r,ah:()=>s});var t=o(7378);const a=t.createContext({});function s(e){const n=t.useContext(a);return t.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}const c={};function r({components:e,children:n,disableParentContext:o}){let r;return r=o?"function"==typeof e?e({}):e||c:s(e),t.createElement(a.Provider,{value:r},n)}}}]);