"use strict";(self.webpackChunkjest_website=self.webpackChunkjest_website||[]).push([[1549],{6111:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>x,frontMatter:()=>d,metadata:()=>h,toc:()=>p});var s=t(4246),o=t(1670),a=t(8447),r=t(2599),i=t(2353),c=t(6294);const d={id:"expect",title:"Expect"},l=void 0,h={unversionedId:"expect",id:"version-29.6/expect",title:"Expect",description:'Quando voc\xea est\xe1 escrevendo testes, geralmente precisa verificar se os valores atendem a certas condi\xe7\xf5es. expect lhe d\xe1 acesso a in\xfameros "matchers" que permitem validar diferentes coisas.',source:"@site/i18n/pt-BR/docusaurus-plugin-content-docs/version-29.6/ExpectAPI.md",sourceDirName:".",slug:"/expect",permalink:"/pt-BR/docs/expect",draft:!1,unlisted:!1,editUrl:"https://crowdin.com/project/jest-v2/pt-BR",tags:[],version:"29.6",frontMatter:{id:"expect",title:"Expect"},sidebar:"api",previous:{title:"Globais",permalink:"/pt-BR/docs/api"},next:{title:"Fun\xe7\xf5es de Simula\xe7\xe3o",permalink:"/pt-BR/docs/mock-function-api"}},u={},p=[{value:"Refer\xeancia",id:"refer\xeancia",level:2},{value:"Expect",id:"expect",level:2},{value:"<code>expect(value)</code>",id:"expectvalue",level:3},{value:"Modifiers",id:"modifiers",level:2},{value:"<code>.not</code>",id:"not",level:3},{value:"<code>.resolves</code>",id:"resolves",level:3},{value:"<code>.rejects</code>",id:"rejects",level:3},{value:"Matchers",id:"matchers",level:2},{value:"<code>.toBe(value)</code>",id:"tobevalue",level:3},{value:"<code>.toHaveBeenCalled()</code>",id:"tohavebeencalled",level:3},{value:"<code>.toHaveBeenCalledTimes(number)</code>",id:"tohavebeencalledtimesnumber",level:3},{value:"<code>.toHaveBeenCalledWith(arg1, arg2, ...)</code>",id:"tohavebeencalledwitharg1-arg2-",level:3},{value:"<code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code>",id:"tohavebeenlastcalledwitharg1-arg2-",level:3},{value:"<code>.toHaveBeenNthCalledWith(nthCall, arg1, arg2, ....)</code>",id:"tohavebeennthcalledwithnthcall-arg1-arg2-",level:3},{value:"<code>.toHaveReturned()</code>",id:"tohavereturned",level:3},{value:"<code>.toHaveReturnedTimes(number)</code>",id:"tohavereturnedtimesnumber",level:3},{value:"<code>.toHaveReturnedWith(value)</code>",id:"tohavereturnedwithvalue",level:3},{value:"<code>.toHaveLastReturnedWith(value)</code>",id:"tohavelastreturnedwithvalue",level:3},{value:"<code>.toHaveNthReturnedWith(nthCall, value)</code>",id:"tohaventhreturnedwithnthcall-value",level:3},{value:"<code>.toHaveLength(number)</code>",id:"tohavelengthnumber",level:3},{value:"<code>.toHaveProperty(keyPath, value?)</code>",id:"tohavepropertykeypath-value",level:3},{value:"<code>.toBeCloseTo(number, numDigits?)</code>",id:"tobeclosetonumber-numdigits",level:3},{value:"<code>.toBeDefined()</code>",id:"tobedefined",level:3},{value:"<code>.toBeFalsy()</code>",id:"tobefalsy",level:3},{value:"<code>.toBeGreaterThan(number | bigint)</code>",id:"tobegreaterthannumber--bigint",level:3},{value:"<code>.toBeGreaterThanOrEqual(number | bigint)</code>",id:"tobegreaterthanorequalnumber--bigint",level:3},{value:"<code>.toBeLessThan(number | bigint)</code>",id:"tobelessthannumber--bigint",level:3},{value:"<code>.toBeLessThanOrEqual(number | bigint)</code>",id:"tobelessthanorequalnumber--bigint",level:3},{value:"<code>.toBeInstanceOf(Class)</code>",id:"tobeinstanceofclass",level:3},{value:"<code>.toBeNull()</code>",id:"tobenull",level:3},{value:"<code>.toBeTruthy()</code>",id:"tobetruthy",level:3},{value:"<code>.toBeUndefined()</code>",id:"tobeundefined",level:3},{value:"<code>.toBeNaN()</code>",id:"tobenan",level:3},{value:"<code>.toContain(item)</code>",id:"tocontainitem",level:3},{value:"<code>.toContainEqual(item)</code>",id:"tocontainequalitem",level:3},{value:"<code>.toEqual(value)</code>",id:"toequalvalue",level:3},{value:"<code>.toMatch(regexp | string)</code>",id:"tomatchregexp--string",level:3},{value:"<code>.toMatchObject(object)</code>",id:"tomatchobjectobject",level:3},{value:"<code>.toMatchSnapshot(propertyMatchers?, hint?)</code>",id:"tomatchsnapshotpropertymatchers-hint",level:3},{value:"<code>.toMatchInlineSnapshot(propertyMatchers?, inlineSnapshot)</code>",id:"tomatchinlinesnapshotpropertymatchers-inlinesnapshot",level:3},{value:"<code>.toStrictEqual(value)</code>",id:"tostrictequalvalue",level:3},{value:"<code>.toThrow(error?)</code>",id:"tothrowerror",level:3},{value:"<code>.toThrowErrorMatchingSnapshot(hint?)</code>",id:"tothrowerrormatchingsnapshothint",level:3},{value:"<code>.toThrowErrorMatchingInlineSnapshot(inlineSnapshot)</code>",id:"tothrowerrormatchinginlinesnapshotinlinesnapshot",level:3},{value:"Asymmetric Matchers",id:"asymmetric-matchers",level:2},{value:"<code>expect.anything()</code>",id:"expectanything",level:3},{value:"<code>expect.any(constructor)</code>",id:"expectanyconstructor",level:3},{value:"<code>expect.arrayContaining(array)</code>",id:"expectarraycontainingarray",level:3},{value:"<code>expect.not.arrayContaining(array)</code>",id:"expectnotarraycontainingarray",level:3},{value:"<code>expect.closeTo(number, numDigits?)</code>",id:"expectclosetonumber-numdigits",level:3},{value:"<code>expect.objectContaining(object)</code>",id:"expectobjectcontainingobject",level:3},{value:"<code>expect.not.objectContaining(object)</code>",id:"expectnotobjectcontainingobject",level:3},{value:"<code>expect.stringContaining(string)</code>",id:"expectstringcontainingstring",level:3},{value:"<code>expect.not.stringContaining(string)</code>",id:"expectnotstringcontainingstring",level:3},{value:"<code>expect.stringMatching(string | regexp)</code>",id:"expectstringmatchingstring--regexp",level:3},{value:"<code>expect.not.stringMatching(string | regexp)</code>",id:"expectnotstringmatchingstring--regexp",level:3},{value:"Assertion Count",id:"assertion-count",level:2},{value:"<code>expect.assertions(number)</code>",id:"expectassertionsnumber",level:3},{value:"<code>expect.hasAssertions()</code>",id:"expecthasassertions",level:3},{value:"Extend Utilities",id:"extend-utilities",level:2},{value:"<code>expect.addEqualityTesters(testers)</code>",id:"expectaddequalitytesterstesters",level:3},{value:"Custom equality testers API",id:"custom-equality-testers-api",level:4},{value:"<code>this.equals(a, b, customTesters?)</code>",id:"thisequalsa-b-customtesters",level:4},{value:"Matchers vs Testers",id:"matchers-vs-testers",level:4},{value:"Recursive custom equality testers",id:"recursive-custom-equality-testers",level:4},{value:"<code>expect.addSnapshotSerializer(serializer)</code>",id:"expectaddsnapshotserializerserializer",level:3},{value:"<code>expect.extend(matchers)</code>",id:"expectextendmatchers",level:3},{value:"Async Matchers",id:"async-matchers",level:4},{value:"Custom Matchers API",id:"custom-matchers-api",level:4},{value:"<code>this.isNot</code>",id:"thisisnot",level:4},{value:"<code>this.promise</code>",id:"thispromise",level:4},{value:"<code>this.equals(a, b, customTesters?)</code>",id:"thisequalsa-b-customtesters-1",level:4},{value:"<code>this.expand</code>",id:"thisexpand",level:4},{value:"<code>this.utils</code>",id:"thisutils",level:4},{value:"<code>this.customTesters</code>",id:"thiscustomtesters",level:4},{value:"Custom snapshot matchers",id:"custom-snapshot-matchers",level:4},{value:"async",id:"async",level:4},{value:"Bail out",id:"bail-out",level:4}];function m(e){const n=Object.assign({p:"p",code:"code",admonition:"admonition",a:"a",h2:"h2",hr:"hr",h3:"h3",pre:"pre",strong:"strong",ul:"ul",li:"li",em:"em",h4:"h4"},(0,o.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Quando voc\xea est\xe1 escrevendo testes, geralmente precisa verificar se os valores atendem a certas condi\xe7\xf5es. ",(0,s.jsx)(n.code,{children:"expect"}),' lhe d\xe1 acesso a in\xfameros "matchers" que permitem validar diferentes coisas.']}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:['Outros "matchers" mantidos pela Comunidade Jest podem ser encontrados em ',(0,s.jsx)(n.a,{href:"https://github.com/jest-community/jest-extended",children:(0,s.jsx)(n.code,{children:"jest-extended"})}),"."]})}),"\n","\n",(0,s.jsx)(i.ZP,{}),"\n",(0,s.jsx)(n.h2,{id:"refer\xeancia",children:"Refer\xeancia"}),"\n","\n","\n",(0,s.jsx)(c.Z,{toc:p.slice(1)}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"expect",children:"Expect"}),"\n",(0,s.jsx)(n.h3,{id:"expectvalue",children:(0,s.jsx)(n.code,{children:"expect(value)"})}),"\n",(0,s.jsxs)(n.p,{children:["A fun\xe7\xe3o ",(0,s.jsx)(n.code,{children:"expect"})," \xe9 usada toda vez que voc\xea quer testar um valor. Voc\xea raramente ir\xe1 usar o ",(0,s.jsx)(n.code,{children:"expect"})," sozinho. Em vez disso, voc\xea ir\xe1 usar ",(0,s.jsx)(n.code,{children:"expect"}),' junto com uma fun\xe7\xe3o "matcher" para verificar algo sobre um valor.']}),"\n",(0,s.jsxs)(n.p,{children:["\xc9 mais f\xe1cil de entender isto com um exemplo. Digamos que voc\xea tenha um m\xe9todo ",(0,s.jsx)(n.code,{children:"bestLaCroixFlavor()"})," que se espera retornar a string ",(0,s.jsx)(n.code,{children:"'grapefruit'"}),". Veja como voc\xea testaria isso:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('the best flavor is grapefruit', () => {\n  expect(bestLaCroixFlavor()).toBe('grapefruit');\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Neste caso, ",(0,s.jsx)(n.code,{children:"toBe"}),' \xe9 a fun\xe7\xe3o "matcher". Existem muitas fun\xe7\xf5es "matcher" diferentes, documentadas abaixo, para ajuda-lo a testar coisas diferentes.']}),"\n",(0,s.jsxs)(n.p,{children:["O argumento para ",(0,s.jsx)(n.code,{children:"expect"})," deve ser o valor que o seu c\xf3digo produz, e qualquer argumento para o matcher deve ser o valor correto esperado. Se voc\xea mistur\xe1-los, os testes ainda ir\xe3o funcionar, mas as mensagens de erro em testes que falharem v\xe3o parecer estranhas."]}),"\n",(0,s.jsx)(n.h2,{id:"modifiers",children:"Modifiers"}),"\n",(0,s.jsx)(n.h3,{id:"not",children:(0,s.jsx)(n.code,{children:".not"})}),"\n",(0,s.jsxs)(n.p,{children:["Se voc\xea sabe como testar algo, ",(0,s.jsx)(n.code,{children:".not"}),' permite que voc\xea teste seu oposto. Por exemplo, este c\xf3digo testa que o melhor sabor da La Croix n\xe3o \xe9 "coconut":']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('the best flavor is not coconut', () => {\n  expect(bestLaCroixFlavor()).not.toBe('coconut');\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"resolves",children:(0,s.jsx)(n.code,{children:".resolves"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"resolves"})," para decodificar o valor de uma promessa cumprida, para que qualquer outro matcher possa ent\xe3o ser encadeado. Se a promessa for rejeitada a verifica\xe7\xe3o falhar\xe1."]}),"\n",(0,s.jsxs)(n.p,{children:["Por exemplo, este c\xf3digo de testes que a promessa resolve e que o valor resultante \xe9 ",(0,s.jsx)(n.code,{children:"'lemon'"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('resolves to lemon', () => {\n  // make sure to add a return statement\n  return expect(Promise.resolve('lemon')).resolves.toBe('lemon');\n});\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["Since you are still testing promises, the test is still asynchronous. Hence, you will need to ",(0,s.jsx)(n.a,{href:"/pt-BR/docs/asynchronous#promises",children:"tell Jest to wait"})," by returning the unwrapped assertion."]}),(0,s.jsxs)(n.p,{children:["Como alternativa, voc\xea pode usar ",(0,s.jsx)(n.code,{children:"async/await"})," em combina\xe7\xe3o com ",(0,s.jsx)(n.code,{children:".resolves"}),":"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('resolves to lemon', async () => {\n  await expect(Promise.resolve('lemon')).resolves.toBe('lemon');\n  await expect(Promise.resolve('lemon')).resolves.not.toBe('octopus');\n});\n"})})]}),"\n",(0,s.jsx)(n.h3,{id:"rejects",children:(0,s.jsx)(n.code,{children:".rejects"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".rejects"})," para decodificar o motivo de uma promessa rejeitada, para que qualquer outro matcher possa ser encadeado. Se a promessa \xe9 cumprida a verifica\xe7\xe3o falhar\xe1."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, this code tests that the promise rejects with reason ",(0,s.jsx)(n.code,{children:"'octopus'"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('rejects to octopus', () => {\n  // make sure to add a return statement\n  return expect(Promise.reject(new Error('octopus'))).rejects.toThrow(\n    'octopus',\n  );\n});\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["Since you are still testing promises, the test is still asynchronous. Hence, you will need to ",(0,s.jsx)(n.a,{href:"/pt-BR/docs/asynchronous#promises",children:"tell Jest to wait"})," by returning the unwrapped assertion."]}),(0,s.jsxs)(n.p,{children:["Alternatively, you can use ",(0,s.jsx)(n.code,{children:"async/await"})," in combination with ",(0,s.jsx)(n.code,{children:".rejects"}),"."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('rejects to octopus', async () => {\n  await expect(Promise.reject(new Error('octopus'))).rejects.toThrow('octopus');\n});\n"})})]}),"\n",(0,s.jsx)(n.h2,{id:"matchers",children:"Matchers"}),"\n",(0,s.jsx)(n.h3,{id:"tobevalue",children:(0,s.jsx)(n.code,{children:".toBe(value)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toBe"})," to compare primitive values or to check referential identity of object instances. It calls ",(0,s.jsx)(n.code,{children:"Object.is"})," to compare values, which is even better for testing than ",(0,s.jsx)(n.code,{children:"==="})," strict equality operator."]}),"\n",(0,s.jsxs)(n.p,{children:["Por exemplo, este c\xf3digo ir\xe1 validar algumas propriedades do objeto ",(0,s.jsx)(n.code,{children:"can"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const can = {\n  name: 'pamplemousse',\n  ounces: 12,\n};\n\ndescribe('the can', () => {\n  test('has 12 ounces', () => {\n    expect(can.ounces).toBe(12);\n  });\n\n  test('has a sophisticated name', () => {\n    expect(can.name).toBe('pamplemousse');\n  });\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Don't use ",(0,s.jsx)(n.code,{children:".toBe"})," with floating-point numbers. Por exemplo, devido a arredondamentos, em JavaScript ",(0,s.jsx)(n.code,{children:"0.2 + 0.1"})," n\xe3o \xe9 estritamente igual a ",(0,s.jsx)(n.code,{children:"0.3"}),". Se voc\xea tem n\xfameros de ponto flutuante, tente usar de prefer\xeancia ",(0,s.jsx)(n.code,{children:".toBeCloseTo"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Although the ",(0,s.jsx)(n.code,{children:".toBe"})," matcher ",(0,s.jsx)(n.strong,{children:"checks"})," referential identity, it ",(0,s.jsx)(n.strong,{children:"reports"})," a deep comparison of values if the assertion fails. If differences between properties do not help you to understand why a test fails, especially if the report is large, then you might move the comparison into the ",(0,s.jsx)(n.code,{children:"expect"})," function. For example, to assert whether or not elements are the same instance:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["rewrite ",(0,s.jsx)(n.code,{children:"expect(received).toBe(expected)"})," as ",(0,s.jsx)(n.code,{children:"expect(Object.is(received, expected)).toBe(true)"})]}),"\n",(0,s.jsxs)(n.li,{children:["rewrite ",(0,s.jsx)(n.code,{children:"expect(received).not.toBe(expected)"})," as ",(0,s.jsx)(n.code,{children:"expect(Object.is(received, expected)).toBe(false)"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"tohavebeencalled",children:(0,s.jsx)(n.code,{children:".toHaveBeenCalled()"})}),"\n",(0,s.jsxs)(n.p,{children:["Tamb\xe9m sob o pseud\xf4nimo: ",(0,s.jsx)(n.code,{children:".toBeCalled()"})]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toHaveBeenCalledWith"})," para garantir que uma fun\xe7\xe3o de simula\xe7\xe3o (mock, em ingl\xeas) foi chamada com argumentos espec\xedficos. The arguments are checked with the same algorithm that ",(0,s.jsx)(n.code,{children:".toEqual"})," uses."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's say you have a ",(0,s.jsx)(n.code,{children:"drinkAll(drink, flavour)"})," function that takes a ",(0,s.jsx)(n.code,{children:"drink"})," function and applies it to all available beverages. You might want to check that ",(0,s.jsx)(n.code,{children:"drink"})," gets called for ",(0,s.jsx)(n.code,{children:"'lemon'"}),", but not for ",(0,s.jsx)(n.code,{children:"'octopus'"}),", because ",(0,s.jsx)(n.code,{children:"'octopus'"})," flavour is really weird and why would anything be octopus-flavoured? Voc\xea pode fazer isso com este conjunto de testes:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function drinkAll(callback, flavour) {\n  if (flavour !== 'octopus') {\n    callback(flavour);\n  }\n}\n\ndescribe('drinkAll', () => {\n  test('drinks something lemon-flavoured', () => {\n    const drink = jest.fn();\n    drinkAll(drink, 'lemon');\n    expect(drink).toHaveBeenCalled();\n  });\n\n  test('does not drink something octopus-flavoured', () => {\n    const drink = jest.fn();\n    drinkAll(drink, 'octopus');\n    expect(drink).not.toHaveBeenCalled();\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavebeencalledtimesnumber",children:(0,s.jsx)(n.code,{children:".toHaveBeenCalledTimes(number)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".toBeCalledTimes(number)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toHaveBeenCalledTimes"})," para garantir que uma fun\xe7\xe3o de simula\xe7\xe3o (mock, em ingl\xeas) foi chamada um n\xfamero exato de vezes."]}),"\n",(0,s.jsxs)(n.p,{children:["Por exemplo, vamos dizer voc\xea tem uma fun\xe7\xe3o ",(0,s.jsx)(n.code,{children:"drinkEach(drink, Array<flavor>)"})," que usa uma fun\xe7\xe3o ",(0,s.jsx)(n.code,{children:"drink"}),' e aplica ela ao array das bebidas passadas. Voc\xea pode querer verificar que a fun\xe7\xe3o "drink" foi chamada um n\xfamero exato de vezes. Voc\xea pode fazer isso com este conjunto de testes:']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drinkEach drinks each drink', () => {\n  const drink = jest.fn();\n  drinkEach(drink, ['lemon', 'octopus']);\n  expect(drink).toHaveBeenCalledTimes(2);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavebeencalledwitharg1-arg2-",children:(0,s.jsx)(n.code,{children:".toHaveBeenCalledWith(arg1, arg2, ...)"})}),"\n",(0,s.jsxs)(n.p,{children:["Tamb\xe9m sob o pseud\xf4nimo: ",(0,s.jsx)(n.code,{children:".toBeCalledWith()"})]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toHaveBeenCalledWith"})," para garantir que uma fun\xe7\xe3o de simula\xe7\xe3o (mock, em ingl\xeas) foi chamada com argumentos espec\xedficos. The arguments are checked with the same algorithm that ",(0,s.jsx)(n.code,{children:".toEqual"})," uses."]}),"\n",(0,s.jsxs)(n.p,{children:["Por exemplo, digamos que voc\xea pode registrar uma bebida com uma fun\xe7\xe3o ",(0,s.jsx)(n.code,{children:"register"}),", e ",(0,s.jsx)(n.code,{children:"applyToAll(f)"})," deve aplicar a fun\xe7\xe3o ",(0,s.jsx)(n.code,{children:"f"})," para todas as bebidas registradas. Para garantir que isso funciona, voc\xea poderia escrever:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('registration applies correctly to orange La Croix', () => {\n  const beverage = new LaCroix('orange');\n  register(beverage);\n  const f = jest.fn();\n  applyToAll(f);\n  expect(f).toHaveBeenCalledWith(beverage);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavebeenlastcalledwitharg1-arg2-",children:(0,s.jsx)(n.code,{children:".toHaveBeenLastCalledWith(arg1, arg2, ...)"})}),"\n",(0,s.jsxs)(n.p,{children:["Tamb\xe9m sob o pseud\xf4nimo: ",(0,s.jsx)(n.code,{children:".lastCalledWith(arg1, arg2, ...)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Se voc\xea tiver uma fun\xe7\xe3o de simula\xe7\xe3o (mock, em ingl\xeas), voc\xea pode usar ",(0,s.jsx)(n.code,{children:".toHaveBeenLastCalledWith"})," para testar com quais argumentos foi chamada na \xfaltima vez. Por exemplo, digamos que voc\xea tem uma fun\xe7\xe3o ",(0,s.jsx)(n.code,{children:"applyToAllFlavors(f)"})," que aplica ",(0,s.jsx)(n.code,{children:"f"})," para um monte de sabores, e voc\xea deseja garantir que quando voc\xea cham\xe1-la, o \xfaltimo sabor em que ela opera \xe9 ",(0,s.jsx)(n.code,{children:"'mango'"}),". Voc\xea pode escrever:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('applying to all flavors does mango last', () => {\n  const drink = jest.fn();\n  applyToAllFlavors(drink);\n  expect(drink).toHaveBeenLastCalledWith('mango');\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavebeennthcalledwithnthcall-arg1-arg2-",children:(0,s.jsx)(n.code,{children:".toHaveBeenNthCalledWith(nthCall, arg1, arg2, ....)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".nthCalledWith(nthCall, arg1, arg2, ...)"})]}),"\n",(0,s.jsxs)(n.p,{children:["If you have a mock function, you can use ",(0,s.jsx)(n.code,{children:".toHaveBeenNthCalledWith"})," to test what arguments it was nth called with. For example, let's say you have a ",(0,s.jsx)(n.code,{children:"drinkEach(drink, Array<flavor>)"})," function that applies ",(0,s.jsx)(n.code,{children:"f"})," to a bunch of flavors, and you want to ensure that when you call it, the first flavor it operates on is ",(0,s.jsx)(n.code,{children:"'lemon'"})," and the second one is ",(0,s.jsx)(n.code,{children:"'octopus'"}),". Voc\xea pode escrever:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drinkEach drinks each drink', () => {\n  const drink = jest.fn();\n  drinkEach(drink, ['lemon', 'octopus']);\n  expect(drink).toHaveBeenNthCalledWith(1, 'lemon');\n  expect(drink).toHaveBeenNthCalledWith(2, 'octopus');\n});\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"The nth argument must be positive integer starting from 1."})}),"\n",(0,s.jsx)(n.h3,{id:"tohavereturned",children:(0,s.jsx)(n.code,{children:".toHaveReturned()"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".toReturn()"})]}),"\n",(0,s.jsxs)(n.p,{children:["If you have a mock function, you can use ",(0,s.jsx)(n.code,{children:".toHaveReturned"})," to test that the mock function successfully returned (i.e., did not throw an error) at least one time. For example, let's say you have a mock ",(0,s.jsx)(n.code,{children:"drink"})," that returns ",(0,s.jsx)(n.code,{children:"true"}),". Voc\xea pode escrever:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drinks returns', () => {\n  const drink = jest.fn(() => true);\n\n  drink();\n\n  expect(drink).toHaveReturned();\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavereturnedtimesnumber",children:(0,s.jsx)(n.code,{children:".toHaveReturnedTimes(number)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".toReturnTimes(number)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toHaveReturnedTimes"})," to ensure that a mock function returned successfully (i.e., did not throw an error) an exact number of times. Any calls to the mock function that throw an error are not counted toward the number of times the function returned."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's say you have a mock ",(0,s.jsx)(n.code,{children:"drink"})," that returns ",(0,s.jsx)(n.code,{children:"true"}),". Voc\xea pode escrever:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drink returns twice', () => {\n  const drink = jest.fn(() => true);\n\n  drink();\n  drink();\n\n  expect(drink).toHaveReturnedTimes(2);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavereturnedwithvalue",children:(0,s.jsx)(n.code,{children:".toHaveReturnedWith(value)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".toReturnWith(value)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toHaveReturnedWith"})," to ensure that a mock function returned a specific value."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's say you have a mock ",(0,s.jsx)(n.code,{children:"drink"})," that returns the name of the beverage that was consumed. Voc\xea pode escrever:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drink returns La Croix', () => {\n  const beverage = {name: 'La Croix'};\n  const drink = jest.fn(beverage => beverage.name);\n\n  drink(beverage);\n\n  expect(drink).toHaveReturnedWith('La Croix');\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavelastreturnedwithvalue",children:(0,s.jsx)(n.code,{children:".toHaveLastReturnedWith(value)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".lastReturnedWith(value)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toHaveLastReturnedWith"})," to test the specific value that a mock function last returned. If the last call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's say you have a mock ",(0,s.jsx)(n.code,{children:"drink"})," that returns the name of the beverage that was consumed. Voc\xea pode escrever:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drink returns La Croix (Orange) last', () => {\n  const beverage1 = {name: 'La Croix (Lemon)'};\n  const beverage2 = {name: 'La Croix (Orange)'};\n  const drink = jest.fn(beverage => beverage.name);\n\n  drink(beverage1);\n  drink(beverage2);\n\n  expect(drink).toHaveLastReturnedWith('La Croix (Orange)');\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohaventhreturnedwithnthcall-value",children:(0,s.jsx)(n.code,{children:".toHaveNthReturnedWith(nthCall, value)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".nthReturnedWith(nthCall, value)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toHaveNthReturnedWith"})," to test the specific value that a mock function returned for the nth call. If the nth call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's say you have a mock ",(0,s.jsx)(n.code,{children:"drink"})," that returns the name of the beverage that was consumed. Voc\xea pode escrever:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drink returns expected nth calls', () => {\n  const beverage1 = {name: 'La Croix (Lemon)'};\n  const beverage2 = {name: 'La Croix (Orange)'};\n  const drink = jest.fn(beverage => beverage.name);\n\n  drink(beverage1);\n  drink(beverage2);\n\n  expect(drink).toHaveNthReturnedWith(1, 'La Croix (Lemon)');\n  expect(drink).toHaveNthReturnedWith(2, 'La Croix (Orange)');\n});\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"The nth argument must be positive integer starting from 1."})}),"\n",(0,s.jsx)(n.h3,{id:"tohavelengthnumber",children:(0,s.jsx)(n.code,{children:".toHaveLength(number)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toHaveLength"})," para verificar que um objeto tem uma propriedade ",(0,s.jsx)(n.code,{children:".length"})," e est\xe1 definida para um determinado valor num\xe9rico."]}),"\n",(0,s.jsx)(n.p,{children:"Isto \xe9 especialmente \xfatil para verificar arrays ou tamanho de strings."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"expect([1, 2, 3]).toHaveLength(3);\nexpect('abc').toHaveLength(3);\nexpect('').not.toHaveLength(5);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tohavepropertykeypath-value",children:(0,s.jsx)(n.code,{children:".toHaveProperty(keyPath, value?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toHaveProperty"})," para verificar se a propriedade fornecida na refer\xeancia ",(0,s.jsx)(n.code,{children:"keyPath"})," existe para um objeto. For checking deeply nested properties in an object you may use ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors",children:"dot notation"})," or an array containing the keyPath for deep references."]}),"\n",(0,s.jsxs)(n.p,{children:["You can provide an optional ",(0,s.jsx)(n.code,{children:"value"})," argument to compare the received property value (recursively for all properties of object instances, also known as deep equality, like the ",(0,s.jsx)(n.code,{children:"toEqual"})," matcher)."]}),"\n",(0,s.jsxs)(n.p,{children:["O exemplo a seguir cont\xe9m um objeto ",(0,s.jsx)(n.code,{children:"houseForSale"})," com propriedades aninhadas. We are using ",(0,s.jsx)(n.code,{children:"toHaveProperty"})," to check for the existence and values of various properties in the object."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Object containing house features to be tested\nconst houseForSale = {\n  bath: true,\n  bedrooms: 4,\n  kitchen: {\n    amenities: ['oven', 'stove', 'washer'],\n    area: 20,\n    wallColor: 'white',\n    'nice.oven': true,\n  },\n  livingroom: {\n    amenities: [\n      {\n        couch: [\n          ['large', {dimensions: [20, 20]}],\n          ['small', {dimensions: [10, 10]}],\n        ],\n      },\n    ],\n  },\n  'ceiling.height': 2,\n};\n\ntest('this house has my desired features', () => {\n  // Example Referencing\n  expect(houseForSale).toHaveProperty('bath');\n  expect(houseForSale).toHaveProperty('bedrooms', 4);\n\n  expect(houseForSale).not.toHaveProperty('pool');\n\n  // Deep referencing using dot notation\n  expect(houseForSale).toHaveProperty('kitchen.area', 20);\n  expect(houseForSale).toHaveProperty('kitchen.amenities', [\n    'oven',\n    'stove',\n    'washer',\n  ]);\n\n  expect(houseForSale).not.toHaveProperty('kitchen.open');\n\n  // Deep referencing using an array containing the keyPath\n  expect(houseForSale).toHaveProperty(['kitchen', 'area'], 20);\n  expect(houseForSale).toHaveProperty(\n    ['kitchen', 'amenities'],\n    ['oven', 'stove', 'washer'],\n  );\n  expect(houseForSale).toHaveProperty(['kitchen', 'amenities', 0], 'oven');\n  expect(houseForSale).toHaveProperty(\n    'livingroom.amenities[0].couch[0][1].dimensions[0]',\n    20,\n  );\n  expect(houseForSale).toHaveProperty(['kitchen', 'nice.oven']);\n  expect(houseForSale).not.toHaveProperty(['kitchen', 'open']);\n\n  // Referencing keys with dot in the key itself\n  expect(houseForSale).toHaveProperty(['ceiling.height'], 'tall');\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobeclosetonumber-numdigits",children:(0,s.jsx)(n.code,{children:".toBeCloseTo(number, numDigits?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"toBeCloseTo"})," to compare floating point numbers for approximate equality."]}),"\n",(0,s.jsxs)(n.p,{children:["The optional ",(0,s.jsx)(n.code,{children:"numDigits"})," argument limits the number of digits to check ",(0,s.jsx)(n.strong,{children:"after"})," the decimal point. For the default value ",(0,s.jsx)(n.code,{children:"2"}),", the test criterion is ",(0,s.jsx)(n.code,{children:"Math.abs(expected - received) < 0.005"})," (that is, ",(0,s.jsx)(n.code,{children:"10 ** -2 / 2"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"Intuitive equality comparisons often fail, because arithmetic on decimal (base 10) values often have rounding errors in limited precision binary (base 2) representation. For example, this test fails:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('adding works sanely with decimals', () => {\n  expect(0.2 + 0.1).toBe(0.3); // Fails!\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It fails because in JavaScript, ",(0,s.jsx)(n.code,{children:"0.2 + 0.1"})," is actually ",(0,s.jsx)(n.code,{children:"0.30000000000000004"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"For example, this test passes with a precision of 5 digits:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('adding works sanely with decimals', () => {\n  expect(0.2 + 0.1).toBeCloseTo(0.3, 5);\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Because floating point errors are the problem that ",(0,s.jsx)(n.code,{children:"toBeCloseTo"})," solves, it does not support big integer values."]}),"\n",(0,s.jsx)(n.h3,{id:"tobedefined",children:(0,s.jsx)(n.code,{children:".toBeDefined()"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toBeDefined"}),' para verificar que uma vari\xe1vel n\xe3o "undefined". For example, if you want to check that a function ',(0,s.jsx)(n.code,{children:"fetchNewFlavorIdea()"})," returns ",(0,s.jsx)(n.em,{children:"something"}),", you can write:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('there is a new flavor idea', () => {\n  expect(fetchNewFlavorIdea()).toBeDefined();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Voc\xea poderia escrever ",(0,s.jsx)(n.code,{children:"expect(fetchNewFlavorIdea()).not.toBe(undefined)"}),", mas \xe9 uma melhor pr\xe1tica evitar refer\xeancia a ",(0,s.jsx)(n.code,{children:"undefined"})," diretamente em seu c\xf3digo."]}),"\n",(0,s.jsx)(n.h3,{id:"tobefalsy",children:(0,s.jsx)(n.code,{children:".toBeFalsy()"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toBeFalsy"})," when you don't care what a value is and you want to ensure a value is false in a boolean context. For example, let's say you have some application code that looks like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"drinkSomeLaCroix();\nif (!getErrors()) {\n  drinkMoreLaCroix();\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Voc\xea pode n\xe3o se importar com o que ",(0,s.jsx)(n.code,{children:"getErrors"})," retorna, especificamente - ele pode retornar ",(0,s.jsx)(n.code,{children:"false"}),", ",(0,s.jsx)(n.code,{children:"null"})," ou ",(0,s.jsx)(n.code,{children:"0"}),", e seu c\xf3digo ainda funcionaria. Ent\xe3o se voc\xea quiser testar que n\xe3o existem erros depois de beber algumas La Croix, voc\xea poderia escrever:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drinking La Croix does not lead to errors', () => {\n  drinkSomeLaCroix();\n  expect(getErrors()).toBeFalsy();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:['Em JavaScript, existem seis valores "falsy" (que se traduzem em falso quando avaliados em um contexto booleano): ',(0,s.jsx)(n.code,{children:"false"}),", ",(0,s.jsx)(n.code,{children:"0"}),", ",(0,s.jsx)(n.code,{children:"''"}),", ",(0,s.jsx)(n.code,{children:"null"}),", ",(0,s.jsx)(n.code,{children:"undefined"})," e ",(0,s.jsx)(n.code,{children:"NaN"}),'. Todo o resto \xe9 "truthy" (se traduzem em verdadeiro quando avaliados em um contexto booleano).']}),"\n",(0,s.jsx)(n.h3,{id:"tobegreaterthannumber--bigint",children:(0,s.jsx)(n.code,{children:".toBeGreaterThan(number | bigint)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"toBeGreaterThan"})," to compare ",(0,s.jsx)(n.code,{children:"received > expected"})," for number or big integer values. For example, test that ",(0,s.jsx)(n.code,{children:"ouncesPerCan()"})," returns a value of more than 10 ounces:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('ounces per can is more than 10', () => {\n  expect(ouncesPerCan()).toBeGreaterThan(10);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobegreaterthanorequalnumber--bigint",children:(0,s.jsx)(n.code,{children:".toBeGreaterThanOrEqual(number | bigint)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"toBeGreaterThanOrEqual"})," to compare ",(0,s.jsx)(n.code,{children:"received >= expected"})," for number or big integer values. For example, test that ",(0,s.jsx)(n.code,{children:"ouncesPerCan()"})," returns a value of at least 12 ounces:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('ounces per can is at least 12', () => {\n  expect(ouncesPerCan()).toBeGreaterThanOrEqual(12);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobelessthannumber--bigint",children:(0,s.jsx)(n.code,{children:".toBeLessThan(number | bigint)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"toBeLessThan"})," to compare ",(0,s.jsx)(n.code,{children:"received < expected"})," for number or big integer values. For example, test that ",(0,s.jsx)(n.code,{children:"ouncesPerCan()"})," returns a value of less than 20 ounces:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('ounces per can is less than 20', () => {\n  expect(ouncesPerCan()).toBeLessThan(20);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobelessthanorequalnumber--bigint",children:(0,s.jsx)(n.code,{children:".toBeLessThanOrEqual(number | bigint)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"toBeLessThanOrEqual"})," to compare ",(0,s.jsx)(n.code,{children:"received <= expected"})," for number or big integer values. For example, test that ",(0,s.jsx)(n.code,{children:"ouncesPerCan()"})," returns a value of at most 12 ounces:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('ounces per can is at most 12', () => {\n  expect(ouncesPerCan()).toBeLessThanOrEqual(12);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobeinstanceofclass",children:(0,s.jsx)(n.code,{children:".toBeInstanceOf(Class)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toBeInstanceOf(Class)"}),' para verificar que um objeto \xe9 uma inst\xe2ncia de uma classe. Este "matcher" usa ',(0,s.jsx)(n.code,{children:"instanceof"})," por debaixo."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class A {}\n\nexpect(new A()).toBeInstanceOf(A);\nexpect(() => {}).toBeInstanceOf(Function);\nexpect(new A()).toBeInstanceOf(Function); // throws\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobenull",children:(0,s.jsx)(n.code,{children:".toBeNull()"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:".toBeNull()"})," \xe9 o mesmo que ",(0,s.jsx)(n.code,{children:".toBe(null)"}),", mas as mensagens de erro s\xe3o um pouco mais agrad\xe1veis. Ent\xe3o use ",(0,s.jsx)(n.code,{children:".toBeNull()"})," quando voc\xea deseja verificar que algo \xe9 nulo."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function bloop() {\n  return null;\n}\n\ntest('bloop returns null', () => {\n  expect(bloop()).toBeNull();\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tobetruthy",children:(0,s.jsx)(n.code,{children:".toBeTruthy()"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toBeTruthy"})," when you don't care what a value is and you want to ensure a value is true in a boolean context. For example, let's say you have some application code that looks like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"drinkSomeLaCroix();\nif (thirstInfo()) {\n  drinkMoreLaCroix();\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Voc\xea pode n\xe3o se importar o que ",(0,s.jsx)(n.code,{children:"thirstInfo"})," retorna, especificamente - ele pode retornar ",(0,s.jsx)(n.code,{children:"true"})," ou um objeto complexo, e seu c\xf3digo ainda funcionaria. So if you want to test that ",(0,s.jsx)(n.code,{children:"thirstInfo"})," will be truthy after drinking some La Croix, you could write:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('drinking La Croix leads to having thirst info', () => {\n  drinkSomeLaCroix();\n  expect(thirstInfo()).toBeTruthy();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:['Em JavaScript, existem seis valores "falsy" (que se traduzem em falso quando avaliados em um contexto booleano): ',(0,s.jsx)(n.code,{children:"false"}),", ",(0,s.jsx)(n.code,{children:"0"}),", ",(0,s.jsx)(n.code,{children:"''"}),", ",(0,s.jsx)(n.code,{children:"null"}),", ",(0,s.jsx)(n.code,{children:"undefined"})," e ",(0,s.jsx)(n.code,{children:"NaN"}),'. Todo o resto \xe9 "truthy" (se traduzem em verdadeiro quando avaliados em um contexto booleano).']}),"\n",(0,s.jsx)(n.h3,{id:"tobeundefined",children:(0,s.jsx)(n.code,{children:".toBeUndefined()"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toBeUndefined"}),' para verificar se uma vari\xe1vel \xe9 "undefined". Por exemplo, se voc\xea quiser verificar que uma fun\xe7\xe3o ',(0,s.jsx)(n.code,{children:"bestDrinkForFlavor(flavor)"})," retornar\xe1 ",(0,s.jsx)(n.code,{children:"undefined"})," para o sabor ",(0,s.jsx)(n.code,{children:"'octopus'"}),', porque n\xe3o h\xe1 nenhuma boa bebida com sabor "octopus", ou polvo:']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('the best drink for octopus flavor is undefined', () => {\n  expect(bestDrinkForFlavor('octopus')).toBeUndefined();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Voc\xea poderia escrever ",(0,s.jsx)(n.code,{children:"expect(bestDrinkForFlavor('octopus')).toBe(undefined)"}),", mas \xe9 uma melhor pr\xe1tica evitar se referir a ",(0,s.jsx)(n.code,{children:"undefined"})," diretamente em seu c\xf3digo."]}),"\n",(0,s.jsx)(n.h3,{id:"tobenan",children:(0,s.jsx)(n.code,{children:".toBeNaN()"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toBeNaN"})," when checking a value is ",(0,s.jsx)(n.code,{children:"NaN"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('passes when value is NaN', () => {\n  expect(NaN).toBeNaN();\n  expect(1).not.toBeNaN();\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tocontainitem",children:(0,s.jsx)(n.code,{children:".toContain(item)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toContain"})," quando voc\xea deseja verificar se um item est\xe1 em um array. Para testar os itens no array, este usa ",(0,s.jsx)(n.code,{children:"==="}),", uma verifica\xe7\xe3o de igualdade estrita. ",(0,s.jsx)(n.code,{children:".toContain"})," tamb\xe9m pode verificar se uma string \xe9 uma substring de outra string."]}),"\n",(0,s.jsxs)(n.p,{children:["Por exemplo, se ",(0,s.jsx)(n.code,{children:"getAllFlavors()"})," retorna um array de sabores e voc\xea quer ter certeza que ",(0,s.jsx)(n.code,{children:"lime"})," est\xe1 l\xe1, voc\xea pode escrever:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('the flavor list contains lime', () => {\n  expect(getAllFlavors()).toContain('lime');\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"This matcher also accepts others iterables such as strings, sets, node lists and HTML collections."}),"\n",(0,s.jsx)(n.h3,{id:"tocontainequalitem",children:(0,s.jsx)(n.code,{children:".toContainEqual(item)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toContainEqual"}),' quando voc\xea deseja verificar que um item com uma estrutura espec\xedfica e valores est\xe1 contido em um array. Para testar os itens no array, este "matcher" recursivamente verifica a igualdade de todos os campos, em vez de verificar a identidade do objeto.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('my beverage', () => {\n  test('is delicious and not sour', () => {\n    const myBeverage = {delicious: true, sour: false};\n    expect(myBeverages()).toContainEqual(myBeverage);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"toequalvalue",children:(0,s.jsx)(n.code,{children:".toEqual(value)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toEqual"}),' to compare recursively all properties of object instances (also known as "deep" equality). It calls ',(0,s.jsx)(n.code,{children:"Object.is"})," to compare primitive values, which is even better for testing than ",(0,s.jsx)(n.code,{children:"==="})," strict equality operator."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, ",(0,s.jsx)(n.code,{children:".toEqual"})," and ",(0,s.jsx)(n.code,{children:".toBe"})," behave differently in this test suite, so all the tests pass:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const can1 = {\n  flavor: 'grapefruit',\n  ounces: 12,\n};\nconst can2 = {\n  flavor: 'grapefruit',\n  ounces: 12,\n};\n\ndescribe('the La Croix cans on my desk', () => {\n  test('have all the same properties', () => {\n    expect(can1).toEqual(can2);\n  });\n  test('are not the exact same can', () => {\n    expect(can1).not.toBe(can2);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"toEqual"})," ignores object keys with ",(0,s.jsx)(n.code,{children:"undefined"})," properties, ",(0,s.jsx)(n.code,{children:"undefined"})," array items, array sparseness, or object type mismatch. To take these into account use ",(0,s.jsx)(n.a,{href:"#tostrictequalvalue",children:(0,s.jsx)(n.code,{children:".toStrictEqual"})})," instead."]})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:".toEqual"})," won't perform a ",(0,s.jsx)(n.em,{children:"deep equality"})," check for two errors. Apenas a propriedade ",(0,s.jsx)(n.code,{children:"message"}),' de um Error \xe9 considerada pela igualdade. \xc9 recomend\xe1vel usar o "matcher" ',(0,s.jsx)(n.code,{children:".toThrow"})," para testes contra erros."]})}),"\n",(0,s.jsxs)(n.p,{children:["If differences between properties do not help you to understand why a test fails, especially if the report is large, then you might move the comparison into the ",(0,s.jsx)(n.code,{children:"expect"})," function. For example, use ",(0,s.jsx)(n.code,{children:"equals"})," method of ",(0,s.jsx)(n.code,{children:"Buffer"})," class to assert whether or not buffers contain the same content:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["rewrite ",(0,s.jsx)(n.code,{children:"expect(received).toEqual(expected)"})," as ",(0,s.jsx)(n.code,{children:"expect(received.equals(expected)).toBe(true)"})]}),"\n",(0,s.jsxs)(n.li,{children:["rewrite ",(0,s.jsx)(n.code,{children:"expect(received).not.toEqual(expected)"})," as ",(0,s.jsx)(n.code,{children:"expect(received.equals(expected)).toBe(false)"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"tomatchregexp--string",children:(0,s.jsx)(n.code,{children:".toMatch(regexp | string)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toMatch"})," para verificar se uma string corresponde a uma express\xe3o regular."]}),"\n",(0,s.jsxs)(n.p,{children:["Por exemplo, voc\xea talvez n\xe3o saiba o que exatamente ",(0,s.jsx)(n.code,{children:"essayOnTheBestFlavor()"})," retorna, mas voc\xea sabe que \xe9 uma string muito longa, e a substring ",(0,s.jsx)(n.code,{children:"grapefruit"})," deve estar em algum lugar. Voc\xea pode testar isso com:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('an essay on the best flavor', () => {\n  test('mentions grapefruit', () => {\n    expect(essayOnTheBestFlavor()).toMatch(/grapefruit/);\n    expect(essayOnTheBestFlavor()).toMatch(new RegExp('grapefruit'));\n  });\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:'Este "matcher" tamb\xe9m aceita uma string, a qual tentar\xe1 corresponder:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('grapefruits are healthy', () => {\n  test('grapefruits are a fruit', () => {\n    expect('grapefruits').toMatch('fruit');\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tomatchobjectobject",children:(0,s.jsx)(n.code,{children:".toMatchObject(object)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toMatchObject"})," para verificar se um objeto JavaScript corresponde a um subconjunto das propriedades de um objeto. Combinar\xe1 objetos recebidos com propriedades que ",(0,s.jsx)(n.strong,{children:"n\xe3o"})," est\xe3o no objeto esperado."]}),"\n",(0,s.jsxs)(n.p,{children:["Voc\xea tamb\xe9m pode passar uma array de objetos, neste caso o m\xe9todo retornar\xe1 verdadeiro somente se cada objeto na matriz recebida corresponder (no sentido ",(0,s.jsx)(n.code,{children:"toMatchObject"})," descrito acima) o objeto correspondente no array esperado. Isso \xe9 \xfatil se voc\xea deseja verificar que dois arrays correspondem em seu n\xfamero de elementos, em oposi\xe7\xe3o a ",(0,s.jsx)(n.code,{children:"arrayContaining"}),", que permite elementos extras no array recebido."]}),"\n",(0,s.jsx)(n.p,{children:'Voc\xea pode corresponder propriedades contra valores ou "matchers".'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const houseForSale = {\n  bath: true,\n  bedrooms: 4,\n  kitchen: {\n    amenities: ['oven', 'stove', 'washer'],\n    area: 20,\n    wallColor: 'white',\n  },\n};\nconst desiredHouse = {\n  bath: true,\n  kitchen: {\n    amenities: ['oven', 'stove', 'washer'],\n    wallColor: expect.stringMatching(/white|yellow/),\n  },\n};\n\ntest('the house has my desired features', () => {\n  expect(houseForSale).toMatchObject(desiredHouse);\n});\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('toMatchObject applied to arrays', () => {\n  test('the number of elements must match exactly', () => {\n    expect([{foo: 'bar'}, {baz: 1}]).toMatchObject([{foo: 'bar'}, {baz: 1}]);\n  });\n\n  test('.toMatchObject is called for each elements, so extra object properties are okay', () => {\n    expect([{foo: 'bar'}, {baz: 1, extra: 'quux'}]).toMatchObject([\n      {foo: 'bar'},\n      {baz: 1},\n    ]);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tomatchsnapshotpropertymatchers-hint",children:(0,s.jsx)(n.code,{children:".toMatchSnapshot(propertyMatchers?, hint?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Isso garante que um valor corresponda ao snapshot mais recente. Confira ",(0,s.jsx)(n.a,{href:"/pt-BR/docs/snapshot-testing",children:"o guia de Teste de Snapshot"})," para obter mais informa\xe7\xf5es."]}),"\n",(0,s.jsxs)(n.p,{children:["You can provide an optional ",(0,s.jsx)(n.code,{children:"propertyMatchers"})," object argument, which has asymmetric matchers as values of a subset of expected properties, ",(0,s.jsx)(n.strong,{children:"if"})," the received value will be an ",(0,s.jsx)(n.strong,{children:"object"})," instance. It is like ",(0,s.jsx)(n.code,{children:"toMatchObject"})," with flexible criteria for a subset of properties, followed by a snapshot test as exact criteria for the rest of the properties."]}),"\n",(0,s.jsxs)(n.p,{children:["You can provide an optional ",(0,s.jsx)(n.code,{children:"hint"})," string argument that is appended to the test name. Although Jest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate ",(0,s.jsx)(n.strong,{children:"multiple"})," snapshots in a ",(0,s.jsx)(n.strong,{children:"single"})," ",(0,s.jsx)(n.code,{children:"it"})," or ",(0,s.jsx)(n.code,{children:"test"})," block. Jest sorts snapshots by name in the corresponding ",(0,s.jsx)(n.code,{children:".snap"})," file."]}),"\n",(0,s.jsx)(n.h3,{id:"tomatchinlinesnapshotpropertymatchers-inlinesnapshot",children:(0,s.jsx)(n.code,{children:".toMatchInlineSnapshot(propertyMatchers?, inlineSnapshot)"})}),"\n",(0,s.jsx)(n.p,{children:"Ensures that a value matches the most recent snapshot."}),"\n",(0,s.jsxs)(n.p,{children:["You can provide an optional ",(0,s.jsx)(n.code,{children:"propertyMatchers"})," object argument, which has asymmetric matchers as values of a subset of expected properties, ",(0,s.jsx)(n.strong,{children:"if"})," the received value will be an ",(0,s.jsx)(n.strong,{children:"object"})," instance. It is like ",(0,s.jsx)(n.code,{children:"toMatchObject"})," with flexible criteria for a subset of properties, followed by a snapshot test as exact criteria for the rest of the properties."]}),"\n",(0,s.jsxs)(n.p,{children:["Jest adds the ",(0,s.jsx)(n.code,{children:"inlineSnapshot"})," string argument to the matcher in the test file (instead of an external ",(0,s.jsx)(n.code,{children:".snap"})," file) the first time that the test runs."]}),"\n",(0,s.jsxs)(n.p,{children:["Check out the section on ",(0,s.jsx)(n.a,{href:"/pt-BR/docs/snapshot-testing#inline-snapshots",children:"Inline Snapshots"})," for more info."]}),"\n",(0,s.jsx)(n.h3,{id:"tostrictequalvalue",children:(0,s.jsx)(n.code,{children:".toStrictEqual(value)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toStrictEqual"})," to test that objects have the same structure and type."]}),"\n",(0,s.jsxs)(n.p,{children:["Differences from ",(0,s.jsx)(n.code,{children:".toEqual"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["keys with ",(0,s.jsx)(n.code,{children:"undefined"})," properties are checked, e.g. ",(0,s.jsx)(n.code,{children:"{a: undefined, b: 2}"})," will not equal ",(0,s.jsx)(n.code,{children:"{b: 2}"}),";"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"undefined"})," items are taken into account, e.g. ",(0,s.jsx)(n.code,{children:"[2]"})," will not equal ",(0,s.jsx)(n.code,{children:"[2, undefined]"}),";"]}),"\n",(0,s.jsxs)(n.li,{children:["array sparseness is checked, e.g. ",(0,s.jsx)(n.code,{children:"[, 1]"})," will not equal ",(0,s.jsx)(n.code,{children:"[undefined, 1]"}),";"]}),"\n",(0,s.jsxs)(n.li,{children:["object types are checked, e.g. a class instance with fields ",(0,s.jsx)(n.code,{children:"a"})," and ",(0,s.jsx)(n.code,{children:"b"})," will not equal a literal object with fields ",(0,s.jsx)(n.code,{children:"a"})," and ",(0,s.jsx)(n.code,{children:"b"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class LaCroix {\n  constructor(flavor) {\n    this.flavor = flavor;\n  }\n}\n\ndescribe('the La Croix cans on my desk', () => {\n  test('are not semantically the same', () => {\n    expect(new LaCroix('lemon')).toEqual({flavor: 'lemon'});\n    expect(new LaCroix('lemon')).not.toStrictEqual({flavor: 'lemon'});\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tothrowerror",children:(0,s.jsx)(n.code,{children:".toThrow(error?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Also under the alias: ",(0,s.jsx)(n.code,{children:".toThrowError(error?)"})]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toThrow"})," para testar que uma fun\xe7\xe3o \xe9 capaz de lan\xe7ar erros quando \xe9 chamada. Por exemplo, se queremos testar que ",(0,s.jsx)(n.code,{children:"drinkFlavor('octopus')"}),' lan\xe7a um erro, porque o sabor "octopus", ou polvo, \xe9 muito nojento para beber, podemos escrever:']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('throws on octopus', () => {\n  expect(() => {\n    drinkFlavor('octopus');\n  }).toThrow();\n});\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"You must wrap the code in a function, otherwise the error will not be caught and the assertion will fail."})}),"\n",(0,s.jsx)(n.p,{children:"You can provide an optional argument to test that a specific error is thrown:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["regular expression: error message ",(0,s.jsx)(n.strong,{children:"matches"})," the pattern"]}),"\n",(0,s.jsxs)(n.li,{children:["string: error message ",(0,s.jsx)(n.strong,{children:"includes"})," the substring"]}),"\n",(0,s.jsxs)(n.li,{children:["error object: error message is ",(0,s.jsx)(n.strong,{children:"equal to"})," the message property of the object"]}),"\n",(0,s.jsxs)(n.li,{children:["error class: error object is ",(0,s.jsx)(n.strong,{children:"instance of"})," class"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Por exemplo, digamos que ",(0,s.jsx)(n.code,{children:"drinkFlavor"})," \xe9 codificado como segue:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function drinkFlavor(flavor) {\n  if (flavor == 'octopus') {\n    throw new DisgustingFlavorError('yuck, octopus flavor');\n  }\n  // Do some other stuff\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Podemos fazer um teste se esse erro \xe9 lan\xe7ado de diversas maneiras:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('throws on octopus', () => {\n  function drinkOctopus() {\n    drinkFlavor('octopus');\n  }\n\n  // Test that the error message says \"yuck\" somewhere: these are equivalent\n  expect(drinkOctopus).toThrow(/yuck/);\n  expect(drinkOctopus).toThrow('yuck');\n\n  // Test the exact error message\n  expect(drinkOctopus).toThrow(/^yuck, octopus flavor$/);\n  expect(drinkOctopus).toThrow(new Error('yuck, octopus flavor'));\n\n  // Test that we get a DisgustingFlavorError\n  expect(drinkOctopus).toThrow(DisgustingFlavorError);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tothrowerrormatchingsnapshothint",children:(0,s.jsx)(n.code,{children:".toThrowErrorMatchingSnapshot(hint?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toThrowErrorMatchingSnapshot"})," para testar que uma fun\xe7\xe3o lan\xe7a um erro que corresponde ao snapshot mais recente quando \xe9 chamada."]}),"\n",(0,s.jsxs)(n.p,{children:["You can provide an optional ",(0,s.jsx)(n.code,{children:"hint"})," string argument that is appended to the test name. Although Jest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate ",(0,s.jsx)(n.strong,{children:"multiple"})," snapshots in a ",(0,s.jsx)(n.strong,{children:"single"})," ",(0,s.jsx)(n.code,{children:"it"})," or ",(0,s.jsx)(n.code,{children:"test"})," block. Jest sorts snapshots by name in the corresponding ",(0,s.jsx)(n.code,{children:".snap"})," file."]}),"\n",(0,s.jsxs)(n.p,{children:["Por exemplo, digamos que voc\xea tem uma fun\xe7\xe3o ",(0,s.jsx)(n.code,{children:"drinkFlavor"})," que lan\xe7a um erro sempre que o sabor \xe9 ",(0,s.jsx)(n.code,{children:"'octopus'"}),", e \xe9 codificada como segue:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function drinkFlavor(flavor) {\n  if (flavor == 'octopus') {\n    throw new DisgustingFlavorError('yuck, octopus flavor');\n  }\n  // Do some other stuff\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"O teste para esta fun\xe7\xe3o ficar\xe1 assim:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('throws on octopus', () => {\n  function drinkOctopus() {\n    drinkFlavor('octopus');\n  }\n\n  expect(drinkOctopus).toThrowErrorMatchingSnapshot();\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"E ir\xe1 gerar o seguinte snapshot:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'exports[`drinking flavors throws on octopus 1`] = `"yuck, octopus flavor"`;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Check out ",(0,s.jsx)(n.a,{href:"/blog/2016/07/27/jest-14",children:"React Tree Snapshot Testing"})," for more information on snapshot testing."]}),"\n",(0,s.jsx)(n.h3,{id:"tothrowerrormatchinginlinesnapshotinlinesnapshot",children:(0,s.jsx)(n.code,{children:".toThrowErrorMatchingInlineSnapshot(inlineSnapshot)"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".toThrowErrorMatchingInlineSnapshot"})," to test that a function throws an error matching the most recent snapshot when it is called."]}),"\n",(0,s.jsxs)(n.p,{children:["Jest adds the ",(0,s.jsx)(n.code,{children:"inlineSnapshot"})," string argument to the matcher in the test file (instead of an external ",(0,s.jsx)(n.code,{children:".snap"})," file) the first time that the test runs."]}),"\n",(0,s.jsxs)(n.p,{children:["Check out the section on ",(0,s.jsx)(n.a,{href:"/pt-BR/docs/snapshot-testing#inline-snapshots",children:"Inline Snapshots"})," for more info."]}),"\n",(0,s.jsx)(n.h2,{id:"asymmetric-matchers",children:"Asymmetric Matchers"}),"\n",(0,s.jsx)(n.h3,{id:"expectanything",children:(0,s.jsx)(n.code,{children:"expect.anything()"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.anything()"})," corresponde a qualquer coisa menos ",(0,s.jsx)(n.code,{children:"null"})," ou ",(0,s.jsx)(n.code,{children:"undefined"}),". Voc\xea pode us\xe1-lo dentro de ",(0,s.jsx)(n.code,{children:"toEqual"})," ou ",(0,s.jsx)(n.code,{children:"toBeCalledWith"})," em vez de um valor literal. Por exemplo, se voc\xea quiser verificar que uma fun\xe7\xe3o de simula\xe7\xe3o (mock, em ingl\xeas) \xe9 chamada com um argumento n\xe3o nulo:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('map calls its argument with a non-null argument', () => {\n  const mock = jest.fn();\n  [1].map(x => mock(x));\n  expect(mock).toHaveBeenCalledWith(expect.anything());\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectanyconstructor",children:(0,s.jsx)(n.code,{children:"expect.any(constructor)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.any(constructor)"})," matches anything that was created with the given constructor or if it's a primitive that is of the passed type. Voc\xea pode us\xe1-lo dentro de ",(0,s.jsx)(n.code,{children:"toEqual"})," ou ",(0,s.jsx)(n.code,{children:"toBeCalledWith"})," em vez de um valor literal. Por exemplo, se voc\xea quiser verificar que uma fun\xe7\xe3o de simula\xe7\xe3o (mock, em ingl\xeas) \xe9 chamada com um n\xfamero:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class Cat {}\nfunction getCat(fn) {\n  return fn(new Cat());\n}\n\ntest('randocall calls its callback with a class instance', () => {\n  const mock = jest.fn();\n  getCat(mock);\n  expect(mock).toHaveBeenCalledWith(expect.any(Cat));\n});\n\nfunction randocall(fn) {\n  return fn(Math.floor(Math.random() * 6 + 1));\n}\n\ntest('randocall calls its callback with a number', () => {\n  const mock = jest.fn();\n  randocall(mock);\n  expect(mock).toHaveBeenCalledWith(expect.any(Number));\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectarraycontainingarray",children:(0,s.jsx)(n.code,{children:"expect.arrayContaining(array)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.arrayContaining(array)"})," corresponde a um array recebido que cont\xe9m todos os elementos no array esperado. Ou seja, o array esperado \xe9 um ",(0,s.jsx)(n.strong,{children:"subconjunto"})," do array recebido. Portanto, combina com um array recebido que cont\xe9m elementos que ",(0,s.jsx)(n.strong,{children:"n\xe3o"})," est\xe3o no array esperado."]}),"\n",(0,s.jsx)(n.p,{children:"Voc\xea pode us\xe1-lo em vez de um valor literal:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["in ",(0,s.jsx)(n.code,{children:"toEqual"})," or ",(0,s.jsx)(n.code,{children:"toBeCalledWith"})]}),"\n",(0,s.jsxs)(n.li,{children:["to match a property in ",(0,s.jsx)(n.code,{children:"objectContaining"})," or ",(0,s.jsx)(n.code,{children:"toMatchObject"})]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('arrayContaining', () => {\n  const expected = ['Alice', 'Bob'];\n  it('matches even if received contains additional elements', () => {\n    expect(['Alice', 'Bob', 'Eve']).toEqual(expect.arrayContaining(expected));\n  });\n  it('does not match if received does not contain expected elements', () => {\n    expect(['Bob', 'Eve']).not.toEqual(expect.arrayContaining(expected));\n  });\n});\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('Beware of a misunderstanding! A sequence of dice rolls', () => {\n  const expected = [1, 2, 3, 4, 5, 6];\n  it('matches even with an unexpected number 7', () => {\n    expect([4, 1, 6, 7, 3, 5, 2, 5, 4, 6]).toEqual(\n      expect.arrayContaining(expected),\n    );\n  });\n  it('does not match without an expected number 2', () => {\n    expect([4, 1, 6, 7, 3, 5, 7, 5, 4, 6]).not.toEqual(\n      expect.arrayContaining(expected),\n    );\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectnotarraycontainingarray",children:(0,s.jsx)(n.code,{children:"expect.not.arrayContaining(array)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.not.arrayContaining(array)"})," corresponde a um array recebido que n\xe3o cont\xe9m todos os elementos no array esperado. Ou seja, o array esperado ",(0,s.jsx)(n.strong,{children:"n\xe3o \xe9 um subconjunto"})," do array recebido."]}),"\n",(0,s.jsxs)(n.p,{children:["It is the inverse of ",(0,s.jsx)(n.code,{children:"expect.arrayContaining"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('not.arrayContaining', () => {\n  const expected = ['Samantha'];\n\n  it('matches if the actual array does not contain the expected elements', () => {\n    expect(['Alice', 'Bob', 'Eve']).toEqual(\n      expect.not.arrayContaining(expected),\n    );\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectclosetonumber-numdigits",children:(0,s.jsx)(n.code,{children:"expect.closeTo(number, numDigits?)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.closeTo(number, numDigits?)"})," is useful when comparing floating point numbers in object properties or array item. If you need to compare a number, please use ",(0,s.jsx)(n.code,{children:".toBeCloseTo"})," instead."]}),"\n",(0,s.jsxs)(n.p,{children:["The optional ",(0,s.jsx)(n.code,{children:"numDigits"})," argument limits the number of digits to check ",(0,s.jsx)(n.strong,{children:"after"})," the decimal point. For the default value ",(0,s.jsx)(n.code,{children:"2"}),", the test criterion is ",(0,s.jsx)(n.code,{children:"Math.abs(expected - received) < 0.005 (that is, 10 ** -2 / 2)"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"For example, this test passes with a precision of 5 digits:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('compare float in object properties', () => {\n  expect({\n    title: '0.1 + 0.2',\n    sum: 0.1 + 0.2,\n  }).toEqual({\n    title: '0.1 + 0.2',\n    sum: expect.closeTo(0.3, 5),\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectobjectcontainingobject",children:(0,s.jsx)(n.code,{children:"expect.objectContaining(object)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.objectContaining(object)"})," corresponde a qualquer objeto recebido que recursivamente coincide com as propriedades esperadas. Ou seja, o objeto esperado \xe9 um ",(0,s.jsx)(n.strong,{children:"subconjunto"})," do objeto recebido. Therefore, it matches a received object which contains properties that ",(0,s.jsx)(n.strong,{children:"are present"})," in the expected object."]}),"\n",(0,s.jsxs)(n.p,{children:['Em vez de valores literais de propriedade no objeto esperado, voc\xea pode usar "matchers", ',(0,s.jsx)(n.code,{children:"expect.anything()"}),", e assim por diante."]}),"\n",(0,s.jsxs)(n.p,{children:["Por exemplo, digamos que esperamos uma fun\xe7\xe3o ",(0,s.jsx)(n.code,{children:"onPress"})," ser chamada com um objeto ",(0,s.jsx)(n.code,{children:"Event"}),", e tudo que precisamos verificar \xe9 que o evento tem propriedades ",(0,s.jsx)(n.code,{children:"event.x"})," e ",(0,s.jsx)(n.code,{children:"event.y"}),". Podemos fazer isso com:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('onPress gets called with the right thing', () => {\n  const onPress = jest.fn();\n  simulatePresses(onPress);\n  expect(onPress).toHaveBeenCalledWith(\n    expect.objectContaining({\n      x: expect.any(Number),\n      y: expect.any(Number),\n    }),\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectnotobjectcontainingobject",children:(0,s.jsx)(n.code,{children:"expect.not.objectContaining(object)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.not.objectContaining(object)"})," corresponde a qualquer objeto recebido que n\xe3o corresponde recursivamente \xe0s propriedades esperadas. Ou seja, o objeto esperado ",(0,s.jsx)(n.strong,{children:"n\xe3o \xe9 um subconjunto"})," do objeto recebido. Portanto, combina com um objeto recebido que cont\xe9m propriedades que ",(0,s.jsx)(n.strong,{children:"n\xe3o"})," est\xe3o no objeto esperado."]}),"\n",(0,s.jsxs)(n.p,{children:["\xc9 a inversa de ",(0,s.jsx)(n.code,{children:"expect.objectContaining"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('not.objectContaining', () => {\n  const expected = {foo: 'bar'};\n\n  it('matches if the actual object does not contain expected key: value pairs', () => {\n    expect({bar: 'baz'}).toEqual(expect.not.objectContaining(expected));\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectstringcontainingstring",children:(0,s.jsx)(n.code,{children:"expect.stringContaining(string)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.stringContaining(string)"})," matches the received value if it is a string that contains the exact expected string."]}),"\n",(0,s.jsx)(n.h3,{id:"expectnotstringcontainingstring",children:(0,s.jsx)(n.code,{children:"expect.not.stringContaining(string)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.not.stringContaining(string)"})," matches the received value if it is not a string or if it is a string that does not contain the exact expected string."]}),"\n",(0,s.jsxs)(n.p,{children:["It is the inverse of ",(0,s.jsx)(n.code,{children:"expect.stringContaining"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('not.stringContaining', () => {\n  const expected = 'Hello world!';\n\n  it('matches if the received value does not contain the expected substring', () => {\n    expect('How are you?').toEqual(expect.not.stringContaining(expected));\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectstringmatchingstring--regexp",children:(0,s.jsx)(n.code,{children:"expect.stringMatching(string | regexp)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.stringMatching(string | regexp)"})," matches the received value if it is a string that matches the expected string or regular expression."]}),"\n",(0,s.jsx)(n.p,{children:"Voc\xea pode us\xe1-lo em vez de um valor literal:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["in ",(0,s.jsx)(n.code,{children:"toEqual"})," or ",(0,s.jsx)(n.code,{children:"toBeCalledWith"})]}),"\n",(0,s.jsxs)(n.li,{children:["to match an element in ",(0,s.jsx)(n.code,{children:"arrayContaining"})]}),"\n",(0,s.jsxs)(n.li,{children:["to match a property in ",(0,s.jsx)(n.code,{children:"objectContaining"})," or ",(0,s.jsx)(n.code,{children:"toMatchObject"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:['Este exemplo tamb\xe9m mostra como voc\xea pode aninhar v\xe1rios "matchers" assim\xe9tricos, com ',(0,s.jsx)(n.code,{children:"expect.stringMatching"})," dentro de ",(0,s.jsx)(n.code,{children:"expect.arrayContaining"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('stringMatching in arrayContaining', () => {\n  const expected = [\n    expect.stringMatching(/^Alic/),\n    expect.stringMatching(/^[BR]ob/),\n  ];\n  it('matches even if received contains additional elements', () => {\n    expect(['Alicia', 'Roberto', 'Evelina']).toEqual(\n      expect.arrayContaining(expected),\n    );\n  });\n  it('does not match if received does not contain expected elements', () => {\n    expect(['Roberto', 'Evelina']).not.toEqual(\n      expect.arrayContaining(expected),\n    );\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectnotstringmatchingstring--regexp",children:(0,s.jsx)(n.code,{children:"expect.not.stringMatching(string | regexp)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.not.stringMatching(string | regexp)"})," matches the received value if it is not a string or if it is a string that does not match the expected string or regular expression."]}),"\n",(0,s.jsxs)(n.p,{children:["It is the inverse of ",(0,s.jsx)(n.code,{children:"expect.stringMatching"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('not.stringMatching', () => {\n  const expected = /Hello world!/;\n\n  it('matches if the received value does not match the expected regex', () => {\n    expect('How are you?').toEqual(expect.not.stringMatching(expected));\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"assertion-count",children:"Assertion Count"}),"\n",(0,s.jsx)(n.h3,{id:"expectassertionsnumber",children:(0,s.jsx)(n.code,{children:"expect.assertions(number)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.assertions(number)"}),' verifica que um certo n\xfamero de verifica\xe7\xf5es s\xe3o chamadas durante um teste. Isto \xe9 frequentemente \xfatil ao testar c\xf3digo ass\xedncrono, a fim de certificar-se que as verifica\xe7\xf5es de um "callback" realmente tenham sido chamadas.']}),"\n",(0,s.jsxs)(n.p,{children:["Por exemplo, digamos que temos uma fun\xe7\xe3o ",(0,s.jsx)(n.code,{children:"doAsync"}),' que recebe duas "callbacks" ',(0,s.jsx)(n.code,{children:"callback1"})," e ",(0,s.jsx)(n.code,{children:"callback2"}),", de forma ass\xedncrona chamar\xe1 as duas numa ordem desconhecida. Podemos testar isso com:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('doAsync calls both callbacks', () => {\n  expect.assertions(2);\n  function callback1(data) {\n    expect(data).toBeTruthy();\n  }\n  function callback2(data) {\n    expect(data).toBeTruthy();\n  }\n\n  doAsync(callback1, callback2);\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A chamada ",(0,s.jsx)(n.code,{children:"expect.assertions(2)"}),' garante que as duas "callbacks" sejam realmente chamadas.']}),"\n",(0,s.jsx)(n.h3,{id:"expecthasassertions",children:(0,s.jsx)(n.code,{children:"expect.hasAssertions()"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.hasAssertions()"}),' verifica que pelo menos uma verifica\xe7\xe3o \xe9 chamada durante um teste. Isto \xe9 frequentemente \xfatil ao testar c\xf3digo ass\xedncrono, a fim de certificar-se que as verifica\xe7\xf5es de um "callback" realmente tenham sido chamadas.']}),"\n",(0,s.jsxs)(n.p,{children:["Por exemplo, digamos que n\xf3s temos algumas fun\xe7\xf5es onde todas lidam com estado. ",(0,s.jsx)(n.code,{children:"prepareState"}),' chama um "callback" com um objeto de estado, ',(0,s.jsx)(n.code,{children:"validateState"})," \xe9 executado nesse objeto de estado, e ",(0,s.jsx)(n.code,{children:"waitOnState"}),' retorna uma promessa que aguarda at\xe9 que todas as "callbacks" ',(0,s.jsx)(n.code,{children:"prepareState"})," completem. Podemos testar isso com:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"test('prepareState prepares a valid state', () => {\n  expect.hasAssertions();\n  prepareState(state => {\n    expect(validateState(state)).toBeTruthy();\n  });\n  return waitOnState();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A chamada ",(0,s.jsx)(n.code,{children:"expect.hasAssertions()"}),' garante que a "callback" ',(0,s.jsx)(n.code,{children:"prepareState"})," \xe9 realmente chamada."]}),"\n",(0,s.jsx)(n.h2,{id:"extend-utilities",children:"Extend Utilities"}),"\n",(0,s.jsx)(n.h3,{id:"expectaddequalitytesterstesters",children:(0,s.jsx)(n.code,{children:"expect.addEqualityTesters(testers)"})}),"\n",(0,s.jsxs)(n.p,{children:["You can use ",(0,s.jsx)(n.code,{children:"expect.addEqualityTesters"})," to add your own methods to test if two objects are equal. For example, let's say you have a class in your code that represents volume and can determine if two volumes using different units are equal. You may want ",(0,s.jsx)(n.code,{children:"toEqual"})," (and other equality matchers) to use this custom equality method when comparing to Volume classes. You can add a custom equality tester to have ",(0,s.jsx)(n.code,{children:"toEqual"})," detect and apply custom logic when comparing Volume classes:"]}),"\n",(0,s.jsxs)(a.Z,{groupId:"code-examples",children:[(0,s.jsxs)(r.Z,{value:"js",label:"JavaScript",children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'tab={"span":3} title="Volume.js"',children:"// For simplicity in this example, we'll just support the units 'L' and 'mL'\nexport class Volume {\n  constructor(amount, unit) {\n    this.amount = amount;\n    this.unit = unit;\n  }\n\n  toString() {\n    return `[Volume ${this.amount}${this.unit}]`;\n  }\n\n  equals(other) {\n    if (this.unit === other.unit) {\n      return this.amount === other.amount;\n    } else if (this.unit === 'L' && other.unit === 'mL') {\n      return this.amount * 1000 === other.unit;\n    } else {\n      return this.amount === other.unit * 1000;\n    }\n  }\n}\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'title="areVolumesEqual.js"',children:"import {expect} from '@jest/globals';\nimport {Volume} from './Volume.js';\n\nfunction areVolumesEqual(a, b) {\n  const isAVolume = a instanceof Volume;\n  const isBVolume = b instanceof Volume;\n\n  if (isAVolume && isBVolume) {\n    return a.equals(b);\n  } else if (isAVolume !== isBVolume) {\n    return false;\n  } else {\n    return undefined;\n  }\n}\n\nexpect.addEqualityTesters([areVolumesEqual]);\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'title="__tests__/Volume.test.js"',children:"import {expect, test} from '@jest/globals';\nimport {Volume} from '../Volume.js';\nimport '../areVolumesEqual.js';\n\ntest('are equal with different units', () => {\n  expect(new Volume(1, 'L')).toEqual(new Volume(1000, 'mL'));\n});\n"})})]}),(0,s.jsxs)(r.Z,{value:"ts",label:"TypeScript",children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'tab={"span":3} title="Volume.ts"',children:"// For simplicity in this example, we'll just support the units 'L' and 'mL'\nexport class Volume {\n  public amount: number;\n  public unit: 'L' | 'mL';\n\n  constructor(amount: number, unit: 'L' | 'mL') {\n    this.amount = amount;\n    this.unit = unit;\n  }\n\n  toString(): string {\n    return `[Volume ${this.amount}${this.unit}]`;\n  }\n\n  equals(other: Volume): boolean {\n    if (this.unit === other.unit) {\n      return this.amount === other.amount;\n    } else if (this.unit === 'L' && other.unit === 'mL') {\n      return this.amount * 1000 === other.amount;\n    } else {\n      return this.amount === other.amount * 1000;\n    }\n  }\n}\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="areVolumesEqual.ts"',children:"import {expect} from '@jest/globals';\nimport {Volume} from './Volume.js';\n\nfunction areVolumesEqual(a: unknown, b: unknown): boolean | undefined {\n  const isAVolume = a instanceof Volume;\n  const isBVolume = b instanceof Volume;\n\n  if (isAVolume && isBVolume) {\n    return a.equals(b);\n  } else if (isAVolume !== isBVolume) {\n    return false;\n  } else {\n    return undefined;\n  }\n}\n\nexpect.addEqualityTesters([areVolumesEqual]);\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="__tests__/Volume.test.ts"',children:"import {expect, test} from '@jest/globals';\nimport {Volume} from '../Volume.js';\nimport '../areVolumesEqual.js';\n\ntest('are equal with different units', () => {\n  expect(new Volume(1, 'L')).toEqual(new Volume(1000, 'mL'));\n});\n"})})]})]}),"\n",(0,s.jsx)(n.h4,{id:"custom-equality-testers-api",children:"Custom equality testers API"}),"\n",(0,s.jsxs)(n.p,{children:["Custom testers are functions that return either the result (",(0,s.jsx)(n.code,{children:"true"})," or ",(0,s.jsx)(n.code,{children:"false"}),") of comparing the equality of the two given arguments or ",(0,s.jsx)(n.code,{children:"undefined"})," if the tester does not handle the given objects and wants to delegate equality to other testers (for example, the builtin equality testers)."]}),"\n",(0,s.jsx)(n.p,{children:"Custom testers are called with 3 arguments: the two objects to compare and the array of custom testers (used for recursive testers, see the section below)."}),"\n",(0,s.jsxs)(n.p,{children:["These helper functions and properties can be found on ",(0,s.jsx)(n.code,{children:"this"})," inside a custom tester:"]}),"\n",(0,s.jsx)(n.h4,{id:"thisequalsa-b-customtesters",children:(0,s.jsx)(n.code,{children:"this.equals(a, b, customTesters?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Esta \xe9 uma fun\xe7\xe3o de igualdade profunda que retornar\xe1 ",(0,s.jsx)(n.code,{children:"true"})," se dois objetos t\xeam os mesmos valores (recursivamente). It optionally takes a list of custom equality testers to apply to the deep equality checks. If you use this function, pass through the custom testers your tester is given so further equality checks ",(0,s.jsx)(n.code,{children:"equals"})," applies can also use custom testers the test author may have configured. See the example in the ",(0,s.jsx)(n.a,{href:"#recursive-custom-equality-testers",children:"Recursive custom equality testers"})," section for more details."]}),"\n",(0,s.jsx)(n.h4,{id:"matchers-vs-testers",children:"Matchers vs Testers"}),"\n",(0,s.jsxs)(n.p,{children:["Matchers are methods available on ",(0,s.jsx)(n.code,{children:"expect"}),", for example ",(0,s.jsx)(n.code,{children:"expect().toEqual()"}),". ",(0,s.jsx)(n.code,{children:"toEqual"})," is a matcher. A tester is a method used by matchers that do equality checks to determine if objects are the same."]}),"\n",(0,s.jsxs)(n.p,{children:["Custom matchers are good to use when you want to provide a custom assertion that test authors can use in their tests. For example, the ",(0,s.jsx)(n.code,{children:"toBeWithinRange"})," example in the ",(0,s.jsx)(n.a,{href:"#expectextendmatchers",children:(0,s.jsx)(n.code,{children:"expect.extend"})})," section is a good example of a custom matcher. Sometimes a test author may want to assert two numbers are exactly equal and should use ",(0,s.jsx)(n.code,{children:"toBe"}),". Other times, however, a test author may want to allow for some flexibility in their test, and ",(0,s.jsx)(n.code,{children:"toBeWithinRange"})," may be a more appropriate assertion."]}),"\n",(0,s.jsxs)(n.p,{children:["Custom equality testers are good for globally extending Jest matchers to apply custom equality logic for all equality comparisons. Test authors can't turn on custom testers for certain assertions and turn them off for others (a custom matcher should be used instead if that behavior is desired). For example, defining how to check if two ",(0,s.jsx)(n.code,{children:"Volume"})," objects are equal for all matchers would be a good custom equality tester."]}),"\n",(0,s.jsx)(n.h4,{id:"recursive-custom-equality-testers",children:"Recursive custom equality testers"}),"\n",(0,s.jsxs)(n.p,{children:["If your custom equality testers are testing objects with properties you'd like to do deep equality with, you should use the ",(0,s.jsx)(n.code,{children:"this.equals"})," helper available to equality testers. This ",(0,s.jsx)(n.code,{children:"equals"})," method is the same deep equals method Jest uses internally for all of its deep equality comparisons. It's the method that invokes your custom equality tester. It accepts an array of custom equality testers as a third argument. Custom equality testers are also given an array of custom testers as their third argument. Pass this argument into the third argument of ",(0,s.jsx)(n.code,{children:"equals"})," so that any further equality checks deeper into your object can also take advantage of custom equality testers."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's say you have a ",(0,s.jsx)(n.code,{children:"Book"})," class that contains an array of ",(0,s.jsx)(n.code,{children:"Author"})," classes and both of these classes have custom testers. The ",(0,s.jsx)(n.code,{children:"Book"})," custom tester would want to do a deep equality check on the array of ",(0,s.jsx)(n.code,{children:"Author"}),"s and pass in the custom testers given to it, so the ",(0,s.jsx)(n.code,{children:"Author"}),"s custom equality tester is applied:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'title="customEqualityTesters.js"',children:"function areAuthorEqual(a, b) {\n  const isAAuthor = a instanceof Author;\n  const isBAuthor = b instanceof Author;\n\n  if (isAAuthor && isBAuthor) {\n    // Authors are equal if they have the same name\n    return a.name === b.name;\n  } else if (isAAuthor !== isBAuthor) {\n    return false;\n  } else {\n    return undefined;\n  }\n}\n\nfunction areBooksEqual(a, b, customTesters) {\n  const isABook = a instanceof Book;\n  const isBBook = b instanceof Book;\n\n  if (isABook && isBBook) {\n    // Books are the same if they have the same name and author array. We need\n    // to pass customTesters to equals here so the Author custom tester will be\n    // used when comparing Authors\n    return (\n      a.name === b.name && this.equals(a.authors, b.authors, customTesters)\n    );\n  } else if (isABook !== isBBook) {\n    return false;\n  } else {\n    return undefined;\n  }\n}\n\nexpect.addEqualityTesters([areAuthorsEqual, areBooksEqual]);\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Remember to define your equality testers as regular functions and ",(0,s.jsx)(n.strong,{children:"not"})," arrow functions in order to access the tester context helpers (e.g. ",(0,s.jsx)(n.code,{children:"this.equals"}),")."]})}),"\n",(0,s.jsx)(n.h3,{id:"expectaddsnapshotserializerserializer",children:(0,s.jsx)(n.code,{children:"expect.addSnapshotSerializer(serializer)"})}),"\n",(0,s.jsxs)(n.p,{children:["Voc\xea pode chamar ",(0,s.jsx)(n.code,{children:"expect.addSnapshotSerializer"})," para adicionar um m\xf3dulo que formata estruturas de dados espec\xedficas da aplica\xe7\xe3o."]}),"\n",(0,s.jsxs)(n.p,{children:["Para um arquivo de teste individual, um m\xf3dulo adicionado precede quaisquer m\xf3dulos da configura\xe7\xe3o ",(0,s.jsx)(n.code,{children:"snapshotSerializers"}),", que precedem os serializadores de snapshot padr\xe3o para tipos internos de JavaScript e para elementos React. O \xfaltimo m\xf3dulo adicionado \xe9 o primeiro m\xf3dulo testado."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import serializer from 'my-serializer-module';\nexpect.addSnapshotSerializer(serializer);\n\n// affects expect(value).toMatchSnapshot() assertions in the test file\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you add a snapshot serializer in individual test files instead of adding it to ",(0,s.jsx)(n.code,{children:"snapshotSerializers"})," configuration:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"You make the dependency explicit instead of implicit."}),"\n",(0,s.jsxs)(n.li,{children:["You avoid limits to configuration that might cause you to eject from ",(0,s.jsx)(n.a,{href:"https://github.com/facebookincubator/create-react-app",children:"create-react-app"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Consulte ",(0,s.jsx)(n.a,{href:"/pt-BR/docs/configuration#snapshotserializers-arraystring",children:" configurando Jest"})," para obter maiores informa\xe7\xf5es."]}),"\n",(0,s.jsx)(n.h3,{id:"expectextendmatchers",children:(0,s.jsx)(n.code,{children:"expect.extend(matchers)"})}),"\n",(0,s.jsxs)(n.p,{children:["Voc\xea pode usar ",(0,s.jsx)(n.code,{children:"expect.extend"}),' para adicionar seus pr\xf3prios "matchers" em Jest. Por exemplo, vamos dizer que voc\xea esta testando uma biblioteca de n\xfameros e voc\xea esta frequentemente afirmando que os n\xfameros aparecem em intervalos espec\xedficos de outros n\xfameros. Voc\xea pode abstrair isso dentro do matcher ',(0,s.jsx)(n.code,{children:"toBeWithinRange"}),":"]}),"\n",(0,s.jsxs)(a.Z,{groupId:"code-examples",children:[(0,s.jsxs)(r.Z,{value:"js",label:"JavaScript",children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'tab={"span":3} title="toBeWithinRange.js"',children:"import {expect} from '@jest/globals';\n\nfunction toBeWithinRange(actual, floor, ceiling) {\n  if (\n    typeof actual !== 'number' ||\n    typeof floor !== 'number' ||\n    typeof ceiling !== 'number'\n  ) {\n    throw new Error('These must be of type number!');\n  }\n\n  const pass = actual >= floor && actual <= ceiling;\n  if (pass) {\n    return {\n      message: () =>\n        `expected ${this.utils.printReceived(\n          actual,\n        )} not to be within range ${this.utils.printExpected(\n          `${floor} - ${ceiling}`,\n        )}`,\n      pass: true,\n    };\n  } else {\n    return {\n      message: () =>\n        `expected ${this.utils.printReceived(\n          actual,\n        )} to be within range ${this.utils.printExpected(\n          `${floor} - ${ceiling}`,\n        )}`,\n      pass: false,\n    };\n  }\n}\n\nexpect.extend({\n  toBeWithinRange,\n});\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:'title="__tests__/ranges.test.js"',children:"import {expect, test} from '@jest/globals';\nimport '../toBeWithinRange';\n\ntest('is within range', () => expect(100).toBeWithinRange(90, 110));\n\ntest('is NOT within range', () => expect(101).not.toBeWithinRange(0, 100));\n\ntest('asymmetric ranges', () => {\n  expect({apples: 6, bananas: 3}).toEqual({\n    apples: expect.toBeWithinRange(1, 10),\n    bananas: expect.not.toBeWithinRange(11, 20),\n  });\n});\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="toBeWithinRange.d.ts"',children:"// optionally add a type declaration, e.g. it enables autocompletion in IDEs\ndeclare module 'expect' {\n  interface AsymmetricMatchers {\n    toBeWithinRange(floor: number, ceiling: number): void;\n  }\n  interface Matchers<R> {\n    toBeWithinRange(floor: number, ceiling: number): R;\n  }\n}\n\nexport {};\n"})})]}),(0,s.jsxs)(r.Z,{value:"ts",label:"TypeScript",children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'tab={"span":2} title="toBeWithinRange.ts"',children:"import {expect} from '@jest/globals';\nimport type {MatcherFunction} from 'expect';\n\nconst toBeWithinRange: MatcherFunction<[floor: unknown, ceiling: unknown]> =\n  // `floor` and `ceiling` get types from the line above\n  // it is recommended to type them as `unknown` and to validate the values\n  function (actual, floor, ceiling) {\n    if (\n      typeof actual !== 'number' ||\n      typeof floor !== 'number' ||\n      typeof ceiling !== 'number'\n    ) {\n      throw new Error('These must be of type number!');\n    }\n\n    const pass = actual >= floor && actual <= ceiling;\n    if (pass) {\n      return {\n        message: () =>\n          // `this` context will have correct typings\n          `expected ${this.utils.printReceived(\n            actual,\n          )} not to be within range ${this.utils.printExpected(\n            `${floor} - ${ceiling}`,\n          )}`,\n        pass: true,\n      };\n    } else {\n      return {\n        message: () =>\n          `expected ${this.utils.printReceived(\n            actual,\n          )} to be within range ${this.utils.printExpected(\n            `${floor} - ${ceiling}`,\n          )}`,\n        pass: false,\n      };\n    }\n  };\n\nexpect.extend({\n  toBeWithinRange,\n});\n\ndeclare module 'expect' {\n  interface AsymmetricMatchers {\n    toBeWithinRange(floor: number, ceiling: number): void;\n  }\n  interface Matchers<R> {\n    toBeWithinRange(floor: number, ceiling: number): R;\n  }\n}\n"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'tab title="__tests__/ranges.test.ts"',children:"import {expect, test} from '@jest/globals';\nimport '../toBeWithinRange';\n\ntest('is within range', () => expect(100).toBeWithinRange(90, 110));\n\ntest('is NOT within range', () => expect(101).not.toBeWithinRange(0, 100));\n\ntest('asymmetric ranges', () => {\n  expect({apples: 6, bananas: 3}).toEqual({\n    apples: expect.toBeWithinRange(1, 10),\n    bananas: expect.not.toBeWithinRange(11, 20),\n  });\n});\n"})})]})]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["The type declaration of the matcher can live in a ",(0,s.jsx)(n.code,{children:".d.ts"})," file or in an imported ",(0,s.jsx)(n.code,{children:".ts"})," module (see JS and TS examples above respectively). If you keep the declaration in a ",(0,s.jsx)(n.code,{children:".d.ts"})," file, make sure that it is included in the program and that it is a valid module, i.e. it has at least an empty ",(0,s.jsx)(n.code,{children:"export {}"}),"."]})}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsxs)(n.p,{children:["Instead of importing ",(0,s.jsx)(n.code,{children:"toBeWithinRange"})," module to the test file, you can enable the matcher for all tests by moving the ",(0,s.jsx)(n.code,{children:"expect.extend"})," call to a ",(0,s.jsx)(n.a,{href:"Configuration.md/#setupfilesafterenv-array",children:(0,s.jsx)(n.code,{children:"setupFilesAfterEnv"})})," script:"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import {expect} from '@jest/globals';\n// remember to export `toBeWithinRange` as well\nimport {toBeWithinRange} from './toBeWithinRange';\n\nexpect.extend({\n  toBeWithinRange,\n});\n"})})]}),"\n",(0,s.jsx)(n.h4,{id:"async-matchers",children:"Async Matchers"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.extend"})," also supports async matchers. Async matchers return a Promise so you will need to await the returned value. Let's use an example matcher to illustrate the usage of them. We are going to implement a matcher called ",(0,s.jsx)(n.code,{children:"toBeDivisibleByExternalValue"}),", where the divisible number is going to be pulled from an external source."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"expect.extend({\n  async toBeDivisibleByExternalValue(received) {\n    const externalValue = await getExternalValueFromRemoteSource();\n    const pass = received % externalValue == 0;\n    if (pass) {\n      return {\n        message: () =>\n          `expected ${received} not to be divisible by ${externalValue}`,\n        pass: true,\n      };\n    } else {\n      return {\n        message: () =>\n          `expected ${received} to be divisible by ${externalValue}`,\n        pass: false,\n      };\n    }\n  },\n});\n\ntest('is divisible by external value', async () => {\n  await expect(100).toBeDivisibleByExternalValue();\n  await expect(101).not.toBeDivisibleByExternalValue();\n});\n"})}),"\n",(0,s.jsx)(n.h4,{id:"custom-matchers-api",children:"Custom Matchers API"}),"\n",(0,s.jsxs)(n.p,{children:["Os Matchers devem retornar um objeto (ou uma Promessa de um objeto) com duas chaves. ",(0,s.jsx)(n.code,{children:"pass"})," indica se houve ou n\xe3o uma correspond\xeancia, e ",(0,s.jsx)(n.code,{children:"message"})," fornece uma fun\xe7\xe3o sem argumentos que retorna uma mensagem de erro em caso de falha. Assim, quando ",(0,s.jsx)(n.code,{children:"pass"})," \xe9 falso, ",(0,s.jsx)(n.code,{children:"message"})," deve retornar a mensagem de erro quando ",(0,s.jsx)(n.code,{children:"expect(x).yourMatcher()"})," falha. E quando ",(0,s.jsx)(n.code,{children:"pass"})," \xe9 verdadeiro, a ",(0,s.jsx)(n.code,{children:"mensagem"})," deve retornar a mensagem de erro quando ",(0,s.jsx)(n.code,{children:"expect(x).not.yourMatcher()"})," falha."]}),"\n",(0,s.jsxs)(n.p,{children:["Matchers s\xe3o chamados com o argumento passado para ",(0,s.jsx)(n.code,{children:"expect(x)"})," seguido dos argumentos passados para ",(0,s.jsx)(n.code,{children:".yourMatcher(y, z)"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"expect.extend({\n  yourMatcher(x, y, z) {\n    return {\n      pass: true,\n      message: () => '',\n    };\n  },\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Essas fun\xe7\xf5es e propriedades auxiliares podem ser encontradas em ",(0,s.jsx)(n.code,{children:"este"}),' dentro de um "matcher" personalizado:']}),"\n",(0,s.jsx)(n.h4,{id:"thisisnot",children:(0,s.jsx)(n.code,{children:"this.isNot"})}),"\n",(0,s.jsxs)(n.p,{children:['Um valor booleano para que voc\xea saiba que este "matcher" foi chamado com o negado ',(0,s.jsx)(n.code,{children:".not"}),' modificador permitindo que voc\xea exiba uma dica de "matcher" clara e correta (veja c\xf3digo de exemplo).']}),"\n",(0,s.jsx)(n.h4,{id:"thispromise",children:(0,s.jsx)(n.code,{children:"this.promise"})}),"\n",(0,s.jsx)(n.p,{children:'Uma string permitindo que voc\xea exiba uma dica de "matcher" clara e correta:'}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"'rejects'"})," if matcher was called with the promise ",(0,s.jsx)(n.code,{children:".rejects"})," modifier"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"'resolves'"})," if matcher was called with the promise ",(0,s.jsx)(n.code,{children:".resolves"})," modifier"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"''"})," if matcher was not called with a promise modifier"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"thisequalsa-b-customtesters-1",children:(0,s.jsx)(n.code,{children:"this.equals(a, b, customTesters?)"})}),"\n",(0,s.jsxs)(n.p,{children:["Esta \xe9 uma fun\xe7\xe3o de igualdade profunda que retornar\xe1 ",(0,s.jsx)(n.code,{children:"true"})," se dois objetos t\xeam os mesmos valores (recursivamente). It optionally takes a list of custom equality testers to apply to the deep equality checks (see ",(0,s.jsx)(n.code,{children:"this.customTesters"})," below)."]}),"\n",(0,s.jsx)(n.h4,{id:"thisexpand",children:(0,s.jsx)(n.code,{children:"this.expand"})}),"\n",(0,s.jsxs)(n.p,{children:['Um valor booleano para que voc\xea saiba que este "matcher" foi chamado com uma op\xe7\xe3o de ',(0,s.jsx)(n.code,{children:"expand"}),". When Jest is called with the ",(0,s.jsx)(n.code,{children:"--expand"})," flag, ",(0,s.jsx)(n.code,{children:"this.expand"})," can be used to determine if Jest is expected to show full diffs and errors."]}),"\n",(0,s.jsx)(n.h4,{id:"thisutils",children:(0,s.jsx)(n.code,{children:"this.utils"})}),"\n",(0,s.jsxs)(n.p,{children:["There are a number of helpful tools exposed on ",(0,s.jsx)(n.code,{children:"this.utils"})," primarily consisting of the exports from ",(0,s.jsx)(n.a,{href:"https://github.com/jestjs/jest/tree/main/packages/jest-matcher-utils",children:(0,s.jsx)(n.code,{children:"jest-matcher-utils"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Os mais \xfateis s\xe3o ",(0,s.jsx)(n.code,{children:"matcherHint"}),", ",(0,s.jsx)(n.code,{children:"printExpected"})," e ",(0,s.jsx)(n.code,{children:"printReceived"}),' para formatar bem as mensagens de erro. Por exemplo, d\xea uma olhada na implementa\xe7\xe3o para o "matcher" ',(0,s.jsx)(n.code,{children:"toBe"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {diff} = require('jest-diff');\nexpect.extend({\n  toBe(received, expected) {\n    const options = {\n      comment: 'Object.is equality',\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n\n    const pass = Object.is(received, expected);\n\n    const message = pass\n      ? () =>\n          // eslint-disable-next-line prefer-template\n          this.utils.matcherHint('toBe', undefined, undefined, options) +\n          '\\n\\n' +\n          `Expected: not ${this.utils.printExpected(expected)}\\n` +\n          `Received: ${this.utils.printReceived(received)}`\n      : () => {\n          const diffString = diff(expected, received, {\n            expand: this.expand,\n          });\n          return (\n            // eslint-disable-next-line prefer-template\n            this.utils.matcherHint('toBe', undefined, undefined, options) +\n            '\\n\\n' +\n            (diffString && diffString.includes('- Expect')\n              ? `Difference:\\n\\n${diffString}`\n              : `Expected: ${this.utils.printExpected(expected)}\\n` +\n                `Received: ${this.utils.printReceived(received)}`)\n          );\n        };\n\n    return {actual: received, message, pass};\n  },\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Isto imprimir\xe1 algo como:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'  expect(received).toBe(expected)\n\n    Expected value to be (using Object.is):\n      "banana"\n    Received:\n      "apple"\n'})}),"\n",(0,s.jsx)(n.p,{children:"Quando uma verifica\xe7\xe3o falha, a mensagem de erro deve dar o m\xe1ximo de informa\xe7\xe3o necess\xe1ria para o usu\xe1rio, para que eles possam resolver seu problema rapidamente. Voc\xea deve criar uma mensagem de falha precisa para certificar-se de que os usu\xe1rios de suas verifica\xe7\xf5es personalizados tenham uma boa experi\xeancia de desenvolvimento."}),"\n",(0,s.jsx)(n.h4,{id:"thiscustomtesters",children:(0,s.jsx)(n.code,{children:"this.customTesters"})}),"\n",(0,s.jsxs)(n.p,{children:["If your matcher does a deep equality check using ",(0,s.jsx)(n.code,{children:"this.equals"}),", you may want to pass user-provided custom testers to ",(0,s.jsx)(n.code,{children:"this.equals"}),". The custom equality testers the user has provided using the ",(0,s.jsx)(n.code,{children:"addEqualityTesters"})," API are available on this property. The built-in Jest matchers pass ",(0,s.jsx)(n.code,{children:"this.customTesters"})," (along with other built-in testers) to ",(0,s.jsx)(n.code,{children:"this.equals"})," to do deep equality, and your custom matchers may want to do the same."]}),"\n",(0,s.jsx)(n.h4,{id:"custom-snapshot-matchers",children:"Custom snapshot matchers"}),"\n",(0,s.jsxs)(n.p,{children:["To use snapshot testing inside of your custom matcher you can import ",(0,s.jsx)(n.code,{children:"jest-snapshot"})," and use it from within your matcher."]}),"\n",(0,s.jsxs)(n.p,{children:["Here's a snapshot matcher that trims a string to store for a given length, ",(0,s.jsx)(n.code,{children:".toMatchTrimmedSnapshot(length)"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {toMatchSnapshot} = require('jest-snapshot');\n\nexpect.extend({\n  toMatchTrimmedSnapshot(received, length) {\n    return toMatchSnapshot.call(\n      this,\n      received.substring(0, length),\n      'toMatchTrimmedSnapshot',\n    );\n  },\n});\n\nit('stores only 10 characters', () => {\n  expect('extra long string oh my gerd').toMatchTrimmedSnapshot(10);\n});\n\n/* Stored snapshot will look like:\n\nexports[`stores only 10 characters: toMatchTrimmedSnapshot 1`] = `\"extra long\"`;\n*/\n"})}),"\n",(0,s.jsx)(n.p,{children:'Tamb\xe9m \xe9 poss\xedvel criar "matchers" personalizados para snapshots em linhas, os snapshots ser\xe3o adicionados corretamente aos "matchers" personalizados. No entanto, o snapshot em linha sempre tentar\xe1 anexar ao primeiro argumento ou ao segundo quando o primeiro argumento for o matcher da propriedade, portanto, n\xe3o \xe9 poss\xedvel aceitar argumentos personalizados nos "matchers" personalizados.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {toMatchInlineSnapshot} = require('jest-snapshot');\n\nexpect.extend({\n  toMatchTrimmedInlineSnapshot(received, ...rest) {\n    return toMatchInlineSnapshot.call(this, received.substring(0, 10), ...rest);\n  },\n});\n\nit('stores only 10 characters', () => {\n  expect('extra long string oh my gerd').toMatchTrimmedInlineSnapshot();\n  /*\n  The snapshot will be added inline like\n  expect('extra long string oh my gerd').toMatchTrimmedInlineSnapshot(\n    `\"extra long\"`\n  );\n  */\n});\n"})}),"\n",(0,s.jsx)(n.h4,{id:"async",children:"async"}),"\n",(0,s.jsxs)(n.p,{children:["Se o seu snapshot em linha personalizado estiver ass\xedncrono, Use ",(0,s.jsx)(n.code,{children:"async"}),"-",(0,s.jsx)(n.code,{children:"await"}),' talvez voc\xea possa encontrar um erro como "M\xfaltiplos snapshots em linha para a mesma chamada n\xe3o s\xe3o suportados". Jest needs additional context information to find where the custom inline snapshot matcher was used to update the snapshots properly.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {toMatchInlineSnapshot} = require('jest-snapshot');\n\nexpect.extend({\n  async toMatchObservationInlineSnapshot(fn, ...rest) {\n    // The error (and its stacktrace) must be created before any `await`\n    this.error = new Error();\n\n    // The implementation of `observe` doesn't matter.\n    // It only matters that the custom snapshot matcher is async.\n    const observation = await observe(async () => {\n      await fn();\n    });\n\n    return toMatchInlineSnapshot.call(this, recording, ...rest);\n  },\n});\n\nit('observes something', async () => {\n  await expect(async () => {\n    return 'async action';\n  }).toMatchTrimmedInlineSnapshot();\n  /*\n  The snapshot will be added inline like\n  await expect(async () => {\n    return 'async action';\n  }).toMatchTrimmedInlineSnapshot(`\"async action\"`);\n  */\n});\n"})}),"\n",(0,s.jsx)(n.h4,{id:"bail-out",children:"Bail out"}),"\n",(0,s.jsxs)(n.p,{children:["Usually ",(0,s.jsx)(n.code,{children:"jest"})," tries to match every snapshot that is expected in a test."]}),"\n",(0,s.jsx)(n.p,{children:"Sometimes it might not make sense to continue the test if a prior snapshot failed. For example, when you make snapshots of a state-machine after various transitions you can abort the test once one transition produced the wrong state."}),"\n",(0,s.jsx)(n.p,{children:"In that case you can implement a custom snapshot matcher that throws on the first mismatch instead of collecting every mismatch."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {toMatchInlineSnapshot} = require('jest-snapshot');\n\nexpect.extend({\n  toMatchStateInlineSnapshot(...args) {\n    this.dontThrow = () => {};\n\n    return toMatchInlineSnapshot.call(this, ...args);\n  },\n});\n\nlet state = 'initial';\n\nfunction transition() {\n  // Typo in the implementation should cause the test to fail\n  if (state === 'INITIAL') {\n    state = 'pending';\n  } else if (state === 'pending') {\n    state = 'done';\n  }\n}\n\nit('transitions as expected', () => {\n  expect(state).toMatchStateInlineSnapshot(`\"initial\"`);\n\n  transition();\n  // Already produces a mismatch. No point in continuing the test.\n  expect(state).toMatchStateInlineSnapshot(`\"loading\"`);\n\n  transition();\n  expect(state).toMatchStateInlineSnapshot(`\"done\"`);\n});\n"})})]})}const x=function(e={}){const{wrapper:n}=Object.assign({},(0,o.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(m,e)})):m(e)}},2353:(e,n,t)=>{t.d(n,{ZP:()=>r});var s=t(4246),o=t(1670);function a(e){const n=Object.assign({admonition:"admonition",p:"p",pre:"pre",code:"code",a:"a"},(0,o.ah)(),e.components);return(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.p,{children:"Os exemplos de TypeScript desta p\xe1gina s\xf3 funcionar\xe3o como documentados se voc\xea importar explicitamente APIs do Jest:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import {expect, jest, test} from '@jest/globals';\n"})}),(0,s.jsxs)(n.p,{children:["Consulte o guia ",(0,s.jsx)(n.a,{href:"/pt-BR/docs/getting-started#using-typescript",children:"Iniciando"})," para obter detalhes sobre como configurar Jest com TypeScript."]})]})}const r=function(e={}){const{wrapper:n}=Object.assign({},(0,o.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(a,e)})):a(e)}}}]);